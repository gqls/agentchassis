filepath = ./deployments/terraform/modules/strimzi-operator/variables.tf
variable "operator_namespace" {
  description = "Namespace to deploy the Strimzi Kafka operator into."
  type        = string
}

variable "watched_namespaces_list" {
  description = "List of namespaces for the Strimzi operator to watch."
  type        = list(string)
}

variable "strimzi_yaml_source_path" {
  description = "Path to the directory containing the Strimzi YAML files to apply (e.g., ./strimzi-yaml-0.45.0/install/cluster-operator/)."
  type        = string
}

variable "operator_deployment_yaml_filename" {
  description = "Filename of the main operator deployment YAML within the strimzi_yaml_source_path (used for trigger)."
  type        = string
  default     = "060-Deployment-strimzi-cluster-operator.yaml"
}

variable "cluster_kubeconfig_path" {
  description = "Path to the kubeconfig file for the target Kubernetes cluster."
  type        = string
  sensitive   = true
}-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/048-Crd-kafkamirrormaker2.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/030-ClusterRoleBinding-strimzi-cluster-operator-kafka-broker-delegation.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/023-amended-ClusterRole-strimzi-cluster-operator-role.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/045-Crd-kafkamirrormaker.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/042-Crd-strimzipodset.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/047-Crd-kafkaconnector.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/020-ClusterRole-strimzi-cluster-operator-role.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/049-Crd-kafkarebalance.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/021-ClusterRole-strimzi-cluster-operator-role.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/023-RoleBinding-strimzi-cluster-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/031-ClusterRole-strimzi-entity-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/030-ClusterRole-strimzi-kafka-broker.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/022-ClusterRole-strimzi-cluster-operator-role.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/033-ClusterRoleBinding-strimzi-cluster-operator-kafka-client-delegation.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/022-RoleBinding-strimzi-cluster-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/041-Crd-kafkaconnect.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/046-Crd-kafkabridge.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/010-ServiceAccount-strimzi-cluster-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/043-Crd-kafkatopic.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/020-RoleBinding-strimzi-cluster-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/04A-Crd-kafkanodepool.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/021-ClusterRoleBinding-strimzi-cluster-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/050-ConfigMap-strimzi-cluster-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/044-Crd-kafkauser.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/033-ClusterRole-strimzi-kafka-client.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/040-Crd-kafka.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/060-Deployment-strimzi-cluster-operator.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/added-clusterrolebinding-operator-watched.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/strimzi-yaml-0.45.0/031-RoleBinding-strimzi-cluster-operator-entity-operator-delegation.yaml
[File listed only - content not included]
-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/providers.tf
/*
provider "kubernetes" {
  config_path = "~/.kube/config_production_sydney"
}

provider "helm" {
  kubernetes {
    config_path = "~/.kube/config_production_sydney"
  }
}*/-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/main.tf
# This module assumes the namespaces (operator_namespace and watched_namespaces_list)
# are created by a separate configuration or exist.
# The main.tf in the instance directory (e.g., 030-strimzi-operator) will create them.

resource "null_resource" "apply_strimzi_operator_yaml" {
  triggers = {
    operator_deployment_sha1 = fileexists("${var.strimzi_yaml_source_path}/${var.operator_deployment_yaml_filename}") ? filesha1("${var.strimzi_yaml_source_path}/${var.operator_deployment_yaml_filename}") : ""
    watched_namespaces_trigger = join(",", var.watched_namespaces_list)
  }

  provisioner "local-exec" {
    command = "kubectl apply --namespace ${var.operator_namespace} --filename ${var.strimzi_yaml_source_path}/"
    environment = {
      KUBECONFIG = var.cluster_kubeconfig_path
    }
  }
}

-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/README.md
The file [060-Deployment-strimzi-cluster-operator.yaml](strimzi-yaml-0.45.0/060-Deployment-strimzi-cluster-operator.yaml)
was altered to add the namespaces that we want strimzi kafka to watch
s/b value: "kafka,personae,strimzi"
(not valueFrom: fieldRef: fieldPath: metadata.namespace)

all myproject namespaces in yamls have to be sed replaced or find/replaced to strimzi

added the clusterrolebinding added-clusterrolebinding-operator-watched.yaml in config dir

github of strimzi files is:
https://github.com/strimzi/strimzi-kafka-operator-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/outputs.tf
output "operator_namespace_used" {
  description = "Namespace where the Strimzi operator was deployed."
  value       = var.operator_namespace
}

output "watched_namespaces_configured" {
  description = "Namespaces the Strimzi operator is configured to watch."
  value       = var.watched_namespaces_list
}-------------------------------------------------
filepath = ./deployments/terraform/modules/strimzi-operator/versions.tf

terraform {
  required_version = ">=1.0"
  required_providers {
    helm = { source = "hashicorp/helm", version = "~> 2.17.0" }
    kubernetes = { source = "hashicorp/kubernetes", version = "~> 2.36.0"}
    null = { source = "hashicorp/null", version = "~> 3.2.4" }
  }
}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/terraform.tfvars
-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/variables.tf
variable "kafka_cr_namespace" {
  description = "Namespace where the Kafka CR will be applied (must be watched by Strimzi operator)."
  type        = string
}

variable "kafka_cr_yaml_file_path" {
  description = "Path to the Kafka Custom Resource YAML file."
  type        = string
}

variable "kubeconfig_path" {
  description = "Path to the kubeconfig file for the target Kubernetes cluster."
  type        = string
  sensitive   = true
}

variable "kube_context_name" {
  description = "The kubectl context to use for applying resources. Must be valid for the provided kubeconfig_path."
  type        = string
  # This will be provided by the calling component
}

# Variables to construct output values, assuming fixed naming conventions from Strimzi
variable "kafka_cr_cluster_name" {
  description = "The metadata.name of the Kafka cluster defined in the CR YAML."
  type        = string
}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/providers.tf
# terraform/environments/production/services-sydney/030-kafka-cluster/providers.tf
provider "kubernetes" {
  config_path = var.kubeconfig_path
}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/main.tf
resource "null_resource" "apply_kafka_cluster_cr" {
  triggers = {
    yaml_file_sha1 = fileexists(var.kafka_cr_yaml_file_path) ? filesha1(var.kafka_cr_yaml_file_path) : ""
    # Adding context and namespace to triggers to ensure re-apply if they change for some reason
    context_trigger   = var.kube_context_name
    namespace_trigger = var.kafka_cr_namespace
  }

  provisioner "local-exec" {
    command = "kubectl --kubeconfig=${var.kubeconfig_path} --context=${var.kube_context_name} apply --namespace ${var.kafka_cr_namespace} --filename ${var.kafka_cr_yaml_file_path}"
    # The KUBECONFIG env var is redundant if --kubeconfig is used in the command, but harmless.
    environment = {
      KUBECONFIG = var.kubeconfig_path
    }
  }
}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/kafkauser-permissive-test.yaml
# test-anonymous-broader-corrected.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaUser
metadata:
  name: test-anonymous-broader
  namespace: kafka
  labels:
    strimzi.io/cluster: personae-kafka-cluster
spec:
  authorization:
    type: simple
    acls:
      # Allow Describe on ALL topics
      - resource:
          type: topic
          name: "*"
          patternType: literal # For all topics, name should be "*" and patternType literal
        operations:
          - Describe
        host: "*"
      # Allow Describe on the cluster
      - resource:
          type: cluster # For 'cluster' type, no 'name' or 'patternType' needed in the resource block.
          # Strimzi implicitly uses 'kafka-cluster' as the resource name.
        operations:
          - Describe
        host: "*"-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/kafka-temp-fix.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: Kafka
metadata:
  name: personae-kafka-cluster
  namespace: kafka
spec:
  kafka:
    version: 3.9.0
    replicas: 1
    listeners:
      # We are defining ONLY the plaintext listener.
      - name: plain
        port: 9092
        type: internal
        tls: false
    config:
      offsets.topic.replication.factor: 1
      transaction.state.log.replication.factor: 1
      transaction.state.log.min.isr: 1
      default.replication.factor: 1
      min.insync.replicas: 1
      inter.broker.protocol.version: "3.9"
    storage:
      type: persistent-claim
      size: 1Gi
      deleteClaim: false
  zookeeper:
    replicas: 1
    storage:
      type: persistent-claim
      size: 1Gi
      deleteClaim: false
  entityOperator:
    topicOperator: {}
    userOperator: {}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/kafkauser-test.yaml
# modules/kafka_cluster/config/kafkauser-test.yaml
# test-anonymous-describe-user.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaUser
metadata:
  name: test-anonymous-describe
  namespace: kafka
  labels:
    strimzi.io/cluster: personae-kafka-cluster
spec:
  authorization:
    type: simple
    acls:
      - resource:
          type: topic
          name: personae-
          patternType: prefix
        host: "*"
        operations:
          - Describe
-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/kafka-cluster-cr-dev.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: Kafka
metadata:
  name: personae-kafka-cluster
  namespace: kafka
spec:
  kafka:
    version: 3.9.0
    replicas: 1
    listeners:
      - name: plain
        port: 9092
        type: internal
        tls: false
    storage:
      type: persistent-claim
      size: 1Gi
      deleteClaim: false # Match working config
    config:
      default.replication.factor: 1
      min.insync.replicas: 1
      inter.broker.protocol.version: "3.9"
      log.message.format.version: "3.9"
      log.retention.hours: "160"
      log4j.logger.kafka.authorizer.logger: INFO
      offsets.topic.replication.factor: 1
      transaction.state.log.replication.factor: 1
      transaction.state.log.min.isr: 1
    resources:
      requests:
        memory: "512Mi"
        cpu: "300m"
      limits:
        memory: "1000Mi"
        cpu: "500"
  zookeeper:
    replicas: 1
    resources:
      requests:
        memory: "250Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"
    storage:
      type: persistent-claim
      size: 1Gi
      deleteClaim: false # Match working config
  entityOperator:
    topicOperator:
      reconciliationIntervalMs: 90000
    userOperator: {}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/personae-app-anonymous-v2.yaml
# personae-app-anonymous-V2.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaUser
metadata:
  name: personae-app-anonymous
  namespace: kafka
  labels:
    strimzi.io/cluster: personae-kafka-cluster
spec:
  authorization:
    type: simple
    acls:
      # For init containers & tools to describe specific topics
      - resource:
          type: topic
          name: personae-core-requests # Be very specific for the test topic
          patternType: literal
        operations: [ Describe ]
        host: "*"
      # For init containers & tools to list/describe all topics (if needed)
      - resource:
          type: topic
          name: "*" # All topics
          patternType: literal
        operations: [ Describe ]
        host: "*"
      # For applications to Read/Write their topics
      - resource:
          type: topic
          name: personae- # Topics starting with "personae-"
          patternType: prefix
        operations: [ Read, Write, Create, Describe ] # Describe is good for apps too
        host: "*"

      # For applications and tools to describe the cluster (often needed for metadata)
      - resource:
          type: cluster
        operations: [ Describe ]
        host: "*"

      # For personae-core-manager consumer group (explicit literal match)
      - resource:
          type: group
          name: personae-core-manager # Explicit name
          patternType: literal
        operations: [ Read, Describe ] # Read is for consuming offsets, Describe for FindCoordinator etc.
        host: "*"
      # General describe for any other group (e.g., if other agents use different group names)
      - resource:
          type: group
          name: "*"
          patternType: literal
        operations: [ Describe ]
        host: "*"-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/personae-app-anonymous.yaml
# personae-app-anonymous-access.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaUser
metadata:
  name: personae-app-anonymous
  namespace: kafka # Users must be in the same namespace as the Kafka cluster
  labels:
    strimzi.io/cluster: personae-kafka-cluster
spec:
  # No authentication block: applies to User:ANONYMOUS
  authorization:
    type: simple
    acls:
      # For init containers and apps to find/describe topics
      - resource:
          type: topic
          name: personae- # Topics starting with "personae-"
          patternType: prefix
        operations:
          - Describe
          - Read    # For consumers
          - Write   # For producers (if any agents produce to these)
          - Create  # If apps/producers might create them (less likely if Strimzi manages topics)
        host: "*"

      # For consumers to operate on their groups
      # Assuming consumer group names might also start with "personae-" or are related
      - resource:
          type: group
          name: personae- # Consumer groups starting with "personae-"
          patternType: prefix # Adjust if group names are different
        operations:
          - Read
          - Describe
          # - Delete # If consumers manage their own offset commits and group membership actively
        host: "*"

      # For consumers to find their coordinator (often needs Describe on a group)
      # The previous rule for group 'personae-' prefix should cover FindCoordinator for those groups.
      # If using arbitrary group names, you'd need a broader group rule like:
      - resource:
          type: group
          name: "*" # Or a more specific group prefix/name if known
          patternType: literal
        operations:
          - Describe # For FindCoordinator for any group
          # - Read # Be cautious with Read on group "*"
        host: "*"

      # General cluster describe, often needed by tools and sometimes clients
      - resource:
          type: cluster
        operations:
          - Describe
        host: "*"-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/kafka-cluster-cr.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: Kafka
metadata:
  name: personae-kafka-cluster
  namespace: kafka
spec:
  kafka:
    version: 3.9.0 # Match operator compatibility
    replicas: 3
    listeners:
      - name: plain
        port: 9092
        type: internal
        tls: false
      - name: tls
        port: 9093
        type: internal
        tls: true
    storage:
      type: persistent-claim
      size: 100Gi
      class: ssd-large
      deleteClaim: false # Match working config
    config:
      default.replication.factor: 3
      min.insync.replicas: 2
      inter.broker.protocol.version: "3.9"
      log.message.format.version: "3.9"
      log.retention.hours: "160"
      log4j.logger.kafka.authorizer.logger: INFO
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "1500Mi"
        cpu: "1"
  zookeeper:
    replicas: 3
    resources:
      requests:
        memory: "512Mi" # Adjust
        cpu: "250m"
      limits:
        memory: "768Mi" # Adjust
        cpu: "500m"
    storage:
      type: persistent-claim
      size: 10Gi
      class: ssd
      deleteClaim: false # Match working config
  entityOperator:
    topicOperator:
      reconciliationIntervalMs: 90000
    userOperator: {}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/config/kafka-kraft-cluster.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: Kafka
metadata:
  name: personae-kafka-cluster
  namespace: kafka
  annotations:
    strimzi.io/kraft: "enabled"
spec:
  kafka:
    version: 3.9.0
    replicas: 1
    listeners:
      - name: plain
        port: 9092
        type: internal
        tls: false
      - name: tls
        port: 9093
        type: internal
        tls: true
    config:
      # Single-node compatible settings
      default.replication.factor: 1
      min.insync.replicas: 1
      inter.broker.protocol.version: "3.9"
      log.retention.hours: 160
      offsets.topic.replication.factor: 1
      transaction.state.log.replication.factor: 1
      transaction.state.log.min.isr: 1
    storage:
      type: persistent-claim
      size: 1Gi
      deleteClaim: false
    resources:
      requests:
        memory: 512Mi
        cpu: 300m
      limits:
        memory: 1000Mi
        cpu: 500m
    # KRaft mode - no separate ZooKeeper needed
    metadataVersion: 3.9-IV4
  # No zookeeper section needed for KRaft
  entityOperator:
    topicOperator:
      reconciliationIntervalMs: 90000
    userOperator: {}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/README.md
when trying to deploy using a kubernetes_manifest for this kafka CRD it continually bugged out when setting config variables, so we are doing it using null_resource kubectl apply ...

this didn't work:
resource "kubernetes_manifest" "kafka_cluster" {
manifest = {
"apiVersion" = "kafka.strimzi.io/v1beta2"
"kind"       = "Kafka"
"metadata" = {
"name"      = var.kafka_cluster_name
"namespace" = var.kafka_cluster_namespace
}
"spec" = {
"kafka" = {
"version"  = var.kafka_version
"replicas" = var.kafka_replicas
"listeners" = [ # Minimal listeners
{ "name": "plain", "port": 9092, "type": "internal", "tls": false },
{ "name" = "tls", "port" = 9093, "type" = "internal", "tls"  = true }
]
"storage" = merge( # Assuming you kept the merge logic for class
{
"type" = "persistent-claim"
"size" = var.kafka_persistent_claim_size
},
var.kafka_persistent_claim_storage_class == null ? {} : { "class" = var.kafka_persistent_claim_storage_class
}
),
"config" = var.kafka_config
}
"entityOperator" = {
"topicOperator" = var.enable_topic_operator ? {} : null
"userOperator"  = var.enable_user_operator ? {} : null
}
}
}
computed_fields = [
"spec.kafka.config"
]
}

because of the "config" = va.kafka_config didn't read the map properly:
variable "kafka_config" {
description = "List of Kafka broker configuration overrides."
type        = map(string)
default = {
"log.message.format.version" = "4.0",
"log.retention.hours"        = "168"
}
}

I got:
terraform apply -auto-approve
kubernetes_manifest.kafka_cluster: Refreshing state...
╷
│ Error: Failed to update proposed state from prior state
│
│   with kubernetes_manifest.kafka_cluster,
│   on main.tf line 3, in resource "kubernetes_manifest" "kafka_cluster":
│    3: resource "kubernetes_manifest" "kafka_cluster" {
│
│ AttributeName("config"): can't use tftypes.Object["log.message.format.version":tftypes.String, "log.retention.hours":tftypes.String] as
│ tftypes.Map[tftypes.String]
╵
-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/outputs.tf
# terraform/modules/kafka_cluster/outputs.tf
output "cluster_name_applied" {
  description = "The name of the Kafka cluster that was applied."
  value       = var.kafka_cr_cluster_name
}

output "cluster_namespace_applied" {
  description = "The namespace where the Kafka cluster CR was applied."
  value       = var.kafka_cr_namespace
}

output "bootstrap_servers_plain" {
  description = "Assumed Internal Plaintext Bootstrap Servers."
  value       = "${var.kafka_cr_cluster_name}-kafka-bootstrap.${var.kafka_cr_namespace}.svc:9092"
}

output "bootstrap_servers_tls" {
  description = "Assumed Internal TLS Bootstrap Servers."
  value       = "${var.kafka_cr_cluster_name}-kafka-bootstrap.${var.kafka_cr_namespace}.svc:9093"
}-------------------------------------------------
filepath = ./deployments/terraform/modules/kafka-cluster/versions.tf
terraform {
  required_providers {
    kubernetes = { # Needed if you want to add data sources for services later, but not strictly for null_resource
      source  = "hashicorp/kubernetes"
      version = "~> 2.36.0"
    }
    null = {
      source  = "hashicorp/null"
      version = "~> 3.2.4"
    }
  }
  required_version = ">= 1.0"
}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/030-strimzi-operator/terraform.tfvars
-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/030-strimzi-operator/variables.tf
variable "kube_context_name" {
  description = "The Kubernetes context name for Kind."
  type        = string
  default = "kind-personae-dev"
}

variable "kubeconfig_path" {
  description = "Optional path to kubeconfig YAML file."
  type        = string
  default     = null # If null, a default single-node cluster is created
}

variable "strimzi_operator_dev_namespace" {
  description = "Namespace for the Strimzi operator in dev."
  type        = string
  default     = "strimzi" // Operator's own namespace
}

variable "watched_namespaces_dev" {
  description = "List of namespaces for the Strimzi operator to watch in dev."
  type        = list(string)
  default     = ["kafka", "personae"] // Strimzi will watch 'kafka' for Kafka CRs and 'personae' if KafkaUsers are there
}

variable "strimzi_yaml_bundle_path_dev" {
  description = "Path to the Strimzi YAML files directory for dev."
  type        = string
  # Path relative to this file's directory, pointing to the module's shared Strimzi YAMLs
  default     = "../../../../modules/strimzi_operator/strimzi-yaml-0.45.0/"
}

variable "strimzi_operator_deployment_yaml_filename_dev" {
description = "Filename of the main operator deployment YAML."
type        = string
default     = "060-Deployment-strimzi-cluster-operator.yaml"
}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/030-strimzi-operator/providers.tf
provider "kubernetes" {
  config_path    = "~/.kube/config"
  config_context = var.kube_context_name
}

provider "null" {} // If your module uses null_resource-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/030-strimzi-operator/main.tf
# Ensure the namespaces Strimzi will operate in or watch exist.
# Strimzi operator's own namespace:
resource "kubernetes_namespace" "operator_ns" {
  metadata {
    name = var.strimzi_operator_dev_namespace // e.g., "strimzi"
  }
}

# Namespace for Kafka clusters (watched by Strimzi):
resource "kubernetes_namespace" "kafka_cluster_ns" {
  metadata {
    name = "kafka" // Assuming Kafka CRs will be in 'kafka' namespace
  }
}

# Namespace for Personae app (if Strimzi needs to manage KafkaUsers there):
resource "kubernetes_namespace" "personae_app_ns" {
  metadata {
    name = "personae" // Assuming Personae app and potentially KafkaUsers are in 'personae'
  }
}

module "strimzi_operator" {
  source = "../../../../modules/strimzi_operator"

  operator_namespace                = kubernetes_namespace.operator_ns.metadata[0].name
  watched_namespaces_list           = var.watched_namespaces_dev
  strimzi_yaml_source_path          = var.strimzi_yaml_bundle_path_dev
  operator_deployment_yaml_filename = var.strimzi_operator_deployment_yaml_filename_dev
  cluster_kubeconfig_path           = "" # Path to the kubeconfig Terraform should use

  depends_on = [
    kubernetes_namespace.operator_ns,
    kubernetes_namespace.kafka_cluster_ns,
    kubernetes_namespace.personae_app_ns
  ]
}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/030-strimzi-operator/strimzi-rbac-terraform.tf
resource "kubernetes_cluster_role" "strimzi_kafka_namespace" {
  metadata {
    name = "strimzi-cluster-operator-kafka-namespace"
  }

  rule {
    api_groups = [""]
    resources  = ["pods", "services", "endpoints", "persistentvolumeclaims", "configmaps", "secrets", "serviceaccounts"]
    verbs      = ["get", "list", "watch", "create", "update", "patch", "delete"]
  }

  rule {
    api_groups = ["apps"]
    resources  = ["deployments", "statefulsets", "replicasets"]
    verbs      = ["get", "list", "watch", "create", "update", "patch", "delete"]
  }

  rule {
    api_groups = ["networking.k8s.io"]
    resources  = ["ingresses", "networkpolicies"]
    verbs      = ["get", "list", "watch", "create", "update", "patch", "delete"]
  }

  rule {
    api_groups = ["kafka.strimzi.io"]
    resources  = ["*"]
    verbs      = ["*"]
  }

  rule {
    api_groups = ["core.strimzi.io"]
    resources  = ["*"]
    verbs      = ["*"]
  }

  rule {
    api_groups = ["rbac.authorization.k8s.io"]
    resources  = ["roles", "rolebindings"]
    verbs      = ["get", "list", "watch", "create", "update", "patch", "delete"]
  }

  rule {
    api_groups = ["policy"]
    resources  = ["poddisruptionbudgets"]
    verbs      = ["get", "list", "watch", "create", "update", "patch", "delete"]
  }
}

resource "kubernetes_cluster_role_binding" "strimzi_kafka_namespace" {
  metadata {
    name = "strimzi-cluster-operator-kafka-namespace"
  }

  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "ClusterRole"
    name      = kubernetes_cluster_role.strimzi_kafka_namespace.metadata[0].name
  }

  subject {
    kind      = "ServiceAccount"
    name      = "strimzi-cluster-operator"
    namespace = "strimzi"
  }
}

resource "kubernetes_role_binding" "strimzi_kafka_namespace" {
  metadata {
    name      = "strimzi-cluster-operator-kafka-namespace"
    namespace = "kafka"
  }

  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "ClusterRole"
    name      = kubernetes_cluster_role.strimzi_kafka_namespace.metadata[0].name
  }

  subject {
    kind      = "ServiceAccount"
    name      = "strimzi-cluster-operator"
    namespace = "strimzi"
  }
}

resource "kubernetes_cluster_role_binding" "strimzi_entity_operator_delegation" {
  metadata {
    name = "strimzi-cluster-operator-entity-operator-delegation"
    labels = {
      app = "strimzi"
    }
  }

  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "ClusterRole"
    name      = "strimzi-entity-operator"
  }

  subject {
    kind      = "ServiceAccount"
    name      = "strimzi-cluster-operator"
    namespace = "strimzi"
  }
}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/030-strimzi-operator/outputs.tf
output "operator_namespace_used" {
  description = "Namespace where the Strimzi operator was deployed for dev."
  value       = module.strimzi_operator.operator_namespace_used
}

output "watched_namespaces_configured" {
  description = "Namespaces the Strimzi operator is configured to watch for dev."
  value       = module.strimzi_operator.watched_namespaces_configured
}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/040-kafka-cluster/terraform.tfvars
-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/040-kafka-cluster/variables.tf
variable "kube_context_name" {
  description = "The Kubernetes context name for Kind (e.g., kind-personae-dev)."
  type        = string
  default     = "kind-personae-dev"
}

variable "kubeconfig_path" { // Specific name for this component's var
  description = "Path to the kubeconfig file to be used for this dev component."
  type        = string
  default     = "~/.kube/config" // Default for Kind, overridden by Makefile if necessary
}

variable "kafka_namespace_dev" {
  description = "Namespace where the Kafka CR for dev will be deployed."
  type        = string
  default     = "kafka"
}

variable "kafka_cluster_cr_yaml_path_dev" {
  description = "Path to the Kafka CR YAML file for the dev instance."
  type        = string
  default     = "../../../../modules/kafka_cluster/config/kafka-cluster-cr-dev.yaml" // Point to your DEV version
}

variable "kafka_cluster_name_dev" {
  description = "The metadata.name of the Kafka cluster for dev."
  type        = string
  default     = "personae-kafka-cluster" // Should match the name in kafka-cluster-cr-dev.yaml
}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/040-kafka-cluster/providers.tf
provider "kubernetes" {
  config_path    = abspath(pathexpand(var.kubeconfig_path_for_dev))
  config_context = var.kube_context_name
}

provider "helm" {
  kubernetes {
    config_path    = abspath(pathexpand(var.kubeconfig_path_for_dev))
    config_context = var.kube_context_name
  }
}
provider "null" {}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/040-kafka-cluster/main.tf
module "kafka_cluster_dev" {
  source = "../../../../modules/kafka_cluster"

  kubeconfig_path         = abspath(pathexpand(var.kubeconfig_path))
  kube_context_name       = var.kube_context_name    // Pass the dev context name
  kafka_cr_namespace      = var.kafka_namespace_dev
  kafka_cr_yaml_file_path = var.kafka_cluster_cr_yaml_path_dev
  kafka_cr_cluster_name   = var.kafka_cluster_name_dev
}-------------------------------------------------
filepath = ./deployments/terraform/environments/development/uk_dev/040-kafka-cluster/outputs.tf
output "dev_kafka_cluster_name" {
  description = "Name of the Kafka cluster deployed in dev."
  value       = module.kafka_cluster_dev.cluster_name_applied
}

output "dev_kafka_cluster_namespace" {
  description = "Namespace of the Kafka cluster in dev."
  value       = module.kafka_cluster_dev.cluster_namespace_applied
}

output "dev_kafka_bootstrap_servers_plain" {
  description = "Internal Plaintext Bootstrap Servers for dev Kafka."
  value       = module.kafka_cluster_dev.bootstrap_servers_plain
}

output "dev_kafka_bootstrap_servers_tls" {
  description = "Internal TLS Bootstrap Servers for dev Kafka."
  value       = module.kafka_cluster_dev.bootstrap_servers_tls
}-------------------------------------------------
filepath = ./deployments/kustomize/infrastructure/kafka/kafka.yaml
apiVersion: v1
kind: Service
metadata:
  name: kafka-headless
  namespace: ai-persona-system
  labels:
    app: kafka
spec:
  ports:
    - port: 9092
      name: broker
    - port: 9093
      name: controller
  clusterIP: None
  selector:
    app: kafka

---
apiVersion: v1
kind: Service
metadata:
  name: kafka-ui
  namespace: ai-persona-system
spec:
  ports:
    - port: 8080
      targetPort: 8080
  selector:
    app: kafka-ui
  type: ClusterIP

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kafka
  namespace: ai-persona-system
spec:
  serviceName: kafka-headless
  replicas: 3
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      containers:
        - name: kafka
          image: confluentinc/cp-kafka:7.5.0
          ports:
            - containerPort: 9092
              name: broker
            - containerPort: 9093
              name: controller
          env:
            - name: KAFKA_NODE_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: KAFKA_PROCESS_ROLES
              value: "broker,controller"
            - name: KAFKA_LISTENERS
              value: "PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093"
            - name: KAFKA_ADVERTISED_LISTENERS
              value: "PLAINTEXT://$(KAFKA_NODE_ID).kafka-headless:9092"
            - name: KAFKA_CONTROLLER_LISTENER_NAMES
              value: "CONTROLLER"
            - name: KAFKA_LISTENER_SECURITY_PROTOCOL_MAP
              value: "CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT"
            - name: KAFKA_CONTROLLER_QUORUM_VOTERS
              value: "kafka-0@kafka-0.kafka-headless:9093,kafka-1@kafka-1.kafka-headless:9093,kafka-2@kafka-2.kafka-headless:9093"
            - name: KAFKA_LOG_DIRS
              value: "/var/lib/kafka/data"
            - name: KAFKA_AUTO_CREATE_TOPICS_ENABLE
              value: "false"
            - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR
              value: "3"
            - name: KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
              value: "3"
            - name: KAFKA_TRANSACTION_STATE_LOG_MIN_ISR
              value: "2"
            - name: KAFKA_DEFAULT_REPLICATION_FACTOR
              value: "3"
            - name: KAFKA_MIN_INSYNC_REPLICAS
              value: "2"
          volumeMounts:
            - name: kafka-storage
              mountPath: /var/lib/kafka/data
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
  volumeClaimTemplates:
    - metadata:
        name: kafka-storage
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: "standard"
        resources:
          requests:
            storage: 10Gi

---
# Kafka UI for monitoring
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka-ui
  namespace: ai-persona-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka-ui
  template:
    metadata:
      labels:
        app: kafka-ui
    spec:
      containers:
        - name: kafka-ui
          image: provectuslabs/kafka-ui:latest
          ports:
            - containerPort: 8080
          env:
            - name: KAFKA_CLUSTERS_0_NAME
              value: "ai-persona-cluster"
            - name: KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS
              value: "kafka-0.kafka-headless:9092,kafka-1.kafka-headless:9092,kafka-2.kafka-headless:9092"
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"-------------------------------------------------
filepath = ./deployments/kustomize/infrastructure/kafka/kustomization.yaml
-------------------------------------------------
