filepath = ./cmd/agent-chassis/main.go
// FILE: cmd/agent-chassis/main.go (updated)
package main

import (
	"context"
	"flag"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/gqls/agentchassis/platform/agentbase"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/logger"
	"go.uber.org/zap"
)

func main() {
	// Load configuration
	configPath := flag.String("config", "configs/agent-chassis.yaml", "Path to config file")
	flag.Parse()

	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Initialize logger
	appLogger, err := logger.New(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	defer appLogger.Sync()

	// Create context
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Initialize agent
	agent, err := agentbase.New(ctx, cfg, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize agent", zap.Error(err))
	}

	// Handle shutdown
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

	// Run agent in goroutine
	errCh := make(chan error, 1)
	go func() {
		if err := agent.Run(); err != nil {
			errCh <- err
		}
	}()

	// Wait for shutdown signal or error
	select {
	case <-sigCh:
		appLogger.Info("Shutdown signal received")
		cancel()
		if err := agent.Shutdown(); err != nil {
			appLogger.Error("Shutdown error", zap.Error(err))
		}
	case err := <-errCh:
		appLogger.Error("Agent failed", zap.Error(err))
		cancel()
		agent.Shutdown()
	}

	appLogger.Info("Agent stopped")
}
-------------------------------------------------
filepath = ./cmd/auth-service/docs/swagger.yaml
basePath: /api/v1
host: localhost:8081
info:
  contact:
    email: support@persona-platform.com
    name: AI Persona Support
  description: Authentication and authorization service for the AI Persona Platform
  license:
    name: Proprietary
  termsOfService: http://swagger.io/terms/
  title: Auth Service API
  version: "1.0"
paths: {}
securityDefinitions:
  Bearer:
    description: Type "Bearer" followed by a space and JWT token.
    in: header
    name: Authorization
    type: apiKey
swagger: "2.0"
-------------------------------------------------
filepath = ./cmd/auth-service/docs/swagger.json
{
    "swagger": "2.0",
    "info": {
        "description": "Authentication and authorization service for the AI Persona Platform",
        "title": "Auth Service API",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "AI Persona Support",
            "email": "support@persona-platform.com"
        },
        "license": {
            "name": "Proprietary"
        },
        "version": "1.0"
    },
    "host": "localhost:8081",
    "basePath": "/api/v1",
    "paths": {},
    "securityDefinitions": {
        "Bearer": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}-------------------------------------------------
filepath = ./cmd/auth-service/docs/docs.go
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "AI Persona Support",
            "email": "support@persona-platform.com"
        },
        "license": {
            "name": "Proprietary"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {},
    "securityDefinitions": {
        "Bearer": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8081",
	BasePath:         "/api/v1",
	Schemes:          []string{},
	Title:            "Auth Service API",
	Description:      "Authentication and authorization service for the AI Persona Platform",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
-------------------------------------------------
filepath = ./cmd/auth-service/swagger_endpoints.go
package main

// healthCheck godoc
// @Summary      Health check
// @Description  Check if the auth service is running and healthy
// @Tags         System
// @Accept       json
// @Produce      json
// @Success      200 {object} map[string]interface{} "Service is healthy"
// @Failure      503 {object} map[string]interface{} "Service unavailable"
// @Router       /health [get]
// @ID           healthCheck

// handleWebSocket godoc
// @Summary      WebSocket connection
// @Description  Establish a WebSocket connection for real-time communication
// @Tags         WebSocket
// @Success      101 {string} string "Switching Protocols"
// @Failure      400 {object} map[string]interface{} "Bad request"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      426 {object} map[string]interface{} "Upgrade required"
// @Router       /ws [get]
// @Security     Bearer
// @ID           websocketConnect
-------------------------------------------------
filepath = ./cmd/auth-service/docs.go
// Package main AI Persona Platform API
//
// The AI Persona Platform provides APIs for managing AI personas, authentication, and content generation.
//
// Authentication:
// All API endpoints (except auth endpoints) require a valid JWT token in the Authorization header:
// Authorization: Bearer <token>
//
// Rate Limiting:
// API calls are rate-limited based on your subscription tier:
// - Free: 100 requests/hour
// - Basic: 1000 requests/hour
// - Premium: 10000 requests/hour
// - Enterprise: Unlimited
//
//	Schemes: https, http
//	Host: api.personaplatform.com
//	BasePath: /
//	Version: 1.0.0
//	Contact: AI Persona Support<support@personaplatform.com>
//
//	Consumes:
//	- application/json
//
//	Produces:
//	- application/json
//
//	Security:
//	- BearerAuth: []
//
//	SecurityDefinitions:
//	BearerAuth:
//	  type: apiKey
//	  name: Authorization
//	  in: header
//	  description: "Type 'Bearer' followed by a space and the JWT token"
//
// swagger:meta
package main

import (
	_ "github.com/gqls/agentchassis/internal/auth-service/auth"
	_ "github.com/gqls/agentchassis/internal/auth-service/project"
	_ "github.com/gqls/agentchassis/internal/auth-service/subscription"
	_ "github.com/gqls/agentchassis/internal/auth-service/user"
)
-------------------------------------------------
filepath = ./cmd/auth-service/main.go
// FILE: cmd/auth-service/main.go

// @title Auth Service API
// @version 1.0
// @description Authentication and authorization service for the AI Persona Platform
// @termsOfService http://swagger.io/terms/

// @contact.name AI Persona Support
// @contact.email support@persona-platform.com

// @license.name Proprietary

// @host localhost:8081
// @BasePath /api/v1

// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

package main

import (
	"context"
	"errors"
	"flag"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/auth-service/admin"
	"github.com/gqls/agentchassis/internal/auth-service/auth"
	"github.com/gqls/agentchassis/internal/auth-service/gateway"
	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"github.com/gqls/agentchassis/internal/auth-service/middleware"
	"github.com/gqls/agentchassis/internal/auth-service/project"
	"github.com/gqls/agentchassis/internal/auth-service/subscription"
	"github.com/gqls/agentchassis/internal/auth-service/user"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/database"
	"github.com/gqls/agentchassis/platform/logger"
	"github.com/rs/cors"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"go.uber.org/zap"

	_ "github.com/gqls/agentchassis/cmd/auth-service/docs"
)

func main() {
	// --- Step 1: Load Configuration using the Platform Library ---
	configPath := flag.String("config", "configs/auth-service.yaml", "Path to config file")
	flag.Parse()

	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("CRITICAL: Failed to load configuration: %v", err)
	}

	// --- Step 2: Initialize Logger using the Platform Library ---
	appLogger, err := logger.New(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("CRITICAL: Failed to initialize logger: %v", err)
	}
	defer appLogger.Sync()

	appLogger.Info("Auth Service starting",
		zap.String("service_name", cfg.ServiceInfo.Name),
		zap.String("version", cfg.ServiceInfo.Version),
		zap.String("environment", cfg.ServiceInfo.Environment),
	)

	// --- Step 3: Initialize Database Connection using the Platform Library ---
	// The auth service uses MySQL.
	db, err := database.NewMySQLConnection(context.Background(), cfg.Infrastructure.AuthDatabase, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to connect to the auth database", zap.Error(err))
	}
	defer db.Close()

	// --- Step 4: Initialize All Services and Handlers ---

	// Extract JWT configuration from environment and config
	jwtSecret := os.Getenv("JWT_SECRET_KEY")
	if jwtSecret == "" {
		appLogger.Fatal("JWT_SECRET_KEY environment variable not set")
	}

	// Get JWT expiry from config
	jwtExpiryMinutes := 60 // default
	if cfg.Custom != nil {
		if expiry, ok := cfg.Custom["jwt_expiry_access_minutes"].(float64); ok {
			jwtExpiryMinutes = int(expiry)
		}
	}

	// Initialize JWT service
	jwtSvc, err := jwt.NewService(jwtSecret, jwtExpiryMinutes, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize JWT Service", zap.Error(err))
	}

	// Initialize repositories
	userRepo := user.NewRepository(db, appLogger)
	//adminRepo := admin.NewRepository(db, appLogger, nil) // admin repo doesn't need config
	projectRepo := project.NewRepository(db, appLogger)
	subscriptionRepo := subscription.NewRepository(db, appLogger)

	// Initialize services
	userSvc := user.NewService(userRepo, appLogger)
	authSvc := auth.NewService(userSvc, jwtSvc, appLogger)
	gatewaySvc := gateway.NewService(cfg, appLogger)
	subscriptionSvc := subscription.NewService(subscriptionRepo, appLogger)

	// Initialize handlers
	authHandlers := auth.NewHandlers(authSvc)
	userHandlers := user.NewHandlers(userSvc)
	projectHandler := project.NewHTTPHandler(projectRepo, appLogger)
	subscriptionHandlers := subscription.NewHandlers(subscriptionSvc)
	subscriptionAdminHandlers := subscription.NewAdminHandlers(subscriptionSvc, appLogger)
	gatewayHandler := gateway.NewHTTPHandler(gatewaySvc, appLogger)
	adminHandlers := admin.NewHandlers(userRepo, appLogger)

	// --- Step 5: Setup Routing and Middleware ---
	// Using Gin router for consistency with handlers
	router := gin.New()
	router.Use(gin.Recovery())

	// Public routes (no auth required)
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":  "healthy",
			"service": cfg.ServiceInfo.Name,
			"version": cfg.ServiceInfo.Version,
		})
	})

	// Auth endpoints (public)
	authGroup := router.Group("/api/v1/auth")
	{
		authGroup.POST("/register", authHandlers.HandleRegister)
		authGroup.POST("/login", authHandlers.HandleLogin)
		authGroup.POST("/refresh", authHandlers.HandleRefresh)
		authGroup.POST("/validate", authHandlers.HandleValidate)
		authGroup.POST("/logout", middleware.RequireAuth(jwtSvc, appLogger), authHandlers.HandleLogout)
	}

	// User endpoints (protected)
	userGroup := router.Group("/api/v1/user")
	userGroup.Use(middleware.RequireAuth(jwtSvc, appLogger))
	{
		userGroup.GET("/profile", userHandlers.HandleGetCurrentUser)
		userGroup.PUT("/profile", userHandlers.HandleUpdateCurrentUser)
		userGroup.POST("/password", userHandlers.HandleChangePassword)
		userGroup.DELETE("/delete", userHandlers.HandleDeleteAccount)
	}

	// Subscription endpoints (protected)
	subGroup := router.Group("/api/v1/subscription")
	subGroup.Use(middleware.RequireAuth(jwtSvc, appLogger))
	{
		subGroup.GET("", subscriptionHandlers.HandleGetSubscription)
		subGroup.GET("/usage", subscriptionHandlers.HandleGetUsageStats)
		subGroup.GET("/check-quota", subscriptionHandlers.HandleCheckQuota)
	}

	// Project endpoints (protected)
	projectGroup := router.Group("/api/v1/projects")
	projectGroup.Use(middleware.RequireAuth(jwtSvc, appLogger))
	{
		projectGroup.GET("", wrapHTTPHandler(projectHandler.ListProjects))
		projectGroup.POST("", wrapHTTPHandler(projectHandler.CreateProject))
		projectGroup.GET("/:id", wrapProjectHandler(projectHandler.GetProject))
		projectGroup.PUT("/:id", wrapProjectHandler(projectHandler.UpdateProject))
		projectGroup.DELETE("/:id", wrapProjectHandler(projectHandler.DeleteProject))
	}

	// Admin endpoints (protected + admin role)
	adminGroup := router.Group("/api/v1/admin")
	adminGroup.Use(middleware.RequireAuth(jwtSvc, appLogger))
	adminGroup.Use(middleware.RequireRole("admin"))
	{
		// User management (handled by auth-service)
		adminGroup.GET("/users", adminHandlers.HandleListUsers)
		adminGroup.GET("/users/:user_id", adminHandlers.HandleGetUser)
		adminGroup.PUT("/users/:user_id", adminHandlers.HandleUpdateUser)
		adminGroup.DELETE("/users/:user_id", adminHandlers.HandleDeleteUser)
		adminGroup.GET("/users/:user_id/activity", adminHandlers.HandleGetUserActivity)
		adminGroup.POST("/users/:user_id/permissions", adminHandlers.HandleGrantPermission)
		adminGroup.DELETE("/users/:user_id/permissions/:permission_name", adminHandlers.HandleRevokePermission)

		// Subscription management (handled by auth-service)
		adminGroup.GET("/subscriptions", subscriptionAdminHandlers.HandleListSubscriptions)
		adminGroup.POST("/subscriptions", subscriptionAdminHandlers.HandleCreateSubscription)
		adminGroup.PUT("/subscriptions/:user_id", wrapAdminSubscriptionHandler(subscriptionAdminHandlers.HandleUpdateSubscription))

		// Routes to be proxied to core-manager
		adminGroup.Any("/clients", gatewayHandler.HandleAdminRoutes)
		adminGroup.Any("/clients/*path", gatewayHandler.HandleAdminRoutes)
		adminGroup.Any("/system/*path", gatewayHandler.HandleAdminRoutes)
		adminGroup.Any("/workflows/*path", gatewayHandler.HandleAdminRoutes)
		adminGroup.Any("/agent-definitions/*path", gatewayHandler.HandleAdminRoutes)

	}

	// Gateway proxy endpoints (protected)
	gatewayGroup := router.Group("/api/v1")
	gatewayGroup.Use(middleware.RequireAuth(jwtSvc, appLogger))
	{
		// Template management (admin only)
		templateGroup := gatewayGroup.Group("/templates")
		templateGroup.Use(middleware.RequireRole("admin"))
		{
			templateGroup.Any("", gatewayHandler.HandleTemplateRoutes)
			templateGroup.Any("/*path", gatewayHandler.HandleTemplateRoutes)
		}

		// Instance management
		gatewayGroup.Any("/personas/instances", gatewayHandler.HandleInstanceRoutes)
		gatewayGroup.Any("/personas/instances/*path", gatewayHandler.HandleInstanceRoutes)
	}

	// WebSocket endpoint
	router.GET("/ws", middleware.RequireAuth(jwtSvc, appLogger), gatewayHandler.HandleWebSocket)

	setupSwaggerRoutes(router)

	// Apply CORS middleware
	allowedOrigins := []string{"*"} // default
	if cfg.Custom != nil {
		if origins, ok := cfg.Custom["allowed_origins"].([]interface{}); ok {
			allowedOrigins = make([]string, len(origins))
			for i, origin := range origins {
				allowedOrigins[i] = origin.(string)
			}
		}
	}

	corsConfig := cors.New(cors.Options{
		AllowedOrigins:   allowedOrigins,
		AllowedMethods:   []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Authorization", "Content-Type", "X-Requested-With"},
		AllowCredentials: true,
		MaxAge:           300,
	})

	// --- Step 6: Start Server and Handle Graceful Shutdown ---
	server := &http.Server{
		Addr:    ":" + cfg.Server.Port,
		Handler: corsConfig.Handler(router),
	}

	// Start server in a goroutine
	go func() {
		appLogger.Info("Auth Service listening", zap.String("address", server.Addr))
		if err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			appLogger.Fatal("Auth Service listen and serve error", zap.Error(err))
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	appLogger.Info("Shutdown signal received, shutting down auth server...")

	// Graceful shutdown with timeout
	ctxShutdown, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := server.Shutdown(ctxShutdown); err != nil {
		appLogger.Fatal("Auth Server forced to shutdown due to error", zap.Error(err))
	}
	appLogger.Info("Auth Server exited gracefully")
}

// wrapHTTPHandler wraps standard http handlers to work with gin
func wrapHTTPHandler(fn func(http.ResponseWriter, *http.Request)) gin.HandlerFunc {
	return func(c *gin.Context) {
		fn(c.Writer, c.Request)
	}
}

// wrapProjectHandler wraps project handlers that take an ID parameter
func wrapProjectHandler(fn func(http.ResponseWriter, *http.Request, string)) gin.HandlerFunc {
	return func(c *gin.Context) {
		id := c.Param("id")
		fn(c.Writer, c.Request, id)
	}
}

// wrapAdminSubscriptionHandler wraps the admin subscription update handler
func wrapAdminSubscriptionHandler(fn func(*gin.Context)) gin.HandlerFunc {
	return func(c *gin.Context) {
		// The user_id is already available as a URL parameter
		c.Set("param_user_id", c.Param("user_id"))
		fn(c)
	}
}

func setupSwaggerRoutes(router *gin.Engine) {
	// Swagger documentation route
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Redirect /api/docs to swagger UI
	router.GET("/api/docs", func(c *gin.Context) {
		c.Redirect(http.StatusMovedPermanently, "/swagger/index.html")
	})
}
-------------------------------------------------
filepath = ./cmd/web-search-adapter/main.go
// FILE: cmd/web-search-adapter/main.go
package main

import (
	"context"
	"flag"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gqls/agentchassis/internal/adapters/websearch"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/logger"
	"go.uber.org/zap"
)

func main() {
	configPath := flag.String("config", "configs/web-search-adapter.yaml", "Path to config file")
	flag.Parse()

	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	appLogger, err := logger.New(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	defer appLogger.Sync()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	adapter, err := websearch.NewAdapter(ctx, cfg, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize web search adapter", zap.Error(err))
	}

	go func() {
		if err := adapter.Run(); err != nil {
			appLogger.Error("Web search adapter failed", zap.Error(err))
			cancel()
		}
	}()

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	appLogger.Info("Shutdown signal received")

	cancel()
	time.Sleep(2 * time.Second)
	appLogger.Info("Web search adapter stopped")
}
-------------------------------------------------
filepath = ./cmd/reasoning-agent/Dockerfile
# FILE: Dockerfile.reasoning
# A dedicated Dockerfile for building the reasoning agent service.

# Stage 1: Build the application
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Copy modules and download dependencies
COPY go.mod go.sum ./
RUN go mod download

# Copy the entire project context
COPY . .

# Build the specific service binary
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o /app/reasoning-agent ./cmd/reasoning-agent

# Stage 2: Create the final small image
FROM alpine:latest
RUN apk --no-cache add ca-certificates

# Create a non-root user for security
RUN addgroup -S appgroup && adduser -S -G appgroup appuser

WORKDIR /app

# Copy only the compiled binary from the builder stage
COPY --from=builder /app/reasoning-agent /app/reasoning-agent

# Copy its specific configuration file
COPY configs/reasoning-agent.yaml /app/configs/reasoning-agent.yaml

RUN chown appuser:appgroup /app/reasoning-agent

USER appuser

# The command to run the service, pointing to its own config
CMD ["./reasoning-agent", "-config", "configs/reasoning-agent.yaml"]
-------------------------------------------------
filepath = ./cmd/reasoning-agent/main.go
// FILE: cmd/reasoning-agent/main.go
package main

import (
	"context"
	"flag"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gqls/agentchassis/internal/agents/reasoning"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/logger"
	"go.uber.org/zap"
)

func main() {
	configPath := flag.String("config", "configs/reasoning-agent.yaml", "Path to config file")
	flag.Parse()

	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	appLogger, err := logger.New(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	defer appLogger.Sync()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	agent, err := reasoning.NewAgent(ctx, cfg, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize reasoning agent", zap.Error(err))
	}

	// Start health endpoint HERE
	agent.StartHealthServer("9090")

	// Start the agent's main run loop in a goroutine
	go func() {
		if err := agent.Run(); err != nil {
			appLogger.Error("Reasoning agent failed to run", zap.Error(err))
			cancel()
		}
	}()

	// Wait for shutdown signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	appLogger.Info("Shutdown signal received, shutting down reasoning agent...")

	cancel()
	time.Sleep(2 * time.Second)
	appLogger.Info("Reasoning agent service stopped.")
}
-------------------------------------------------
filepath = ./cmd/core-manager/docs/swagger.yaml
info:
  contact: {}
paths: {}
swagger: "2.0"
-------------------------------------------------
filepath = ./cmd/core-manager/docs/swagger.json
{
    "swagger": "2.0",
    "info": {
        "contact": {}
    },
    "paths": {}
}-------------------------------------------------
filepath = ./cmd/core-manager/docs/docs.go
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {}
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "",
	Host:             "",
	BasePath:         "",
	Schemes:          []string{},
	Title:            "",
	Description:      "",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
-------------------------------------------------
filepath = ./cmd/core-manager/main.go
// FILE: cmd/core-manager/main.go
package main

import (
	"context"
	"errors"
	"flag"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gqls/agentchassis/internal/core-manager/api"

	// Platform packages
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/database"
	"github.com/gqls/agentchassis/platform/logger"

	"go.uber.org/zap"
)

func main() {
	// --- Step 1: Load Configuration using the Platform Library ---
	configPath := flag.String("config", "configs/core-manager.yaml", "Path to config file")
	flag.Parse()

	// Use the standardized platform loader
	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// --- Step 2: Initialize Logger using the Platform Library ---
	appLogger, err := logger.New(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	defer appLogger.Sync()

	appLogger.Info("Core Manager Service starting",
		zap.String("service_name", cfg.ServiceInfo.Name),
		zap.String("version", cfg.ServiceInfo.Version),
		zap.String("environment", cfg.ServiceInfo.Environment),
		zap.String("log_level", cfg.Logging.Level),
	)

	// Create a main context that can be cancelled for graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// --- Step 3: Initialize Database Connections using the Platform Library ---
	// 3a. Create connection pool for the Templates Database
	templatesPool, err := database.NewPostgresConnection(ctx, cfg.Infrastructure.TemplatesDatabase, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize templates database connection", zap.Error(err))
	}
	defer templatesPool.Close()

	// 3b. Create connection pool for the Clients Database
	clientsPool, err := database.NewPostgresConnection(ctx, cfg.Infrastructure.ClientsDatabase, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize clients database connection", zap.Error(err))
	}
	defer clientsPool.Close()

	// --- Step 4: Initialize and Start the API Server ---
	apiServer, err := api.NewServer(ctx, cfg, appLogger, templatesPool, clientsPool)
	if err != nil {
		appLogger.Fatal("Failed to initialize API server", zap.Error(err))
	}

	// Run the server in a goroutine so it doesn't block
	go func() {
		appLogger.Info("Starting HTTP server", zap.String("address", apiServer.Address()))
		if err := apiServer.Start(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			appLogger.Error("API server failed", zap.Error(err))
			cancel() // Trigger shutdown on server error
		}
	}()

	// --- Step 5: Handle Graceful Shutdown ---
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	receivedSignal := <-sigCh
	appLogger.Info("Shutdown signal received", zap.String("signal", receivedSignal.String()))

	// Graceful shutdown with timeout
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer shutdownCancel()

	if err := apiServer.Shutdown(shutdownCtx); err != nil {
		appLogger.Error("Error during graceful shutdown", zap.Error(err))
	}

	appLogger.Info("Core Manager Service stopped")
}
-------------------------------------------------
filepath = ./cmd/image-generator-adapter/main.go
// FILE: cmd/image-generator-adapter/main.go
package main

import (
	"context"
	"flag"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gqls/agentchassis/internal/adapters/imagegenerator"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/logger"
	"go.uber.org/zap"
)

func main() {
	configPath := flag.String("config", "configs/image-adapter.yaml", "Path to config file")
	flag.Parse()

	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	appLogger, err := logger.New(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	defer appLogger.Sync()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	adapter, err := imagegenerator.NewAdapter(ctx, cfg, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize image generator adapter", zap.Error(err))
	}

	// Start health endpoint HERE
	adapter.StartHealthServer("9090")

	// Start the adapter's main run loop in a goroutine
	go func() {
		if err := adapter.Run(); err != nil {
			appLogger.Error("Image generator adapter failed to run", zap.Error(err))
			cancel()
		}
	}()

	// Wait for shutdown signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	appLogger.Info("Shutdown signal received, shutting down image generator adapter...")

	cancel()
	time.Sleep(2 * time.Second)
	appLogger.Info("Image generator adapter stopped.")
}
-------------------------------------------------
filepath = ./internal/adapters/imagegenerator/adapter.go
// FILE: internal/adapters/imagegenerator/adapter.go (updated with circuit breaker)
package imagegenerator

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/errors"
	"github.com/gqls/agentchassis/platform/kafka"
	"github.com/gqls/agentchassis/platform/resilience"
	"github.com/gqls/agentchassis/platform/storage"
	"go.uber.org/zap"
)

const (
	requestTopic  = "system.adapter.image.generate"
	responseTopic = "system.responses.image"
	consumerGroup = "image-generator-adapter-group"
)

// RequestPayload defines the expected data for an image generation request
type RequestPayload struct {
	Action string `json:"action"`
	Data   struct {
		Prompt      string  `json:"prompt"`
		AspectRatio string  `json:"aspect_ratio,omitempty"`
		Style       string  `json:"style,omitempty"`
		Seed        float64 `json:"seed,omitempty"`
	} `json:"data"`
}

// ResponsePayload defines the data sent back after successful generation
type ResponsePayload struct {
	ImageURI string `json:"image_uri"`
	Prompt   string `json:"prompt"`
	Seed     int64  `json:"seed"`
}

// Adapter handles the translation between our internal system and an external API
type Adapter struct {
	ctx           context.Context
	logger        *zap.Logger
	consumer      *kafka.Consumer
	producer      kafka.Producer
	storageClient storage.Client
	httpClient    *resilience.HTTPClientWithBreaker
	externalAPI   string
	apiKey        string
}

// NewAdapter initializes all dependencies for the adapter
func NewAdapter(ctx context.Context, cfg *config.ServiceConfig, logger *zap.Logger) (*Adapter, error) {
	// Initialize Kafka consumer
	consumer, err := kafka.NewConsumer(cfg.Infrastructure.KafkaBrokers, requestTopic, consumerGroup, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create kafka consumer: %w", err)
	}

	// Initialize Kafka producer
	producer, err := kafka.NewProducer(cfg.Infrastructure.KafkaBrokers, logger)
	if err != nil {
		consumer.Close()
		return nil, fmt.Errorf("failed to create kafka producer: %w", err)
	}

	// Initialize Object Storage client
	storageClient, err := storage.NewS3Client(ctx, cfg.Infrastructure.ObjectStorage)
	if err != nil {
		consumer.Close()
		producer.Close()
		return nil, fmt.Errorf("failed to create storage client: %w", err)
	}

	// Setup HTTP client with circuit breaker
	baseClient := &http.Client{Timeout: 90 * time.Second}
	cbConfig := resilience.DefaultCircuitBreakerConfig("stability-ai")
	cbConfig.ConsecutiveFailures = 3
	cbConfig.FailureRatio = 0.5
	httpClient := resilience.NewHTTPClientWithBreaker(baseClient, cbConfig, logger)

	externalAPIEndpoint := "https://api.stability.ai/v1/generation/stable-diffusion-v1-6/text-to-image"
	apiKey := os.Getenv("STABILITY_API_KEY")

	return &Adapter{
		ctx:           ctx,
		logger:        logger,
		consumer:      consumer,
		producer:      producer,
		storageClient: storageClient,
		httpClient:    httpClient,
		externalAPI:   externalAPIEndpoint,
		apiKey:        apiKey,
	}, nil
}

// Run starts the consumer loop
func (a *Adapter) Run() error {
	for {
		select {
		case <-a.ctx.Done():
			a.consumer.Close()
			a.producer.Close()
			return nil
		default:
			msg, err := a.consumer.FetchMessage(a.ctx)
			if err != nil {
				if err == context.Canceled {
					continue
				}
				a.logger.Error("Failed to fetch message", zap.Error(err))
				continue
			}
			go a.handleMessage(msg)
		}
	}
}

// handleMessage processes a single image generation request
func (a *Adapter) handleMessage(msg kafka.Message) {
	headers := kafka.HeadersToMap(msg.Headers)
	l := a.logger.With(
		zap.String("correlation_id", headers["correlation_id"]),
		zap.String("request_id", headers["request_id"]),
	)

	var req RequestPayload
	if err := json.Unmarshal(msg.Value, &req); err != nil {
		l.Error("Failed to unmarshal request payload", zap.Error(err))
		a.sendErrorResponse(headers, errors.ValidationError("payload", "invalid JSON"))
		a.consumer.CommitMessages(context.Background(), msg)
		return
	}

	// Call the external API with circuit breaker protection
	imageData, err := a.callExternalImageAPI(req.Data.Prompt)
	if err != nil {
		l.Error("External image API call failed", zap.Error(err))

		// Check if it's a circuit breaker error
		if resilience.IsCircuitBreakerError(err) {
			retryAfter := 30 * time.Second
			a.sendErrorResponse(headers, errors.New(errors.ErrExternalService, "Image service temporarily unavailable").
				AsRetryable(&retryAfter).
				Build())
		} else {
			a.sendErrorResponse(headers, errors.New(errors.ErrAIServiceError, "Failed to generate image").
				WithCause(err).
				Build())
		}
		a.consumer.CommitMessages(context.Background(), msg)
		return
	}

	// Upload the resulting image to Object Storage
	fileName := fmt.Sprintf("images/%s/%s.png", headers["client_id"], uuid.NewString())
	imageURI, err := a.storageClient.Upload(a.ctx, fileName, "image/png", bytes.NewReader(imageData))
	if err != nil {
		l.Error("Failed to upload image to object storage", zap.Error(err))
		a.sendErrorResponse(headers, errors.InternalError("Failed to store image", err))
		a.consumer.CommitMessages(context.Background(), msg)
		return
	}
	l.Info("Image successfully uploaded to storage", zap.String("uri", imageURI))

	// Produce a standard response message with the URI
	responsePayload := ResponsePayload{
		ImageURI: imageURI,
		Prompt:   req.Data.Prompt,
	}
	a.sendSuccessResponse(headers, responsePayload)

	// Commit the original message
	a.consumer.CommitMessages(context.Background(), msg)
}

// callExternalImageAPI calls the Stability AI API with proper error handling
func (a *Adapter) callExternalImageAPI(prompt string) ([]byte, error) {
	a.logger.Info("Calling external image API", zap.String("prompt", prompt))

	requestBody := map[string]interface{}{
		"text_prompts": []map[string]interface{}{
			{"text": prompt, "weight": 1},
		},
		"cfg_scale":            7,
		"clip_guidance_preset": "FAST_BLUE",
		"height":               512,
		"width":                512,
		"samples":              1,
		"steps":                30,
	}

	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	req, err := http.NewRequestWithContext(a.ctx, "POST", a.externalAPI, bytes.NewBuffer(jsonBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", a.apiKey))
	req.Header.Set("Accept", "application/json")

	// Execute through circuit breaker
	resp, err := a.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
	}

	// Parse the response to extract the image
	var apiResponse struct {
		Artifacts []struct {
			Base64 string `json:"base64"`
		} `json:"artifacts"`
	}

	if err := json.Unmarshal(body, &apiResponse); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	if len(apiResponse.Artifacts) == 0 {
		return nil, fmt.Errorf("no images in response")
	}

	// Decode base64 image
	imageData, err := base64.StdEncoding.DecodeString(apiResponse.Artifacts[0].Base64)
	if err != nil {
		return nil, fmt.Errorf("failed to decode image: %w", err)
	}

	return imageData, nil
}

// sendSuccessResponse sends a successful response
func (a *Adapter) sendSuccessResponse(headers map[string]string, payload ResponsePayload) {
	responseBytes, _ := json.Marshal(payload)
	responseHeaders := a.createResponseHeaders(headers)

	if err := a.producer.Produce(a.ctx, responseTopic, responseHeaders,
		[]byte(headers["correlation_id"]), responseBytes); err != nil {
		a.logger.Error("Failed to produce response message", zap.Error(err))
	}
}

// sendErrorResponse sends an error response
func (a *Adapter) sendErrorResponse(headers map[string]string, domainErr *errors.DomainError) {
	responseHeaders := a.createResponseHeaders(headers)
	domainErr.TraceID = headers["correlation_id"]

	errorBytes, _ := json.Marshal(domainErr)

	if err := a.producer.Produce(a.ctx, responseTopic, responseHeaders,
		[]byte(headers["correlation_id"]), errorBytes); err != nil {
		a.logger.Error("Failed to produce error response", zap.Error(err))
	}
}

// createResponseHeaders creates response headers with proper causality tracking
func (a *Adapter) createResponseHeaders(originalHeaders map[string]string) map[string]string {
	return map[string]string{
		"correlation_id": originalHeaders["correlation_id"],
		"causation_id":   originalHeaders["request_id"],
		"request_id":     uuid.NewString(),
		"timestamp":      time.Now().UTC().Format(time.RFC3339),
	}
}

// StartHealthServer starts a simple HTTP server for health checks
func (a *Adapter) StartHealthServer(port string) {
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		status := map[string]interface{}{
			"status":          "healthy",
			"adapter":         "image-generator",
			"circuit_breaker": a.httpClient.State(),
			"circuit_counts":  a.httpClient.Counts(),
		}

		w.Header().Set("Content-Type", "application/json")
		if a.httpClient.Breaker.IsOpen() {
			w.WriteHeader(http.StatusServiceUnavailable)
			status["status"] = "degraded"
		} else {
			w.WriteHeader(http.StatusOK)
		}
		json.NewEncoder(w).Encode(status)
	})

	go func() {
		a.logger.Info("Starting health server", zap.String("port", port))
		if err := http.ListenAndServe(":"+port, nil); err != nil {
			a.logger.Error("Health server failed", zap.Error(err))
		}
	}()
}
-------------------------------------------------
filepath = ./internal/adapters/imagegenerator/API.md
-------------------------------------------------
filepath = ./internal/adapters/websearch/adapter.go
// FILE: internal/adapters/websearch/adapter.go
package websearch

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/kafka"
	"go.uber.org/zap"
)

const (
	requestTopic  = "system.adapter.web.search"
	responseTopic = "system.responses.websearch"
	consumerGroup = "web-search-adapter-group"
)

// RequestPayload for web search
type RequestPayload struct {
	Action string `json:"action"`
	Data   struct {
		Query      string `json:"query"`
		NumResults int    `json:"num_results,omitempty"`
		SearchType string `json:"search_type,omitempty"` // web, news, images
	} `json:"data"`
}

// ResponsePayload with search results
type ResponsePayload struct {
	Query   string         `json:"query"`
	Results []SearchResult `json:"results"`
	Total   int            `json:"total"`
}

// SearchResult represents a single search result
type SearchResult struct {
	Title       string `json:"title"`
	URL         string `json:"url"`
	Snippet     string `json:"snippet"`
	PublishedAt string `json:"published_at,omitempty"`
}

// Adapter handles web search requests
type Adapter struct {
	ctx          context.Context
	logger       *zap.Logger
	consumer     *kafka.Consumer
	producer     kafka.Producer
	httpClient   *http.Client
	apiKey       string
	searchAPIURL string
}

// NewAdapter creates a new web search adapter
func NewAdapter(ctx context.Context, cfg *config.ServiceConfig, logger *zap.Logger) (*Adapter, error) {
	consumer, err := kafka.NewConsumer(cfg.Infrastructure.KafkaBrokers, requestTopic, consumerGroup, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create consumer: %w", err)
	}

	producer, err := kafka.NewProducer(cfg.Infrastructure.KafkaBrokers, logger)
	if err != nil {
		consumer.Close()
		return nil, fmt.Errorf("failed to create producer: %w", err)
	}

	apiKey := os.Getenv("SERP_API_KEY")
	if apiKey == "" {
		consumer.Close()
		producer.Close()
		return nil, fmt.Errorf("SERP_API_KEY not set")
	}

	return &Adapter{
		ctx:          ctx,
		logger:       logger,
		consumer:     consumer,
		producer:     producer,
		httpClient:   &http.Client{Timeout: 30 * time.Second},
		apiKey:       apiKey,
		searchAPIURL: "https://serpapi.com/search",
	}, nil
}

// Run starts the adapter's main loop
func (a *Adapter) Run() error {
	a.logger.Info("Web search adapter running")

	for {
		select {
		case <-a.ctx.Done():
			a.consumer.Close()
			a.producer.Close()
			return nil
		default:
			msg, err := a.consumer.FetchMessage(a.ctx)
			if err != nil {
				if err == context.Canceled {
					continue
				}
				a.logger.Error("Failed to fetch message", zap.Error(err))
				continue
			}
			go a.handleMessage(msg)
		}
	}
}

// handleMessage processes a search request
func (a *Adapter) handleMessage(msg kafka.Message) {
	headers := kafka.HeadersToMap(msg.Headers)
	l := a.logger.With(zap.String("correlation_id", headers["correlation_id"]))

	var req RequestPayload
	if err := json.Unmarshal(msg.Value, &req); err != nil {
		l.Error("Failed to unmarshal request", zap.Error(err))
		a.consumer.CommitMessages(context.Background(), msg)
		return
	}

	// Perform the search
	results, err := a.performSearch(req.Data.Query, req.Data.NumResults)
	if err != nil {
		l.Error("Search failed", zap.Error(err))
		a.sendErrorResponse(headers, "Search failed: "+err.Error())
		a.consumer.CommitMessages(context.Background(), msg)
		return
	}

	// Send response
	response := ResponsePayload{
		Query:   req.Data.Query,
		Results: results,
		Total:   len(results),
	}

	a.sendResponse(headers, response)
	a.consumer.CommitMessages(context.Background(), msg)
}

// performSearch executes the actual web search
func (a *Adapter) performSearch(query string, numResults int) ([]SearchResult, error) {
	if numResults == 0 {
		numResults = 10
	}

	// Build search URL
	params := url.Values{}
	params.Add("q", query)
	params.Add("api_key", a.apiKey)
	params.Add("num", fmt.Sprintf("%d", numResults))
	params.Add("engine", "google")

	searchURL := fmt.Sprintf("%s?%s", a.searchAPIURL, params.Encode())

	// Execute request
	resp, err := a.httpClient.Get(searchURL)
	if err != nil {
		return nil, fmt.Errorf("failed to execute search request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("search API returned status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	var apiResponse struct {
		OrganicResults []struct {
			Title   string `json:"title"`
			Link    string `json:"link"`
			Snippet string `json:"snippet"`
			Date    string `json:"date,omitempty"`
		} `json:"organic_results"`
	}

	if err := json.Unmarshal(body, &apiResponse); err != nil {
		return nil, fmt.Errorf("failed to parse search response: %w", err)
	}

	// Convert to our format
	results := make([]SearchResult, 0, len(apiResponse.OrganicResults))
	for _, r := range apiResponse.OrganicResults {
		results = append(results, SearchResult{
			Title:       r.Title,
			URL:         r.Link,
			Snippet:     r.Snippet,
			PublishedAt: r.Date,
		})
	}

	return results, nil
}

// sendResponse sends a successful response
func (a *Adapter) sendResponse(headers map[string]string, payload ResponsePayload) {
	responseBytes, _ := json.Marshal(payload)
	responseHeaders := map[string]string{
		"correlation_id": headers["correlation_id"],
		"causation_id":   headers["request_id"],
		"request_id":     uuid.NewString(),
	}

	if err := a.producer.Produce(a.ctx, responseTopic, responseHeaders,
		[]byte(headers["correlation_id"]), responseBytes); err != nil {
		a.logger.Error("Failed to produce response", zap.Error(err))
	}
}

// sendErrorResponse sends an error response
func (a *Adapter) sendErrorResponse(headers map[string]string, errorMsg string) {
	payload := map[string]interface{}{
		"success": false,
		"error":   errorMsg,
	}
	responseBytes, _ := json.Marshal(payload)
	responseHeaders := map[string]string{
		"correlation_id": headers["correlation_id"],
		"causation_id":   headers["request_id"],
		"request_id":     uuid.NewString(),
	}

	a.producer.Produce(a.ctx, responseTopic, responseHeaders,
		[]byte(headers["correlation_id"]), responseBytes)
}
-------------------------------------------------
filepath = ./internal/adapters/websearch/API.md
-------------------------------------------------
filepath = ./internal/auth-service/api/openapi.yaml
openapi: 3.0.3
info:
  title: AI Persona Platform API
  description: |
    The AI Persona Platform provides APIs for managing AI personas, authentication, and content generation.
    
    ## Authentication
    All API endpoints (except auth endpoints) require a valid JWT token in the Authorization header:
    ```
    Authorization: Bearer <token>
    ```
    
    ## Rate Limiting
    API calls are rate-limited based on your subscription tier:
    - Free: 100 requests/hour
    - Basic: 1000 requests/hour
    - Premium: 10000 requests/hour
    - Enterprise: Unlimited
  version: 1.0.0
  contact:
    name: AI Persona Support
    email: support@persona-platform.com
  license:
    name: Proprietary

servers:
  - url: https://api.persona-platform.com
    description: Production server
  - url: https://staging-api.persona-platform.com
    description: Staging server
  - url: http://localhost:8081
    description: Local development

tags:
  - name: Authentication
    description: User authentication and authorization
  - name: Users
    description: User profile management
  - name: Projects
    description: Project management
  - name: Subscriptions
    description: Subscription and billing management
  - name: Templates
    description: Persona template management (Admin only)
  - name: Instances
    description: Persona instance management
  - name: Admin
    description: Administrative operations

paths:
  # Health Check
  /health:
    get:
      summary: Health check endpoint
      description: Returns the health status of the service
      operationId: getHealth
      tags:
        - System
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthResponse'
      security: []

  # Authentication Endpoints
  /api/v1/auth/register:
    post:
      summary: Register a new user
      description: Creates a new user account with the provided credentials
      operationId: registerUser
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RegisterRequest'
      responses:
        '201':
          description: User successfully registered
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TokenResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '409':
          $ref: '#/components/responses/Conflict'
      security: []

  /api/v1/auth/login:
    post:
      summary: User login
      description: Authenticates a user and returns access tokens
      operationId: loginUser
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LoginRequest'
      responses:
        '200':
          description: Login successful
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TokenResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security: []

  /api/v1/auth/refresh:
    post:
      summary: Refresh access token
      description: Uses a refresh token to obtain a new access token
      operationId: refreshToken
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RefreshRequest'
      responses:
        '200':
          description: Token refreshed successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TokenResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security: []

  /api/v1/auth/validate:
    post:
      summary: Validate token
      description: Validates an access token and returns user information
      operationId: validateToken
      tags:
        - Authentication
      responses:
        '200':
          description: Token is valid
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ValidateResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  /api/v1/auth/logout:
    post:
      summary: Logout user
      description: Invalidates the current session
      operationId: logoutUser
      tags:
        - Authentication
      responses:
        '200':
          description: Logout successful
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MessageResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  # User Management Endpoints
  /api/v1/user/profile:
    get:
      summary: Get current user profile
      description: Returns the profile information of the authenticated user
      operationId: getCurrentUserProfile
      tags:
        - Users
      responses:
        '200':
          description: User profile retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'
      security:
        - bearerAuth: []

    put:
      summary: Update current user profile
      description: Updates the profile information of the authenticated user
      operationId: updateCurrentUserProfile
      tags:
        - Users
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateUserRequest'
      responses:
        '200':
          description: Profile updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  /api/v1/user/password:
    post:
      summary: Change password
      description: Changes the user's password
      operationId: changePassword
      tags:
        - Users
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ChangePasswordRequest'
      responses:
        '200':
          description: Password changed successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MessageResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  /api/v1/user/delete:
    delete:
      summary: Delete user account
      description: Permanently deletes the user's account
      operationId: deleteUserAccount
      tags:
        - Users
      responses:
        '200':
          description: Account deleted successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MessageResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  # Project Management Endpoints
  /api/v1/projects:
    get:
      summary: List user projects
      description: Returns all projects owned by the authenticated user
      operationId: listProjects
      tags:
        - Projects
      responses:
        '200':
          description: Projects retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProjectListResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

    post:
      summary: Create project
      description: Creates a new project
      operationId: createProject
      tags:
        - Projects
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateProjectRequest'
      responses:
        '201':
          description: Project created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Project'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  /api/v1/projects/{id}:
    get:
      summary: Get project details
      description: Returns details of a specific project
      operationId: getProject
      tags:
        - Projects
      parameters:
        - $ref: '#/components/parameters/ProjectId'
      responses:
        '200':
          description: Project retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Project'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'
      security:
        - bearerAuth: []

    put:
      summary: Update project
      description: Updates a project's information
      operationId: updateProject
      tags:
        - Projects
      parameters:
        - $ref: '#/components/parameters/ProjectId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateProjectRequest'
      responses:
        '200':
          description: Project updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Project'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'
      security:
        - bearerAuth: []

    delete:
      summary: Delete project
      description: Deletes a project
      operationId: deleteProject
      tags:
        - Projects
      parameters:
        - $ref: '#/components/parameters/ProjectId'
      responses:
        '204':
          description: Project deleted successfully
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'
      security:
        - bearerAuth: []

  # Subscription Endpoints
  /api/v1/subscription:
    get:
      summary: Get current subscription
      description: Returns the current user's subscription details
      operationId: getSubscription
      tags:
        - Subscriptions
      responses:
        '200':
          description: Subscription retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Subscription'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '404':
          $ref: '#/components/responses/NotFound'
      security:
        - bearerAuth: []

  /api/v1/subscription/usage:
    get:
      summary: Get usage statistics
      description: Returns usage statistics for the current billing period
      operationId: getUsageStats
      tags:
        - Subscriptions
      responses:
        '200':
          description: Usage statistics retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UsageStats'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  /api/v1/subscription/check-quota:
    get:
      summary: Check resource quota
      description: Checks if the user has quota for a specific resource
      operationId: checkQuota
      tags:
        - Subscriptions
      parameters:
        - name: resource
          in: query
          required: true
          description: Resource type to check (personas, projects, content)
          schema:
            type: string
            enum: [personas, projects, content]
      responses:
        '200':
          description: Quota check result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QuotaCheckResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

  # Persona Template Endpoints (Admin Only)
  /api/v1/templates:
    get:
      summary: List persona templates
      description: Returns all available persona templates
      operationId: listTemplates
      tags:
        - Templates
      responses:
        '200':
          description: Templates retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TemplateListResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
      security:
        - bearerAuth: []
        - adminRole: []

  # Persona Instance Endpoints
  /api/v1/personas/instances:
    get:
      summary: List persona instances
      description: Returns all persona instances for the authenticated user
      operationId: listPersonaInstances
      tags:
        - Instances
      parameters:
        - name: project_id
          in: query
          description: Filter by project ID
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: Instances retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InstanceListResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

    post:
      summary: Create persona instance
      description: Creates a new persona instance from a template
      operationId: createPersonaInstance
      tags:
        - Instances
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateInstanceRequest'
      responses:
        '201':
          description: Instance created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PersonaInstance'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          description: Quota exceeded
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
      security:
        - bearerAuth: []

  # WebSocket Endpoint
  /ws:
    get:
      summary: WebSocket connection
      description: Establishes a WebSocket connection for real-time communication
      operationId: connectWebSocket
      tags:
        - WebSocket
      responses:
        '101':
          description: Switching Protocols
        '401':
          $ref: '#/components/responses/Unauthorized'
      security:
        - bearerAuth: []

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: JWT token obtained from login endpoint

    adminRole:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: JWT token with admin role

  parameters:
    ProjectId:
      name: id
      in: path
      required: true
      description: Project ID
      schema:
        type: string
        format: uuid

  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'

    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'

    Forbidden:
      description: Forbidden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'

    NotFound:
      description: Not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'

    Conflict:
      description: Conflict
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'

  schemas:
    # System Schemas
    HealthResponse:
      type: object
      required:
        - status
        - service
        - version
      properties:
        status:
          type: string
          example: healthy
        service:
          type: string
          example: personae-auth-service
        version:
          type: string
          example: 1.1.0

    ErrorResponse:
      type: object
      required:
        - error
      properties:
        error:
          type: string
          description: Error message
          example: Invalid request
        details:
          type: object
          description: Additional error details

    MessageResponse:
      type: object
      required:
        - message
      properties:
        message:
          type: string
          example: Operation successful

    # Authentication Schemas
    RegisterRequest:
      type: object
      required:
        - email
        - password
        - client_id
      properties:
        email:
          type: string
          format: email
          example: user@example.com
        password:
          type: string
          format: password
          minLength: 8
          example: SecurePassword123!
        client_id:
          type: string
          example: demo_client
        first_name:
          type: string
          example: John
        last_name:
          type: string
          example: Doe
        company:
          type: string
          example: Acme Corp

    LoginRequest:
      type: object
      required:
        - email
        - password
      properties:
        email:
          type: string
          format: email
          example: user@example.com
        password:
          type: string
          format: password
          example: SecurePassword123!

    RefreshRequest:
      type: object
      required:
        - refresh_token
      properties:
        refresh_token:
          type: string
          description: Refresh token obtained from login
          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

    TokenResponse:
      type: object
      required:
        - access_token
        - refresh_token
        - token_type
        - expires_in
        - user
      properties:
        access_token:
          type: string
          description: JWT access token
          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
        refresh_token:
          type: string
          description: JWT refresh token
          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
        token_type:
          type: string
          example: Bearer
        expires_in:
          type: integer
          description: Token expiry time in seconds
          example: 3600
        user:
          $ref: '#/components/schemas/UserInfo'

    ValidateResponse:
      type: object
      required:
        - valid
        - user
      properties:
        valid:
          type: boolean
          example: true
        user:
          $ref: '#/components/schemas/UserInfo'

    UserInfo:
      type: object
      required:
        - id
        - email
        - client_id
        - role
        - tier
        - email_verified
      properties:
        id:
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        email:
          type: string
          format: email
          example: user@example.com
        client_id:
          type: string
          example: demo_client
        role:
          type: string
          enum: [user, admin, moderator]
          example: user
        tier:
          type: string
          enum: [free, basic, premium, enterprise]
          example: free
        email_verified:
          type: boolean
          example: false
        permissions:
          type: array
          items:
            type: string
          example: ["personas.create", "projects.manage"]

    # User Schemas
    User:
      type: object
      required:
        - id
        - email
        - role
        - client_id
        - subscription_tier
        - is_active
        - email_verified
        - created_at
        - updated_at
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        role:
          type: string
          enum: [user, admin, moderator]
        client_id:
          type: string
        subscription_tier:
          type: string
          enum: [free, basic, premium, enterprise]
        is_active:
          type: boolean
        email_verified:
          type: boolean
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
        last_login_at:
          type: string
          format: date-time
          nullable: true
        profile:
          $ref: '#/components/schemas/UserProfile'
        permissions:
          type: array
          items:
            type: string

    UserProfile:
      type: object
      properties:
        user_id:
          type: string
          format: uuid
        first_name:
          type: string
        last_name:
          type: string
        company:
          type: string
        phone:
          type: string
        avatar_url:
          type: string
          format: uri
        preferences:
          type: object
          additionalProperties: true

    UpdateUserRequest:
      type: object
      properties:
        first_name:
          type: string
          example: John
        last_name:
          type: string
          example: Doe
        company:
          type: string
          example: Acme Corp
        phone:
          type: string
          example: +1234567890
        preferences:
          type: object
          additionalProperties: true

    ChangePasswordRequest:
      type: object
      required:
        - current_password
        - new_password
      properties:
        current_password:
          type: string
          format: password
        new_password:
          type: string
          format: password
          minLength: 8

    # Project Schemas
    Project:
      type: object
      required:
        - id
        - client_id
        - name
        - owner_id
        - is_active
        - created_at
        - updated_at
      properties:
        id:
          type: string
          format: uuid
        client_id:
          type: string
        name:
          type: string
          example: Marketing Campaign Q1
        description:
          type: string
          example: Q1 2024 marketing campaign personas
        owner_id:
          type: string
          format: uuid
        is_active:
          type: boolean
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    ProjectListResponse:
      type: object
      required:
        - projects
        - count
      properties:
        projects:
          type: array
          items:
            $ref: '#/components/schemas/Project'
        count:
          type: integer
          example: 5

    CreateProjectRequest:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          example: Marketing Campaign Q1
        description:
          type: string
          example: Q1 2024 marketing campaign personas

    UpdateProjectRequest:
      type: object
      properties:
        name:
          type: string
        description:
          type: string

    # Subscription Schemas
    Subscription:
      type: object
      required:
        - id
        - user_id
        - tier
        - status
        - start_date
        - created_at
        - updated_at
      properties:
        id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        tier:
          type: string
          enum: [free, basic, premium, enterprise]
        status:
          type: string
          enum: [active, trialing, past_due, canceled, expired]
        start_date:
          type: string
          format: date-time
        end_date:
          type: string
          format: date-time
          nullable: true
        trial_ends_at:
          type: string
          format: date-time
          nullable: true
        cancelled_at:
          type: string
          format: date-time
          nullable: true
        payment_method:
          type: string
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    UsageStats:
      type: object
      required:
        - user_id
        - personas_count
        - projects_count
        - content_count
        - last_updated
      properties:
        user_id:
          type: string
          format: uuid
        personas_count:
          type: integer
          example: 3
        projects_count:
          type: integer
          example: 2
        content_count:
          type: integer
          example: 25
        last_updated:
          type: string
          format: date-time

    QuotaCheckResponse:
      type: object
      required:
        - has_quota
        - resource
      properties:
        has_quota:
          type: boolean
          example: true
        resource:
          type: string
          example: personas

    # Template Schemas
    TemplateListResponse:
      type: object
      required:
        - templates
        - count
      properties:
        templates:
          type: array
          items:
            $ref: '#/components/schemas/PersonaTemplate'
        count:
          type: integer

    PersonaTemplate:
      type: object
      required:
        - id
        - name
        - category
        - is_active
        - created_at
        - updated_at
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
          example: Copywriter
        description:
          type: string
          example: Creates compelling marketing and content copy
        category:
          type: string
          example: data-driven
        config:
          type: object
          additionalProperties: true
        is_active:
          type: boolean
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    # Instance Schemas
    InstanceListResponse:
      type: object
      required:
        - instances
        - count
      properties:
        instances:
          type: array
          items:
            $ref: '#/components/schemas/PersonaInstance'
        count:
          type: integer

    PersonaInstance:
      type: object
      required:
        - id
        - template_id
        - name
        - owner_user_id
        - is_active
        - created_at
        - updated_at
      properties:
        id:
          type: string
          format: uuid
        template_id:
          type: string
          format: uuid
        name:
          type: string
          example: Marketing Copy Expert
        owner_user_id:
          type: string
          format: uuid
        config:
          type: object
          additionalProperties: true
        is_active:
          type: boolean
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    CreateInstanceRequest:
      type: object
      required:
        - template_id
        - name
      properties:
        template_id:
          type: string
          format: uuid
        name:
          type: string
          example: Marketing Copy Expert
        project_id:
          type: string
          format: uuid
        config:
          type: object
          additionalProperties: true-------------------------------------------------
filepath = ./internal/auth-service/gateway/handlers_swagger.go
package gateway

// NOTE: This file contains swagger annotations for the gateway handlers.
// The gateway proxies requests to the core-manager service.
// Run `swag init` to generate the swagger documentation.

// HandleTemplateRoutes godoc
// @Summary      Template management (proxy)
// @Description  Proxies template management requests to core-manager service (admin only)
// @Tags         Templates (Gateway)
// @Accept       json
// @Produce      json
// @Param        path path string false "Additional path segments"
// @Success      200 {object} map[string]interface{} "Request proxied successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      502 {object} map[string]interface{} "Bad gateway - core-manager unavailable"
// @Router       /templates [get]
// @Router       /templates [post]
// @Router       /templates/{path} [get]
// @Router       /templates/{path} [put]
// @Router       /templates/{path} [delete]
// @Security     Bearer
// @ID           gatewayTemplateRoutes

// HandleInstanceRoutes godoc
// @Summary      Instance management (proxy)
// @Description  Proxies persona instance requests to core-manager service
// @Tags         Instances (Gateway)
// @Accept       json
// @Produce      json
// @Param        path path string false "Additional path segments"
// @Success      200 {object} map[string]interface{} "Request proxied successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      502 {object} map[string]interface{} "Bad gateway - core-manager unavailable"
// @Router       /personas/instances [get]
// @Router       /personas/instances [post]
// @Router       /personas/instances/{path} [get]
// @Router       /personas/instances/{path} [put]
// @Router       /personas/instances/{path} [delete]
// @Security     Bearer
// @ID           gatewayInstanceRoutes

// HandleAdminRoutes godoc
// @Summary      Admin routes (proxy)
// @Description  Proxies various admin routes to core-manager service (admin only)
// @Tags         Admin (Gateway)
// @Accept       json
// @Produce      json
// @Param        path path string false "Additional path segments"
// @Success      200 {object} map[string]interface{} "Request proxied successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      502 {object} map[string]interface{} "Bad gateway - core-manager unavailable"
// @Router       /admin/clients [any]
// @Router       /admin/clients/{path} [any]
// @Router       /admin/system/{path} [any]
// @Router       /admin/workflows/{path} [any]
// @Router       /admin/agent-definitions/{path} [any]
// @Security     Bearer
// @ID           gatewayAdminRoutes

// Gateway Proxy Information
// @Description The gateway service acts as a reverse proxy, forwarding requests to the core-manager service.
// @Description All requests are enriched with user context headers before forwarding:
// @Description - X-User-ID: The authenticated user's ID
// @Description - X-Client-ID: The client/tenant ID
// @Description - X-User-Role: The user's role (user, admin, moderator)
// @Description - X-User-Tier: The user's subscription tier
// @Description - X-User-Email: The user's email address
// @Description - X-User-Permissions: Comma-separated list of user permissions

// Core-Manager Endpoints (Proxied)
// @Description The following endpoints are proxied to the core-manager service:

// Templates (Admin Only)
// @Description Template management for persona definitions
// GET    /api/v1/templates              - List all templates
// POST   /api/v1/templates              - Create new template
// GET    /api/v1/templates/:id          - Get template details
// PUT    /api/v1/templates/:id          - Update template
// DELETE /api/v1/templates/:id          - Delete template
// POST   /api/v1/templates/:id/clone    - Clone template
// POST   /api/v1/templates/:id/validate - Validate template

// Persona Instances
// @Description User-created persona instances
// GET    /api/v1/personas/instances                 - List user's instances
// POST   /api/v1/personas/instances                 - Create new instance
// GET    /api/v1/personas/instances/:id             - Get instance details
// PUT    /api/v1/personas/instances/:id             - Update instance
// DELETE /api/v1/personas/instances/:id             - Delete instance
// POST   /api/v1/personas/instances/:id/execute     - Execute instance
// GET    /api/v1/personas/instances/:id/history     - Get execution history
// POST   /api/v1/personas/instances/:id/stop        - Stop running instance
// GET    /api/v1/personas/instances/:id/logs        - Get instance logs

// Admin - Client Management
// @Description Multi-tenant client management (admin only)
// GET    /api/v1/admin/clients             - List all clients
// POST   /api/v1/admin/clients             - Create new client
// GET    /api/v1/admin/clients/:id         - Get client details
// PUT    /api/v1/admin/clients/:id         - Update client
// DELETE /api/v1/admin/clients/:id         - Delete client
// GET    /api/v1/admin/clients/:id/stats   - Get client statistics

// Admin - System Management
// @Description System configuration and monitoring (admin only)
// GET    /api/v1/admin/system/health       - System health check
// GET    /api/v1/admin/system/metrics      - System metrics
// GET    /api/v1/admin/system/config       - Get system configuration
// PUT    /api/v1/admin/system/config       - Update configuration
// POST   /api/v1/admin/system/maintenance  - Toggle maintenance mode
// GET    /api/v1/admin/system/logs         - Get system logs

// Admin - Workflow Management
// @Description Workflow definitions and management (admin only)
// GET    /api/v1/admin/workflows           - List all workflows
// POST   /api/v1/admin/workflows           - Create workflow
// GET    /api/v1/admin/workflows/:id       - Get workflow details
// PUT    /api/v1/admin/workflows/:id       - Update workflow
// DELETE /api/v1/admin/workflows/:id       - Delete workflow
// GET    /api/v1/admin/workflows/:id/runs  - Get workflow runs

// Admin - Agent Definitions
// @Description Agent type definitions (admin only)
// GET    /api/v1/admin/agent-definitions           - List agent definitions
// POST   /api/v1/admin/agent-definitions           - Create agent definition
// GET    /api/v1/admin/agent-definitions/:id       - Get agent definition
// PUT    /api/v1/admin/agent-definitions/:id       - Update agent definition
// DELETE /api/v1/admin/agent-definitions/:id       - Delete agent definition
-------------------------------------------------
filepath = ./internal/auth-service/gateway/handlers.go
// FILE: internal/auth-service/gateway/handlers.go
package gateway

import (
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

// HTTPHandler handles gateway HTTP requests
type HTTPHandler struct {
	service *Service
	logger  *zap.Logger
}

// NewHTTPHandler creates a new gateway HTTP handler
func NewHTTPHandler(service *Service, logger *zap.Logger) *HTTPHandler {
	return &HTTPHandler{
		service: service,
		logger:  logger,
	}
}

// ProxyToCoreManager proxies requests to the core manager service
func (h *HTTPHandler) ProxyToCoreManager(c *gin.Context) {
	// Build target URL
	targetPath := c.Param("path")
	if targetPath == "" {
		targetPath = strings.TrimPrefix(c.Request.URL.Path, "/api/v1")
	}

	targetURL := h.service.coreManagerURL.ResolveReference(&url.URL{
		Path:     "/api/v1" + targetPath,
		RawQuery: c.Request.URL.RawQuery,
	})

	h.logger.Debug("Proxying request",
		zap.String("method", c.Request.Method),
		zap.String("target", targetURL.String()))

	// Create new request
	req, err := http.NewRequest(c.Request.Method, targetURL.String(), c.Request.Body)
	if err != nil {
		h.logger.Error("Failed to create proxy request", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create request"})
		return
	}

	// Copy headers
	for key, values := range c.Request.Header {
		for _, value := range values {
			req.Header.Add(key, value)
		}
	}

	// Add user context headers
	req.Header.Set("X-User-ID", c.GetString("user_id"))
	req.Header.Set("X-Client-ID", c.GetString("client_id"))
	req.Header.Set("X-User-Role", c.GetString("user_role"))
	req.Header.Set("X-User-Tier", c.GetString("user_tier"))
	req.Header.Set("X-User-Email", c.GetString("user_email"))

	// Add permissions
	if perms, exists := c.Get("user_permissions"); exists {
		if permissions, ok := perms.([]string); ok {
			req.Header.Set("X-User-Permissions", strings.Join(permissions, ","))
		}
	}

	// Execute request
	resp, err := h.service.httpClient.Do(req)
	if err != nil {
		h.logger.Error("Proxy request failed", zap.Error(err))
		c.JSON(http.StatusBadGateway, gin.H{"error": "Service unavailable"})
		return
	}
	defer resp.Body.Close()

	// Copy response headers
	for key, values := range resp.Header {
		for _, value := range values {
			c.Header(key, value)
		}
	}

	// Set status code
	c.Status(resp.StatusCode)

	// Copy response body
	_, err = io.Copy(c.Writer, resp.Body)
	if err != nil {
		h.logger.Error("Failed to copy response body", zap.Error(err))
	}
}

// HandleTemplateRoutes handles all template-related routes
func (h *HTTPHandler) HandleTemplateRoutes(c *gin.Context) {
	h.ProxyToCoreManager(c)
}

// HandleInstanceRoutes handles all instance-related routes
func (h *HTTPHandler) HandleInstanceRoutes(c *gin.Context) {
	h.ProxyToCoreManager(c)
}

// HandleAdminRoutes provides a generic proxy for all admin routes destined for core-manager
func (h *HTTPHandler) HandleAdminRoutes(c *gin.Context) {
	h.ProxyToCoreManager(c)
}

// HandleWebSocket handles WebSocket connections
func (h *HTTPHandler) HandleWebSocket(c *gin.Context) {
	wsProxy := NewWebSocketProxy(h.service.coreManagerURL, h.logger)
	wsProxy.ProxyWebSocket(c)
}
-------------------------------------------------
filepath = ./internal/auth-service/gateway/API.md
# Gateway Service Documentation

## Overview

The Gateway service in the Auth Service acts as a reverse proxy, routing authenticated requests to the core-manager service. It enriches requests with user context and handles both HTTP and WebSocket connections.

## Architecture

```
Client → Auth Service (Gateway) → Core Manager
         ↓
    Authentication &
    Context Enrichment
```

## Key Features

### 1. Request Proxying
- Routes authenticated requests to core-manager
- Maintains request/response integrity
- Handles all HTTP methods (GET, POST, PUT, DELETE, PATCH)

### 2. Context Enrichment
All proxied requests are enriched with user context headers:
- `X-User-ID`: Authenticated user's ID
- `X-Client-ID`: Multi-tenant client identifier
- `X-User-Role`: User's role (user, admin, moderator)
- `X-User-Tier`: Subscription tier
- `X-User-Email`: User's email address
- `X-User-Permissions`: Comma-separated permissions list

### 3. WebSocket Proxy
- Upgrades HTTP connections to WebSocket
- Maintains bidirectional communication
- Forwards user context to core-manager

## Proxied Endpoints

### Template Management (Admin Only)
Templates define persona configurations and behaviors.

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/templates` | List all templates |
| POST | `/api/v1/templates` | Create new template |
| GET | `/api/v1/templates/{id}` | Get template details |
| PUT | `/api/v1/templates/{id}` | Update template |
| DELETE | `/api/v1/templates/{id}` | Delete template |
| POST | `/api/v1/templates/{id}/clone` | Clone template |
| POST | `/api/v1/templates/{id}/validate` | Validate template configuration |

### Persona Instances
User-created instances based on templates.

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/personas/instances` | List user's instances |
| POST | `/api/v1/personas/instances` | Create new instance |
| GET | `/api/v1/personas/instances/{id}` | Get instance details |
| PUT | `/api/v1/personas/instances/{id}` | Update instance |
| DELETE | `/api/v1/personas/instances/{id}` | Delete instance |
| POST | `/api/v1/personas/instances/{id}/execute` | Execute instance |
| GET | `/api/v1/personas/instances/{id}/history` | Get execution history |
| POST | `/api/v1/personas/instances/{id}/stop` | Stop running instance |
| GET | `/api/v1/personas/instances/{id}/logs` | Get instance logs |

### Admin Routes
Various administrative endpoints for system management.

#### Client Management
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/admin/clients` | List all clients |
| POST | `/api/v1/admin/clients` | Create new client |
| GET | `/api/v1/admin/clients/{id}` | Get client details |
| PUT | `/api/v1/admin/clients/{id}` | Update client |
| DELETE | `/api/v1/admin/clients/{id}` | Delete client |
| GET | `/api/v1/admin/clients/{id}/stats` | Get client statistics |

#### System Management
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/admin/system/health` | System health check |
| GET | `/api/v1/admin/system/metrics` | System metrics |
| GET | `/api/v1/admin/system/config` | Get configuration |
| PUT | `/api/v1/admin/system/config` | Update configuration |
| POST | `/api/v1/admin/system/maintenance` | Toggle maintenance mode |
| GET | `/api/v1/admin/system/logs` | Get system logs |

#### Workflow Management
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/admin/workflows` | List workflows |
| POST | `/api/v1/admin/workflows` | Create workflow |
| GET | `/api/v1/admin/workflows/{id}` | Get workflow |
| PUT | `/api/v1/admin/workflows/{id}` | Update workflow |
| DELETE | `/api/v1/admin/workflows/{id}` | Delete workflow |
| GET | `/api/v1/admin/workflows/{id}/runs` | Get workflow runs |

#### Agent Definitions
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/v1/admin/agent-definitions` | List agent types |
| POST | `/api/v1/admin/agent-definitions` | Create agent type |
| GET | `/api/v1/admin/agent-definitions/{id}` | Get agent type |
| PUT | `/api/v1/admin/agent-definitions/{id}` | Update agent type |
| DELETE | `/api/v1/admin/agent-definitions/{id}` | Delete agent type |

## WebSocket Protocol

### Connection
```
GET /api/v1/ws
Upgrade: websocket
Authorization: Bearer <token>
```

### Message Format
```json
{
  "type": "command|event|response|error",
  "event": "event.name",
  "data": { "...": "..." },
  "id": "unique-id",
  "timestamp": "2024-07-17T14:30:00Z"
}
```

### Commands

#### Subscribe to Events
```json
{
  "type": "command",
  "event": "subscribe",
  "data": {
    "events": ["instance.status.*", "execution.complete"]
  },
  "id": "cmd_123"
}
```

#### Unsubscribe from Events
```json
{
  "type": "command",
  "event": "unsubscribe",
  "data": {
    "events": ["instance.status.*"]
  },
  "id": "cmd_124"
}
```

#### Keep-Alive Ping
```json
{
  "type": "command",
  "event": "ping",
  "id": "cmd_125"
}
```

### Event Types

#### Instance Events
- `instance.status.changed`: Status update
- `instance.created`: New instance created
- `instance.deleted`: Instance deleted
- `instance.updated`: Instance configuration updated

#### Execution Events
- `execution.started`: Execution began
- `execution.completed`: Execution finished successfully
- `execution.failed`: Execution failed
- `execution.progress`: Progress update

#### System Events
- `system.notification`: System-wide notification
- `system.maintenance`: Maintenance mode change
- `system.alert`: System alert

### Example Event
```json
{
  "type": "event",
  "event": "instance.status.changed",
  "data": {
    "instance_id": "inst_123",
    "previous_status": "running",
    "new_status": "completed",
    "reason": "Execution completed successfully"
  },
  "timestamp": "2024-07-17T14:30:00Z"
}
```

## Error Handling

### Gateway Errors
When the gateway itself encounters errors:

```json
{
  "error": "BAD_GATEWAY",
  "message": "Service temporarily unavailable",
  "status_code": 502,
  "service": "core-manager"
}
```

### Proxied Errors
Errors from core-manager are passed through unchanged.

### WebSocket Errors
```json
{
  "type": "error",
  "error": "Invalid command",
  "data": {
    "details": "Command 'foo' not recognized",
    "command": "foo"
  }
}
```

## Rate Limiting

The gateway respects rate limits from core-manager and adds headers:
- `X-RateLimit-Limit`: Request limit
- `X-RateLimit-Remaining`: Remaining requests
- `X-RateLimit-Reset`: Reset timestamp

## Security Considerations

1. **Authentication**: All requests must include valid JWT token
2. **Authorization**: Role-based access enforced before proxying
3. **Context Isolation**: User context passed via headers, not body
4. **Request Validation**: Basic validation before proxying
5. **Timeout Protection**: 30-second timeout on all proxied requests

## Performance

- **Connection Pooling**: Reuses HTTP connections to core-manager
- **Buffering**: Minimal buffering for streaming responses
- **WebSocket**: 1024-byte read/write buffers
- **Timeout**: 30-second default timeout

## Monitoring

The gateway logs:
- All proxied requests with latency
- Failed proxy attempts
- WebSocket connection lifecycle
- Authentication failures

## Configuration

Gateway configuration via environment/config:
```yaml
custom:
  core_manager_url: "http://core-manager:8080"
  request_timeout: 30
  enable_request_logging: true
  websocket_buffer_size: 1024
```-------------------------------------------------
filepath = ./internal/auth-service/gateway/websocket_swagger.go
package gateway

// NOTE: This file contains swagger annotations and WebSocket-related types for documentation.
// The gateway proxies WebSocket connections to the core-manager service.

// WebSocketMessage for WebSocket communication
type WebSocketMessage struct {
	Type      string      `json:"type" example:"event"`
	Event     string      `json:"event,omitempty" example:"instance.status.changed"`
	Data      interface{} `json:"data,omitempty"`
	Error     string      `json:"error,omitempty" example:"Invalid command"`
	ID        string      `json:"id,omitempty" example:"msg_123e4567"`
	Timestamp string      `json:"timestamp" example:"2024-07-17T14:30:00Z"`
}

// WebSocketEventTypes contains all available WebSocket event types
type WebSocketEventTypes struct {
	InstanceEvents   []string `json:"instance_events" example:"instance.status.changed,instance.created,instance.deleted"`
	ExecutionEvents  []string `json:"execution_events" example:"execution.started,execution.completed,execution.failed"`
	SystemEvents     []string `json:"system_events" example:"system.notification,system.maintenance,system.alert"`
	ConnectionEvents []string `json:"connection_events" example:"connection.established,connection.closed,connection.error"`
}

// WebSocketCommand represents a command sent via WebSocket
type WebSocketCommand struct {
	Type  string      `json:"type" example:"command"`
	Event string      `json:"event" example:"subscribe"`
	Data  interface{} `json:"data"`
	ID    string      `json:"id" example:"cmd_123e4567"`
}

// WebSocketSubscribeData for subscription commands
type WebSocketSubscribeData struct {
	Events []string `json:"events" example:"instance.status.*,execution.complete"`
}

// WebSocketEventMessage represents an event from the server
type WebSocketEventMessage struct {
	Type      string      `json:"type" example:"event"`
	Event     string      `json:"event" example:"instance.status.changed"`
	Data      interface{} `json:"data"`
	Timestamp string      `json:"timestamp" example:"2024-07-17T14:30:00Z"`
	EntityID  string      `json:"entity_id,omitempty" example:"inst_123e4567"`
}

// InstanceStatusChangedEvent data for instance status changes
type InstanceStatusChangedEvent struct {
	InstanceID     string `json:"instance_id" example:"inst_123e4567"`
	PreviousStatus string `json:"previous_status" example:"running"`
	NewStatus      string `json:"new_status" example:"completed"`
	Reason         string `json:"reason,omitempty" example:"Execution completed successfully"`
	TriggeredBy    string `json:"triggered_by,omitempty" example:"user_123"`
}

// HandleWebSocket godoc
// @Summary      WebSocket connection
// @Description  Establishes a WebSocket connection for real-time communication with core-manager
// @Tags         WebSocket (Gateway)
// @Accept       json
// @Produce      json
// @Success      101 {string} string "Switching Protocols"
// @Failure      400 {object} map[string]interface{} "Bad request - invalid WebSocket upgrade"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      426 {object} map[string]interface{} "Upgrade required"
// @Failure      502 {object} map[string]interface{} "Bad gateway - core-manager WebSocket unavailable"
// @Router       /ws [get]
// @Security     Bearer
// @ID           gatewayWebSocket

// WebSocket Protocol Documentation
// @Description The WebSocket endpoint provides real-time bidirectional communication with the core-manager service.
// @Description
// @Description ## Connection Process:
// @Description 1. Client sends WebSocket upgrade request with Bearer token
// @Description 2. Gateway validates authentication
// @Description 3. Gateway establishes upstream connection to core-manager
// @Description 4. Messages are proxied bidirectionally
// @Description
// @Description ## Message Format:
// @Description All messages use JSON format with the gateway.WebSocketMessage structure
// @Description
// @Description ## Available Commands:
// @Description - `subscribe`: Subscribe to events
// @Description   - Data: `{"events": ["instance.status.*", "execution.complete"]}`
// @Description - `unsubscribe`: Unsubscribe from events
// @Description   - Data: `{"events": ["instance.status.*"]}`
// @Description - `ping`: Keep-alive ping
// @Description   - Response: `{"type": "response", "event": "pong"}`
// @Description
// @Description ## Event Types:
// @Description - `instance.status.changed`: Instance status update
// @Description - `instance.execution.started`: Execution started
// @Description - `instance.execution.completed`: Execution completed
// @Description - `instance.execution.failed`: Execution failed
// @Description - `instance.log`: Instance log entry
// @Description - `system.notification`: System notification
// @Description - `connection.established`: Connection established
// @Description - `connection.closed`: Connection closed
// @Description
// @Description ## Error Handling:
// @Description Errors are sent as messages with type "error":
// @Description ```json
// @Description {
// @Description   "type": "error",
// @Description   "error": "Invalid command",
// @Description   "data": { "details": "Command 'foo' not recognized" }
// @Description }
// @Description ```
// @Description
// @Description ## Authentication:
// @Description The WebSocket connection inherits authentication from the initial HTTP upgrade request.
// @Description User context is automatically forwarded to core-manager.
-------------------------------------------------
filepath = ./internal/auth-service/gateway/proxy.go
package gateway

import (
	"net/http"
	"net/http/httputil"
	"net/url"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"
	"go.uber.org/zap"
)

// WebSocketProxy handles WebSocket connections
type WebSocketProxy struct {
	targetURL *url.URL
	upgrader  websocket.Upgrader
	logger    *zap.Logger
}

// NewWebSocketProxy creates a new WebSocket proxy
func NewWebSocketProxy(targetURL *url.URL, logger *zap.Logger) *WebSocketProxy {
	return &WebSocketProxy{
		targetURL: targetURL,
		upgrader: websocket.Upgrader{
			CheckOrigin: func(r *http.Request) bool {
				// Configure based on your security requirements
				return true
			},
			ReadBufferSize:  1024,
			WriteBufferSize: 1024,
		},
		logger: logger,
	}
}

// ProxyWebSocket proxies WebSocket connections
func (p *WebSocketProxy) ProxyWebSocket(c *gin.Context) {
	// Build target WebSocket URL
	targetURL := *p.targetURL
	targetURL.Scheme = "ws"
	if p.targetURL.Scheme == "https" {
		targetURL.Scheme = "wss"
	}
	targetURL.Path = c.Request.URL.Path
	targetURL.RawQuery = c.Request.URL.RawQuery

	p.logger.Debug("Proxying WebSocket connection",
		zap.String("target", targetURL.String()))

	// Connect to target
	targetHeader := http.Header{}
	for key, values := range c.Request.Header {
		if key == "Upgrade" || key == "Connection" || key == "Sec-Websocket-Key" ||
			key == "Sec-Websocket-Version" || key == "Sec-Websocket-Extensions" {
			continue
		}
		targetHeader[key] = values
	}

	// Add user context headers
	targetHeader.Set("X-User-ID", c.GetString("user_id"))
	targetHeader.Set("X-Client-ID", c.GetString("client_id"))

	targetConn, resp, err := websocket.DefaultDialer.Dial(targetURL.String(), targetHeader)
	if err != nil {
		p.logger.Error("Failed to connect to target WebSocket", zap.Error(err))
		if resp != nil {
			c.Status(resp.StatusCode)
		} else {
			c.Status(http.StatusBadGateway)
		}
		return
	}
	defer targetConn.Close()

	// Upgrade client connection
	clientConn, err := p.upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		p.logger.Error("Failed to upgrade client connection", zap.Error(err))
		return
	}
	defer clientConn.Close()

	// Proxy messages
	errChan := make(chan error, 2)

	// Client to target
	go func() {
		for {
			messageType, data, err := clientConn.ReadMessage()
			if err != nil {
				errChan <- err
				return
			}

			if err := targetConn.WriteMessage(messageType, data); err != nil {
				errChan <- err
				return
			}
		}
	}()

	// Target to client
	go func() {
		for {
			messageType, data, err := targetConn.ReadMessage()
			if err != nil {
				errChan <- err
				return
			}

			if err := clientConn.WriteMessage(messageType, data); err != nil {
				errChan <- err
				return
			}
		}
	}()

	// Wait for error
	err = <-errChan
	p.logger.Debug("WebSocket proxy closed", zap.Error(err))
}

// ReverseProxy creates a standard HTTP reverse proxy
func (s *Service) ReverseProxy() *httputil.ReverseProxy {
	proxy := httputil.NewSingleHostReverseProxy(s.coreManagerURL)

	// Customize the director
	originalDirector := proxy.Director
	proxy.Director = func(req *http.Request) {
		originalDirector(req)

		// Add user context from gin context if available
		if ginCtx, ok := req.Context().Value("gin_context").(*gin.Context); ok {
			req.Header.Set("X-User-ID", ginCtx.GetString("user_id"))
			req.Header.Set("X-Client-ID", ginCtx.GetString("client_id"))
			req.Header.Set("X-User-Role", ginCtx.GetString("user_role"))
			req.Header.Set("X-User-Tier", ginCtx.GetString("user_tier"))
		}
	}

	// Custom error handler
	proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) {
		s.logger.Error("Reverse proxy error", zap.Error(err))
		w.WriteHeader(http.StatusBadGateway)
		w.Write([]byte(`{"error": "Service temporarily unavailable"}`))
	}

	return proxy
}
-------------------------------------------------
filepath = ./internal/auth-service/gateway/service.go
package gateway

import (
	"net/http"
	"net/url"
	"time"

	"github.com/gqls/agentchassis/platform/config"
	"go.uber.org/zap"
)

// Service handles API gateway functionality
type Service struct {
	coreManagerURL *url.URL
	httpClient     *http.Client
	logger         *zap.Logger
}

// NewService creates a new gateway service
func NewService(cfg *config.ServiceConfig, logger *zap.Logger) *Service {
	coreManagerURL, _ := url.Parse(cfg.Custom["core_manager_url"].(string))

	return &Service{
		coreManagerURL: coreManagerURL,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		logger: logger,
	}
}

// GetCoreManagerURL returns the core manager URL
func (s *Service) GetCoreManagerURL() *url.URL {
	return s.coreManagerURL
}
-------------------------------------------------
filepath = ./internal/auth-service/user/handlers_swagger.go
package user

// NOTE: This file contains swagger annotations for the user handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective files.

// HandleGetCurrentUser godoc
// @Summary      Get current user profile
// @Description  Retrieves the profile information of the currently authenticated user
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Success      200 {object} user.User "User profile retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "User not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/profile [get]
// @Security     Bearer
// @ID           getCurrentUser

// HandleUpdateCurrentUser godoc
// @Summary      Update user profile
// @Description  Updates the profile information of the currently authenticated user
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Param        request body user.UpdateUserRequest true "Profile update details"
// @Success      200 {object} user.User "Profile updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "User not found"
// @Failure      409 {object} map[string]interface{} "Email already in use"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/profile [put]
// @Security     Bearer
// @ID           updateUserProfile

// HandleChangePassword godoc
// @Summary      Change password
// @Description  Changes the password for the currently authenticated user
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Param        request body user.ChangePasswordRequest true "Password change details"
// @Success      200 {object} map[string]interface{} "Password changed successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request or password requirements not met"
// @Failure      401 {object} map[string]interface{} "Unauthorized or incorrect current password"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/password [post]
// @Security     Bearer
// @ID           changePassword

// HandleDeleteAccount godoc
// @Summary      Delete account
// @Description  Permanently deletes the currently authenticated user's account. This action cannot be undone.
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Param        request body user.DeleteAccountRequest true "Account deletion confirmation"
// @Success      200 {object} map[string]interface{} "Account deleted successfully"
// @Failure      400 {object} map[string]interface{} "Invalid confirmation or request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized or incorrect password"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/delete [delete]
// @Security     Bearer
// @ID           deleteAccount
-------------------------------------------------
filepath = ./internal/auth-service/user/handlers.go
package user

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// Handlers wraps the user service for HTTP handling
type Handlers struct {
	service *Service
}

// NewHandlers creates new user handlers
func NewHandlers(service *Service) *Handlers {
	return &Handlers{service: service}
}

// DeleteAccountRequest for account deletion
type DeleteAccountRequest struct {
	Password     string `json:"password" binding:"required" example:"SecurePassword123!"`
	Confirmation string `json:"confirmation" binding:"required" example:"DELETE MY ACCOUNT"`
	Reason       string `json:"reason,omitempty" example:"No longer need the service"`
}

// HandleGetCurrentUser returns the current user's details
func (h *Handlers) HandleGetCurrentUser(c *gin.Context) {
	userID := c.GetString("user_id")

	user, err := h.service.GetUser(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// HandleUpdateCurrentUser updates the current user's details
func (h *Handlers) HandleUpdateCurrentUser(c *gin.Context) {
	userID := c.GetString("user_id")

	var req UpdateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.service.UpdateUser(c.Request.Context(), userID, &req); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
		return
	}

	// Return updated user
	user, _ := h.service.GetUser(c.Request.Context(), userID)
	c.JSON(http.StatusOK, user)
}

// HandleChangePassword changes the user's password
func (h *Handlers) HandleChangePassword(c *gin.Context) {
	userID := c.GetString("user_id")

	var req ChangePasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.service.ChangePassword(c.Request.Context(), userID, &req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

// HandleDeleteAccount deletes the user's account
func (h *Handlers) HandleDeleteAccount(c *gin.Context) {
	userID := c.GetString("user_id")

	var req DeleteAccountRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate confirmation
	if req.Confirmation != "DELETE MY ACCOUNT" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid confirmation text"})
		return
	}

	// Verify password
	user, err := h.service.GetUser(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify account"})
		return
	}

	// Validate password through login service
	_, err = h.service.Login(c.Request.Context(), user.Email, req.Password)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Incorrect password"})
		return
	}

	if err := h.service.DeleteUser(c.Request.Context(), userID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete account"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Account deleted successfully"})
}
-------------------------------------------------
filepath = ./internal/auth-service/user/repository_admin.go
// FILE: internal/auth-service/user/repository_admin.go
package user

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"go.uber.org/zap"
)

// ListUsersParams contains parameters for listing users
type ListUsersParams struct {
	Offset    int
	Limit     int
	Email     string
	ClientID  string
	Role      string
	Tier      string
	IsActive  *bool
	SortBy    string
	SortOrder string
}

// UserStats contains statistics about a user
type UserStats struct {
	TotalProjects int        `json:"total_projects" example:"5"`
	TotalPersonas int        `json:"total_personas" example:"12"`
	LastLoginAt   *time.Time `json:"last_login_at" example:"2024-07-17T10:00:00Z"`
	AccountAge    string     `json:"account_age" example:"6 months"`
	TotalLogins   int        `json:"total_logins" example:"142"`
}

// UserActivity represents a user activity log entry
type UserActivity struct {
	ID        string    `json:"id" example:"act_123e4567-e89b-12d3-a456-426614174000"`
	UserID    string    `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	Action    string    `json:"action" example:"login"`
	Details   string    `json:"details" example:"{\"ip\":\"192.168.1.1\",\"location\":\"New York\"}"`
	IPAddress string    `json:"ip_address" example:"192.168.1.1"`
	UserAgent string    `json:"user_agent" example:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"`
	CreatedAt time.Time `json:"created_at" example:"2024-07-17T14:30:00Z"`
}

// AdminUpdateRequest contains fields that can be updated by admin
type AdminUpdateRequest struct {
	Role             *string
	SubscriptionTier *string
	IsActive         *bool
	EmailVerified    *bool
}

// ListUsers returns a paginated list of users with optional filtering
func (r *Repository) ListUsers(ctx context.Context, params ListUsersParams) ([]User, int, error) {
	// Build the query dynamically
	query := `
		SELECT u.id, u.email, u.password_hash, u.role, u.client_id, 
		       u.subscription_tier, u.is_active, u.email_verified,
		       u.created_at, u.updated_at, u.last_login_at
		FROM users u
		WHERE 1=1
	`
	countQuery := `SELECT COUNT(*) FROM users u WHERE 1=1`

	args := []interface{}{}
	argCount := 0

	// Add filters
	var conditions []string

	if params.Email != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.email ILIKE $%d", argCount))
		args = append(args, "%"+params.Email+"%")
	}

	if params.ClientID != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.client_id = $%d", argCount))
		args = append(args, params.ClientID)
	}

	if params.Role != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.role = $%d", argCount))
		args = append(args, params.Role)
	}

	if params.Tier != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.subscription_tier = $%d", argCount))
		args = append(args, params.Tier)
	}

	if params.IsActive != nil {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.is_active = $%d", argCount))
		args = append(args, *params.IsActive)
	}

	// Add conditions to queries
	if len(conditions) > 0 {
		whereClause := " AND " + strings.Join(conditions, " AND ")
		query += whereClause
		countQuery += whereClause
	}

	// Get total count
	var totalCount int
	err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&totalCount)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to get user count: %w", err)
	}

	// Add sorting
	validSortColumns := map[string]bool{
		"email": true, "created_at": true, "updated_at": true,
		"last_login_at": true, "role": true, "subscription_tier": true,
	}

	sortBy := "created_at"
	if validSortColumns[params.SortBy] {
		sortBy = params.SortBy
	}

	sortOrder := "DESC"
	if strings.ToUpper(params.SortOrder) == "ASC" {
		sortOrder = "ASC"
	}

	query += fmt.Sprintf(" ORDER BY u.%s %s", sortBy, sortOrder)

	// Add pagination
	argCount++
	query += fmt.Sprintf(" LIMIT $%d", argCount)
	args = append(args, params.Limit)

	argCount++
	query += fmt.Sprintf(" OFFSET $%d", argCount)
	args = append(args, params.Offset)

	// Execute query
	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list users: %w", err)
	}
	defer rows.Close()

	var users []User
	for rows.Next() {
		var user User
		err := rows.Scan(
			&user.ID, &user.Email, &user.PasswordHash, &user.Role,
			&user.ClientID, &user.SubscriptionTier, &user.IsActive,
			&user.EmailVerified, &user.CreatedAt, &user.UpdatedAt,
			&user.LastLoginAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan user row", zap.Error(err))
			continue
		}

		// Don't load profile and permissions for list view (performance)
		users = append(users, user)
	}

	return users, totalCount, nil
}

// GetUserStats retrieves statistics for a user
func (r *Repository) GetUserStats(ctx context.Context, userID string) (*UserStats, error) {
	stats := &UserStats{}

	// Get basic user info for last login and account age
	var createdAt time.Time
	var lastLogin sql.NullTime
	err := r.db.QueryRowContext(ctx,
		"SELECT created_at, last_login_at FROM users WHERE id = $1",
		userID,
	).Scan(&createdAt, &lastLogin)

	if err != nil {
		return nil, err
	}

	if lastLogin.Valid {
		stats.LastLoginAt = &lastLogin.Time
	}

	// Calculate account age
	age := time.Since(createdAt)
	if age.Hours() < 24 {
		stats.AccountAge = fmt.Sprintf("%d hours", int(age.Hours()))
	} else if age.Hours() < 24*30 {
		stats.AccountAge = fmt.Sprintf("%d days", int(age.Hours()/24))
	} else {
		stats.AccountAge = fmt.Sprintf("%d months", int(age.Hours()/(24*30)))
	}

	// Get project count
	err = r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM projects WHERE owner_id = $1 AND is_active = true",
		userID,
	).Scan(&stats.TotalProjects)

	if err != nil && err != sql.ErrNoRows {
		r.logger.Warn("Failed to get project count", zap.Error(err))
	}

	// Note: Persona count would require access to clients DB
	// For now, we'll leave it at 0

	return stats, nil
}

// AdminUpdateUser updates user fields that only admins can change
func (r *Repository) AdminUpdateUser(ctx context.Context, userID string, req *AdminUpdateRequest) error {
	var setClauses []string
	var args []interface{}
	argCount := 0

	if req.Role != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("role = $%d", argCount))
		args = append(args, *req.Role)
	}

	if req.SubscriptionTier != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("subscription_tier = $%d", argCount))
		args = append(args, *req.SubscriptionTier)
	}

	if req.IsActive != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("is_active = $%d", argCount))
		args = append(args, *req.IsActive)
	}

	if req.EmailVerified != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("email_verified = $%d", argCount))
		args = append(args, *req.EmailVerified)
	}

	if len(setClauses) == 0 {
		return nil // Nothing to update
	}

	argCount++
	setClauses = append(setClauses, fmt.Sprintf("updated_at = $%d", argCount))
	args = append(args, time.Now())

	argCount++
	args = append(args, userID)

	query := fmt.Sprintf(
		"UPDATE users SET %s WHERE id = $%d",
		strings.Join(setClauses, ", "),
		argCount,
	)

	_, err := r.db.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("failed to update user: %w", err)
	}

	return nil
}

// GetUserActivityLog retrieves activity logs for a user
func (r *Repository) GetUserActivityLog(ctx context.Context, userID string, limit, offset int) ([]UserActivity, error) {
	// First, ensure activity log table exists
	createTableQuery := `
		CREATE TABLE IF NOT EXISTS user_activity_logs (
			id VARCHAR(36) PRIMARY KEY,
			user_id VARCHAR(36) NOT NULL,
			action VARCHAR(100) NOT NULL,
			details TEXT,
			ip_address VARCHAR(45),
			user_agent TEXT,
			created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
			INDEX idx_activity_user_created (user_id, created_at DESC),
			FOREIGN KEY (user_id) REFERENCES users(id)
		)
	`

	_, err := r.db.ExecContext(ctx, createTableQuery)
	if err != nil {
		r.logger.Warn("Failed to ensure activity log table", zap.Error(err))
	}

	// Get activity logs
	query := `
		SELECT id, user_id, action, COALESCE(details, ''), 
		       COALESCE(ip_address, ''), COALESCE(user_agent, ''), created_at
		FROM user_activity_logs
		WHERE user_id = ?
		ORDER BY created_at DESC
		LIMIT ? OFFSET ?
	`

	rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get activity logs: %w", err)
	}
	defer rows.Close()

	var activities []UserActivity
	for rows.Next() {
		var activity UserActivity
		err := rows.Scan(
			&activity.ID, &activity.UserID, &activity.Action,
			&activity.Details, &activity.IPAddress, &activity.UserAgent,
			&activity.CreatedAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan activity row", zap.Error(err))
			continue
		}
		activities = append(activities, activity)
	}

	return activities, nil
}

// GrantPermission grants a permission to a user
func (r *Repository) GrantPermission(ctx context.Context, userID, permissionName string) error {
	// First get the permission ID
	var permissionID string
	err := r.db.QueryRowContext(ctx,
		"SELECT id FROM permissions WHERE name = ?",
		permissionName,
	).Scan(&permissionID)

	if err != nil {
		return fmt.Errorf("permission not found: %w", err)
	}

	// Grant the permission
	query := `
		INSERT INTO user_permissions (user_id, permission_id, granted_at)
		VALUES (?, ?, ?)
		ON DUPLICATE KEY UPDATE granted_at = VALUES(granted_at)
	`

	_, err = r.db.ExecContext(ctx, query, userID, permissionID, time.Now())
	if err != nil {
		return fmt.Errorf("failed to grant permission: %w", err)
	}

	return nil
}

// RevokePermission revokes a permission from a user
func (r *Repository) RevokePermission(ctx context.Context, userID, permissionName string) error {
	query := `
		DELETE up FROM user_permissions up
		JOIN permissions p ON up.permission_id = p.id
		WHERE up.user_id = ? AND p.name = ?
	`

	_, err := r.db.ExecContext(ctx, query, userID, permissionName)
	if err != nil {
		return fmt.Errorf("failed to revoke permission: %w", err)
	}

	return nil
}

// LogUserActivity logs a user action
func (r *Repository) LogUserActivity(ctx context.Context, activity *UserActivity) error {
	query := `
		INSERT INTO user_activity_logs 
		(id, user_id, action, details, ip_address, user_agent, created_at)
		VALUES (?, ?, ?, ?, ?, ?, ?)
	`

	_, err := r.db.ExecContext(ctx, query,
		activity.ID, activity.UserID, activity.Action,
		activity.Details, activity.IPAddress, activity.UserAgent,
		activity.CreatedAt,
	)

	return err
}
-------------------------------------------------
filepath = ./internal/auth-service/user/repository.go
package user

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"
	"golang.org/x/crypto/bcrypt"
)

// Repository handles user data access
type Repository struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewRepository creates a new user repository
func NewRepository(db *sql.DB, logger *zap.Logger) *Repository {
	return &Repository{
		db:     db,
		logger: logger,
	}
}

// CreateUser creates a new user with profile
func (r *Repository) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {
	// Start transaction
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	user := &User{
		ID:               uuid.New().String(),
		Email:            strings.ToLower(req.Email),
		PasswordHash:     string(hashedPassword),
		Role:             "user", // Default role
		ClientID:         req.ClientID,
		SubscriptionTier: "free", // Default tier
		IsActive:         true,
		EmailVerified:    false,
		CreatedAt:        time.Now(),
		UpdatedAt:        time.Now(),
	}

	// Insert user
	query := `
        INSERT INTO users (id, email, password_hash, role, client_id, subscription_tier, 
                          is_active, email_verified, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `

	_, err = tx.ExecContext(ctx, query,
		user.ID, user.Email, user.PasswordHash, user.Role, user.ClientID,
		user.SubscriptionTier, user.IsActive, user.EmailVerified,
		user.CreatedAt, user.UpdatedAt)

	if err != nil {
		if strings.Contains(err.Error(), "duplicate") {
			return nil, fmt.Errorf("user with email %s already exists", req.Email)
		}
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Create user profile
	profile := &UserProfile{
		UserID:    user.ID,
		FirstName: req.FirstName,
		LastName:  req.LastName,
		Company:   req.Company,
	}

	profileQuery := `
        INSERT INTO user_profiles (user_id, first_name, last_name, company)
        VALUES (?, ?, ?, ?)
    `

	_, err = tx.ExecContext(ctx, profileQuery,
		profile.UserID, profile.FirstName, profile.LastName, profile.Company)

	if err != nil {
		return nil, fmt.Errorf("failed to create user profile: %w", err)
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	user.Profile = profile
	r.logger.Info("User created successfully", zap.String("user_id", user.ID))

	return user, nil
}

// GetUserByEmail retrieves a user by email
func (r *Repository) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	email = strings.ToLower(email)

	var user User
	query := `
        SELECT id, email, password_hash, role, client_id, subscription_tier, 
               is_active, email_verified, created_at, updated_at, last_login_at
        FROM users
        WHERE email = ? AND is_active = true
    `

	err := r.db.QueryRowContext(ctx, query, email).Scan(
		&user.ID, &user.Email, &user.PasswordHash, &user.Role, &user.ClientID,
		&user.SubscriptionTier, &user.IsActive, &user.EmailVerified,
		&user.CreatedAt, &user.UpdatedAt, &user.LastLoginAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Load profile
	profile, err := r.getUserProfile(ctx, user.ID)
	if err == nil {
		user.Profile = profile
	}

	// Load permissions
	permissions, err := r.getUserPermissions(ctx, user.ID)
	if err == nil {
		user.Permissions = permissions
	}

	return &user, nil
}

// GetUserByID retrieves a user by ID
func (r *Repository) GetUserByID(ctx context.Context, userID string) (*User, error) {
	var user User
	query := `
        SELECT id, email, password_hash, role, client_id, subscription_tier, 
               is_active, email_verified, created_at, updated_at, last_login_at
        FROM users
        WHERE id = ? AND is_active = true
    `

	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&user.ID, &user.Email, &user.PasswordHash, &user.Role, &user.ClientID,
		&user.SubscriptionTier, &user.IsActive, &user.EmailVerified,
		&user.CreatedAt, &user.UpdatedAt, &user.LastLoginAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Load profile
	profile, err := r.getUserProfile(ctx, user.ID)
	if err == nil {
		user.Profile = profile
	}

	// Load permissions
	permissions, err := r.getUserPermissions(ctx, user.ID)
	if err == nil {
		user.Permissions = permissions
	}

	return &user, nil
}

// getUserProfile loads user profile
func (r *Repository) getUserProfile(ctx context.Context, userID string) (*UserProfile, error) {
	var profile UserProfile
	query := `
        SELECT user_id, first_name, last_name, company, phone, avatar_url, preferences
        FROM user_profiles
        WHERE user_id = ?
    `

	var preferences sql.NullString
	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&profile.UserID, &profile.FirstName, &profile.LastName,
		&profile.Company, &profile.Phone, &profile.AvatarURL, &preferences)

	if err != nil {
		return nil, err
	}

	if preferences.Valid {
		json.Unmarshal([]byte(preferences.String), &profile.Preferences)
	}

	return &profile, nil
}

// getUserPermissions loads user permissions
func (r *Repository) getUserPermissions(ctx context.Context, userID string) ([]string, error) {
	query := `
        SELECT p.name
        FROM permissions p
        JOIN user_permissions up ON p.id = up.permission_id
        WHERE up.user_id = ?
    `

	rows, err := r.db.QueryContext(ctx, query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var permissions []string
	for rows.Next() {
		var perm string
		if err := rows.Scan(&perm); err != nil {
			continue
		}
		permissions = append(permissions, perm)
	}

	return permissions, nil
}

// UpdateUser updates user information
func (r *Repository) UpdateUser(ctx context.Context, userID string, req *UpdateUserRequest) error {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Update user table
	userQuery := `UPDATE users SET updated_at = ? WHERE id = ?`
	_, err = tx.ExecContext(ctx, userQuery, time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to update user: %w", err)
	}

	// Update profile
	var setClauses []string
	var args []interface{}

	if req.FirstName != nil {
		setClauses = append(setClauses, "first_name = ?")
		args = append(args, *req.FirstName)
	}
	if req.LastName != nil {
		setClauses = append(setClauses, "last_name = ?")
		args = append(args, *req.LastName)
	}
	if req.Company != nil {
		setClauses = append(setClauses, "company = ?")
		args = append(args, *req.Company)
	}
	if req.Phone != nil {
		setClauses = append(setClauses, "phone = ?")
		args = append(args, *req.Phone)
	}
	if req.Preferences != nil {
		prefsJSON, _ := json.Marshal(req.Preferences)
		setClauses = append(setClauses, "preferences = ?")
		args = append(args, string(prefsJSON))
	}

	if len(setClauses) > 0 {
		args = append(args, userID)
		profileQuery := fmt.Sprintf(
			"UPDATE user_profiles SET %s WHERE user_id = ?",
			strings.Join(setClauses, ", "),
		)

		_, err = tx.ExecContext(ctx, profileQuery, args...)
		if err != nil {
			return fmt.Errorf("failed to update profile: %w", err)
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// ValidatePassword checks if the provided password matches
func (r *Repository) ValidatePassword(user *User, password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
	return err == nil
}

// UpdatePassword updates user password
func (r *Repository) UpdatePassword(ctx context.Context, userID, newPassword string) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	query := `UPDATE users SET password_hash = ?, updated_at = ? WHERE id = ?`
	_, err = r.db.ExecContext(ctx, query, string(hashedPassword), time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	return nil
}

// UpdateLastLogin updates the last login timestamp
func (r *Repository) UpdateLastLogin(ctx context.Context, userID string) error {
	query := `UPDATE users SET last_login_at = ? WHERE id = ?`
	_, err := r.db.ExecContext(ctx, query, time.Now(), userID)
	return err
}

// UpdateUserTier updates subscription tier
func (r *Repository) UpdateUserTier(ctx context.Context, userID, tier string) error {
	query := `UPDATE users SET subscription_tier = ?, updated_at = ? WHERE id = ?`
	_, err := r.db.ExecContext(ctx, query, tier, time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to update user tier: %w", err)
	}
	return nil
}

// DeleteUser soft deletes a user
func (r *Repository) DeleteUser(ctx context.Context, userID string) error {
	query := `UPDATE users SET is_active = false, updated_at = ? WHERE id = ?`
	_, err := r.db.ExecContext(ctx, query, time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to delete user: %w", err)
	}
	return nil
}
-------------------------------------------------
filepath = ./internal/auth-service/user/models.go
package user

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"
)

// User represents a user in the system
type User struct {
	ID               string     `json:"id" db:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
	Email            string     `json:"email" db:"email" example:"john.doe@example.com"`
	PasswordHash     string     `json:"-" db:"password_hash"`
	Role             string     `json:"role" db:"role" example:"user"`
	ClientID         string     `json:"client_id" db:"client_id" example:"client-123"`
	SubscriptionTier string     `json:"subscription_tier" db:"subscription_tier" example:"premium"`
	IsActive         bool       `json:"is_active" db:"is_active" example:"true"`
	EmailVerified    bool       `json:"email_verified" db:"email_verified" example:"true"`
	CreatedAt        time.Time  `json:"created_at" db:"created_at" example:"2024-01-15T10:30:00Z"`
	UpdatedAt        time.Time  `json:"updated_at" db:"updated_at" example:"2024-07-17T14:45:00Z"`
	LastLoginAt      *time.Time `json:"last_login_at,omitempty" db:"last_login_at" example:"2024-07-17T10:00:00Z"`

	// Additional fields
	Profile     *UserProfile `json:"profile,omitempty"`
	Permissions []string     `json:"permissions,omitempty" example:"read:agents,write:agents,read:workflows"`
}

// UserProfile contains additional user information
type UserProfile struct {
	UserID      string `json:"user_id" db:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	FirstName   string `json:"first_name" db:"first_name" example:"John"`
	LastName    string `json:"last_name" db:"last_name" example:"Doe"`
	Company     string `json:"company,omitempty" db:"company" example:"Acme Corp"`
	Phone       string `json:"phone,omitempty" db:"phone" example:"+1-555-123-4567"`
	AvatarURL   string `json:"avatar_url,omitempty" db:"avatar_url" example:"https://example.com/avatar.jpg"`
	Preferences JSONB  `json:"preferences,omitempty" db:"preferences"`
}

// JSONB handles JSON data in database
type JSONB map[string]interface{}

// Value implements driver.Valuer interface
func (j JSONB) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan implements sql.Scanner interface
func (j *JSONB) Scan(value interface{}) error {
	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("failed to scan JSONB")
	}
	return json.Unmarshal(bytes, j)
}

// CreateUserRequest for user registration
type CreateUserRequest struct {
	Email     string `json:"email" binding:"required,email" example:"john.doe@example.com"`
	Password  string `json:"password" binding:"required,min=8" example:"SecurePassword123!"`
	ClientID  string `json:"client_id" binding:"required" example:"client-123"`
	FirstName string `json:"first_name" example:"John"`
	LastName  string `json:"last_name" example:"Doe"`
	Company   string `json:"company" example:"Acme Corp"`
}

// UpdateUserRequest for user updates
type UpdateUserRequest struct {
	FirstName   *string `json:"first_name" example:"Jane"`
	LastName    *string `json:"last_name" example:"Smith"`
	Company     *string `json:"company" example:"Tech Corp"`
	Phone       *string `json:"phone" example:"+1-555-987-6543"`
	Preferences *JSONB  `json:"preferences"`
}

// ChangePasswordRequest for password changes
type ChangePasswordRequest struct {
	CurrentPassword string `json:"current_password" binding:"required" example:"OldPassword123!"`
	NewPassword     string `json:"new_password" binding:"required,min=8" example:"NewSecurePassword456!"`
}
-------------------------------------------------
filepath = ./internal/auth-service/user/doc.go
// Package user contains all user management and profile operations.
//
// This package defines the data structures and handlers for all user-centric
// actions such as retrieving profiles, updating details, and managing passwords.
//
// swagger:meta
package user
-------------------------------------------------
filepath = ./internal/auth-service/user/service.go
package user

import (
	"context"
	"fmt"
	"strings"

	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"go.uber.org/zap"
)

// Service handles business logic for users
type Service struct {
	repo   *Repository
	logger *zap.Logger
}

// NewService creates a new user service
func NewService(repo *Repository, logger *zap.Logger) *Service {
	return &Service{
		repo:   repo,
		logger: logger,
	}
}

// Register creates a new user account
func (s *Service) Register(ctx context.Context, req *CreateUserRequest) (*User, error) {
	// Validate email format
	req.Email = strings.ToLower(strings.TrimSpace(req.Email))

	// Check if user already exists
	existingUser, _ := s.repo.GetUserByEmail(ctx, req.Email)
	if existingUser != nil {
		return nil, fmt.Errorf("user with email %s already exists", req.Email)
	}

	// Create user
	user, err := s.repo.CreateUser(ctx, req)
	if err != nil {
		s.logger.Error("Failed to create user", zap.Error(err))
		return nil, err
	}

	// TODO: Send verification email

	s.logger.Info("User registered successfully",
		zap.String("user_id", user.ID),
		zap.String("email", user.Email))

	return user, nil
}

// Login validates user credentials
func (s *Service) Login(ctx context.Context, email, password string) (*User, error) {
	email = strings.ToLower(strings.TrimSpace(email))

	user, err := s.repo.GetUserByEmail(ctx, email)
	if err != nil {
		s.logger.Warn("Login attempt for non-existent user", zap.String("email", email))
		return nil, fmt.Errorf("invalid credentials")
	}

	if !s.repo.ValidatePassword(user, password) {
		s.logger.Warn("Invalid password attempt", zap.String("user_id", user.ID))
		return nil, fmt.Errorf("invalid credentials")
	}

	if !user.IsActive {
		return nil, fmt.Errorf("account is disabled")
	}

	// Update last login
	if err := s.repo.UpdateLastLogin(ctx, user.ID); err != nil {
		s.logger.Error("Failed to update last login", zap.Error(err))
	}

	return user, nil
}

// GetUser retrieves user details
func (s *Service) GetUser(ctx context.Context, userID string) (*User, error) {
	return s.repo.GetUserByID(ctx, userID)
}

// GetUserInfo returns user info for JWT token generation
func (s *Service) GetUserInfo(ctx context.Context, userID string) (*jwt.UserInfo, error) {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	return &jwt.UserInfo{
		UserID:      user.ID,
		Email:       user.Email,
		ClientID:    user.ClientID,
		Role:        user.Role,
		Tier:        user.SubscriptionTier,
		Permissions: user.Permissions,
	}, nil
}

// UpdateUser updates user information
func (s *Service) UpdateUser(ctx context.Context, userID string, req *UpdateUserRequest) error {
	return s.repo.UpdateUser(ctx, userID, req)
}

// ChangePassword changes user password
func (s *Service) ChangePassword(ctx context.Context, userID string, req *ChangePasswordRequest) error {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return err
	}

	// Validate current password
	if !s.repo.ValidatePassword(user, req.CurrentPassword) {
		return fmt.Errorf("current password is incorrect")
	}

	// Update password
	return s.repo.UpdatePassword(ctx, userID, req.NewPassword)
}

// DeleteUser deletes a user account
func (s *Service) DeleteUser(ctx context.Context, userID string) error {
	return s.repo.DeleteUser(ctx, userID)
}
-------------------------------------------------
filepath = ./internal/auth-service/admin/handlers_swagger.go
package admin

// NOTE: This file contains swagger annotations for the admin handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective handler files.

// HandleListUsers godoc
// @Summary      List users
// @Description  Get a paginated list of all users with filtering and sorting options (admin only)
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        page         query    int     false  "Page number"                          default(1) minimum(1)
// @Param        page_size    query    int     false  "Items per page"                       default(20) minimum(1) maximum(100)
// @Param        email        query    string  false  "Filter by email (partial match)"
// @Param        client_id    query    string  false  "Filter by client ID"
// @Param        role         query    string  false  "Filter by role"                       Enums(user,admin,moderator)
// @Param        tier         query    string  false  "Filter by subscription tier"          Enums(free,basic,premium,enterprise)
// @Param        is_active    query    boolean false  "Filter by active status"
// @Param        sort_by      query    string  false  "Sort field"                           default(created_at) Enums(created_at,updated_at,email,last_login_at)
// @Param        sort_order   query    string  false  "Sort order"                           default(desc) Enums(asc,desc)
// @Success      200          {object} admin.UserListResponse                 "List of users retrieved successfully"
// @Failure      400          {object} map[string]interface{}                 "Invalid query parameters"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users [get]
// @Security     Bearer
// @ID           adminListUsers

// HandleGetUser godoc
// @Summary      Get user details
// @Description  Get detailed information about a specific user including statistics (admin only)
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Success      200          {object} map[string]interface{}                 "User details with statistics"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id} [get]
// @Security     Bearer
// @ID           adminGetUser

// HandleUpdateUser godoc
// @Summary      Update user
// @Description  Update user details including role, subscription tier, and status (admin only)
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Param        request      body     admin.UpdateUserRequest true           "User update details"
// @Success      200          {object} user.User                              "Updated user details"
// @Failure      400          {object} map[string]interface{}                 "Invalid request body or invalid role/tier"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id} [put]
// @Security     Bearer
// @ID           adminUpdateUser

// HandleDeleteUser godoc
// @Summary      Delete user
// @Description  Soft delete a user account (admin only). Cannot delete your own account.
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Success      200          {object} map[string]interface{}                 "User deleted successfully"
// @Failure      400          {object} map[string]interface{}                 "Cannot delete your own account"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id} [delete]
// @Security     Bearer
// @ID           adminDeleteUser

// HandleGetUserActivity godoc
// @Summary      Get user activity
// @Description  Get activity logs for a specific user (admin only)
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Param        limit        query    int     false  "Maximum number of activities"         default(50) maximum(200)
// @Param        offset       query    int     false  "Number of activities to skip"         default(0)
// @Success      200          {object} map[string]interface{}                 "User activity logs"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id}/activity [get]
// @Security     Bearer
// @ID           adminGetUserActivity

// HandleGrantPermission godoc
// @Summary      Grant permission
// @Description  Grant a specific permission to a user (admin only)
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Param        request      body     admin.GrantPermissionRequest true      "Permission details"
// @Success      200          {object} map[string]interface{}                 "Permission granted successfully"
// @Failure      400          {object} map[string]interface{}                 "Invalid request body"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      409          {object} map[string]interface{}                 "Permission already exists"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id}/permissions [post]
// @Security     Bearer
// @ID           adminGrantPermission

// HandleRevokePermission godoc
// @Summary      Revoke permission
// @Description  Revoke a specific permission from a user (admin only)
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        user_id          path     string  true   "User ID"
// @Param        permission_name  path     string  true   "Permission name to revoke"
// @Success      200              {object} map[string]interface{}             "Permission revoked successfully"
// @Failure      401              {object} map[string]interface{}             "Unauthorized - no valid token"
// @Failure      403              {object} map[string]interface{}             "Forbidden - admin access required"
// @Failure      404              {object} map[string]interface{}             "User or permission not found"
// @Failure      500              {object} map[string]interface{}             "Internal server error"
// @Router       /admin/users/{user_id}/permissions/{permission_name} [delete]
// @Security     Bearer
// @ID           adminRevokePermission

// Bulk operations and advanced admin features

// HandleBulkUserOperation godoc
// @Summary      Bulk user operation
// @Description  Perform bulk operations on multiple users at once (admin only)
// @Tags         Admin - Bulk Operations
// @Accept       json
// @Produce      json
// @Param        request      body     admin.BulkUserOperation true           "Bulk operation details"
// @Success      200          {object} admin.BulkOperationResult              "Bulk operation results"
// @Failure      400          {object} map[string]interface{}                 "Invalid request body"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/bulk [post]
// @Security     Bearer
// @ID           adminBulkUserOperation

// HandleExportUsers godoc
// @Summary      Export users
// @Description  Export user data in CSV or JSON format with filtering (admin only)
// @Tags         Admin - Data Export
// @Accept       json
// @Produce      json,text/csv
// @Param        request      body     admin.UserExportRequest true           "Export configuration"
// @Success      200          {file}   file                                   "Exported user data (CSV or JSON)"
// @Failure      400          {object} map[string]interface{}                 "Invalid request body"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/export [post]
// @Security     Bearer
// @ID           adminExportUsers

// HandleImportUsers godoc
// @Summary      Import users
// @Description  Bulk import users from CSV file (admin only)
// @Tags         Admin - Data Import
// @Accept       multipart/form-data
// @Produce      json
// @Param        file         formData file    true   "CSV file containing user data"
// @Param        client_id    formData string  true   "Client ID for imported users"
// @Success      200          {object} admin.UserImportResult                "Import results with created user IDs"
// @Failure      400          {object} map[string]interface{}                 "Invalid file or missing client_id"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/import [post]
// @Security     Bearer
// @ID           adminImportUsers

// HandleGetUserSessions godoc
// @Summary      Get user sessions
// @Description  Get all active sessions for a specific user (admin only)
// @Tags         Admin - Session Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Success      200          {object} map[string]interface{}                 "List of active sessions"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id}/sessions [get]
// @Security     Bearer
// @ID           adminGetUserSessions

// HandleTerminateUserSessions godoc
// @Summary      Terminate user sessions
// @Description  Terminate all active sessions for a user, forcing them to re-login (admin only)
// @Tags         Admin - Session Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Param        request      body     admin.TerminateSessionsRequest true    "Termination reason"
// @Success      200          {object} map[string]interface{}                 "Sessions terminated successfully"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id}/sessions [delete]
// @Security     Bearer
// @ID           adminTerminateUserSessions

// HandleResetUserPassword godoc
// @Summary      Reset user password
// @Description  Administratively reset a user's password (admin only)
// @Tags         Admin - User Management
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Param        request      body     admin.ResetPasswordRequest true        "New password details"
// @Success      200          {object} map[string]interface{}                 "Password reset successfully"
// @Failure      400          {object} map[string]interface{}                 "Invalid password requirements"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id}/password [post]
// @Security     Bearer
// @ID           adminResetUserPassword

// HandleGetUserAuditLog godoc
// @Summary      Get user audit log
// @Description  Get detailed audit log for a specific user including all actions performed (admin only)
// @Tags         Admin - Audit
// @Accept       json
// @Produce      json
// @Param        user_id      path     string  true   "User ID"
// @Param        limit        query    int     false  "Maximum number of log entries"        default(100) maximum(500)
// @Param        start_date   query    string  false  "Start date for log entries (RFC3339)" format(date-time)
// @Param        end_date     query    string  false  "End date for log entries (RFC3339)"   format(date-time)
// @Success      200          {object} map[string]interface{}                 "Audit log entries"
// @Failure      401          {object} map[string]interface{}                 "Unauthorized - no valid token"
// @Failure      403          {object} map[string]interface{}                 "Forbidden - admin access required"
// @Failure      404          {object} map[string]interface{}                 "User not found"
// @Failure      500          {object} map[string]interface{}                 "Internal server error"
// @Router       /admin/users/{user_id}/audit [get]
// @Security     Bearer
// @ID           adminGetUserAuditLog
-------------------------------------------------
filepath = ./internal/auth-service/admin/handlers.go
package admin

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	u "github.com/gqls/agentchassis/internal/auth-service/user"
	"go.uber.org/zap"
)

// Handlers provides admin endpoints for user management
type Handlers struct {
	userRepo *u.Repository
	logger   *zap.Logger
}

// NewHandlers creates new admin handlers
func NewHandlers(userRepo *u.Repository, logger *zap.Logger) *Handlers {
	return &Handlers{
		userRepo: userRepo,
		logger:   logger,
	}
}

// UserListRequest represents query parameters for listing users
type UserListRequest struct {
	Page      int    `form:"page,default=1" json:"page" example:"1"`
	PageSize  int    `form:"page_size,default=20" json:"page_size" example:"20"`
	Email     string `form:"email" json:"email,omitempty" example:"john.doe@example.com"`
	ClientID  string `form:"client_id" json:"client_id,omitempty" example:"client-123"`
	Role      string `form:"role" json:"role,omitempty" example:"admin"`
	Tier      string `form:"tier" json:"tier,omitempty" example:"premium"`
	IsActive  *bool  `form:"is_active" json:"is_active,omitempty" example:"true"`
	SortBy    string `form:"sort_by,default=created_at" json:"sort_by" example:"created_at"`
	SortOrder string `form:"sort_order,default=desc" json:"sort_order" example:"desc"`
}

// UserListResponse represents paginated user list
type UserListResponse struct {
	Users      []u.User `json:"users"`
	TotalCount int      `json:"total_count" example:"250"`
	Page       int      `json:"page" example:"1"`
	PageSize   int      `json:"page_size" example:"20"`
	TotalPages int      `json:"total_pages" example:"13"`
}

// UpdateUserRequest represents admin user update
type UpdateUserRequest struct {
	Role             *string `json:"role,omitempty" example:"admin"`
	SubscriptionTier *string `json:"subscription_tier,omitempty" example:"enterprise"`
	IsActive         *bool   `json:"is_active,omitempty" example:"false"`
	EmailVerified    *bool   `json:"email_verified,omitempty" example:"true"`
}

// HandleListUsers returns a paginated list of users with filtering
func (h *Handlers) HandleListUsers(c *gin.Context) {
	var req UserListRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate pagination
	if req.Page < 1 {
		req.Page = 1
	}
	if req.PageSize < 1 || req.PageSize > 100 {
		req.PageSize = 20
	}

	// Get users from repository
	users, totalCount, err := h.userRepo.ListUsers(c.Request.Context(), u.ListUsersParams{
		Offset:    (req.Page - 1) * req.PageSize,
		Limit:     req.PageSize,
		Email:     req.Email,
		ClientID:  req.ClientID,
		Role:      req.Role,
		Tier:      req.Tier,
		IsActive:  req.IsActive,
		SortBy:    req.SortBy,
		SortOrder: req.SortOrder,
	})

	if err != nil {
		h.logger.Error("Failed to list users", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve users"})
		return
	}

	totalPages := (totalCount + req.PageSize - 1) / req.PageSize

	c.JSON(http.StatusOK, UserListResponse{
		Users:      users,
		TotalCount: totalCount,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	})
}

// HandleGetUser returns detailed information about a specific user
func (h *Handlers) HandleGetUser(c *gin.Context) {
	userID := c.Param("user_id")

	user, err := h.userRepo.GetUserByID(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Get additional statistics
	stats, err := h.userRepo.GetUserStats(c.Request.Context(), userID)
	if err != nil {
		h.logger.Warn("Failed to get user stats", zap.Error(err))
		stats = &u.UserStats{}
	}

	c.JSON(http.StatusOK, gin.H{
		"user":  user,
		"stats": stats,
	})
}

// HandleUpdateUser allows admins to update user details
func (h *Handlers) HandleUpdateUser(c *gin.Context) {
	userID := c.Param("user_id")

	var req UpdateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate role if provided
	if req.Role != nil {
		validRoles := map[string]bool{"user": true, "admin": true, "moderator": true}
		if !validRoles[*req.Role] {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role"})
			return
		}
	}

	// Validate tier if provided
	if req.SubscriptionTier != nil {
		validTiers := map[string]bool{"free": true, "basic": true, "premium": true, "enterprise": true}
		if !validTiers[*req.SubscriptionTier] {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid subscription tier"})
			return
		}
	}

	// Update user
	err := h.userRepo.AdminUpdateUser(c.Request.Context(), userID, &u.AdminUpdateRequest{
		Role:             req.Role,
		SubscriptionTier: req.SubscriptionTier,
		IsActive:         req.IsActive,
		EmailVerified:    req.EmailVerified,
	})

	if err != nil {
		h.logger.Error("Failed to update user", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
		return
	}

	// Return updated user
	updatedUser, _ := h.userRepo.GetUserByID(c.Request.Context(), userID)
	c.JSON(http.StatusOK, updatedUser)
}

// HandleDeleteUser soft deletes a user account
func (h *Handlers) HandleDeleteUser(c *gin.Context) {
	userID := c.Param("user_id")

	// Prevent self-deletion
	currentUserID := c.GetString("user_id")
	if currentUserID == userID {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot delete your own account"})
		return
	}

	err := h.userRepo.DeleteUser(c.Request.Context(), userID)
	if err != nil {
		h.logger.Error("Failed to delete user", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}

// HandleGetUserActivity returns user activity logs
func (h *Handlers) HandleGetUserActivity(c *gin.Context) {
	userID := c.Param("user_id")

	// Parse query parameters
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

	activities, err := h.userRepo.GetUserActivityLog(c.Request.Context(), userID, limit, offset)
	if err != nil {
		h.logger.Error("Failed to get user activity", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve activity log"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"user_id":    userID,
		"activities": activities,
		"count":      len(activities),
	})
}

// GrantPermissionRequest for granting permissions
type GrantPermissionRequest struct {
	PermissionName string `json:"permission_name" binding:"required" example:"manage_users"`
}

// HandleGrantPermission grants a permission to a user
func (h *Handlers) HandleGrantPermission(c *gin.Context) {
	userID := c.Param("user_id")

	var req GrantPermissionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	err := h.userRepo.GrantPermission(c.Request.Context(), userID, req.PermissionName)
	if err != nil {
		h.logger.Error("Failed to grant permission", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to grant permission"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "Permission granted successfully",
		"user_id":    userID,
		"permission": req.PermissionName,
	})
}

// HandleRevokePermission revokes a permission from a user
func (h *Handlers) HandleRevokePermission(c *gin.Context) {
	userID := c.Param("user_id")
	permissionName := c.Param("permission_name")

	err := h.userRepo.RevokePermission(c.Request.Context(), userID, permissionName)
	if err != nil {
		h.logger.Error("Failed to revoke permission", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to revoke permission"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":    "Permission revoked successfully",
		"user_id":    userID,
		"permission": permissionName,
	})
}
-------------------------------------------------
filepath = ./internal/auth-service/admin/user_management.go
package admin

import (
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/gqls/agentchassis/internal/auth-service/user"
	"go.uber.org/zap"
)

// UserManagementHandlers provides enhanced user management functionality
type UserManagementHandlers struct {
	userRepo *user.Repository
	db       *sql.DB
	logger   *zap.Logger
}

// NewUserManagementHandlers creates new user management handlers
func NewUserManagementHandlers(userRepo *user.Repository, db *sql.DB, logger *zap.Logger) *UserManagementHandlers {
	return &UserManagementHandlers{
		userRepo: userRepo,
		db:       db,
		logger:   logger,
	}
}

// BulkUserOperation represents a bulk operation on users
type BulkUserOperation struct {
	UserIDs   []string               `json:"user_ids" binding:"required" example:"user-123,user-456,user-789"`
	Operation string                 `json:"operation" binding:"required,oneof=activate deactivate delete upgrade_tier" example:"deactivate"`
	Params    map[string]interface{} `json:"params,omitempty"`
	Reason    string                 `json:"reason" example:"Policy violation - multiple account abuse"`
}

// BulkOperationResult for bulk operation outcomes
type BulkOperationResult struct {
	Operation string   `json:"operation" example:"deactivate"`
	Total     int      `json:"total" example:"10"`
	Succeeded int      `json:"succeeded" example:"8"`
	Failed    int      `json:"failed" example:"2"`
	Errors    []string `json:"errors,omitempty" example:"User user-123: User not found,User user-456: Database error"`
}

// UserExportRequest for exporting user data
type UserExportRequest struct {
	Format  string      `json:"format" binding:"required,oneof=csv json" example:"csv"`
	Filters UserFilters `json:"filters"`
	Fields  []string    `json:"fields,omitempty" example:"id,email,role,created_at"`
}

// UserFilters for filtering users
type UserFilters struct {
	ClientID         string     `json:"client_id,omitempty" example:"client-123"`
	SubscriptionTier string     `json:"subscription_tier,omitempty" example:"premium"`
	Role             string     `json:"role,omitempty" example:"admin"`
	IsActive         *bool      `json:"is_active,omitempty" example:"true"`
	CreatedAfter     *time.Time `json:"created_after,omitempty" example:"2024-01-01T00:00:00Z"`
	CreatedBefore    *time.Time `json:"created_before,omitempty" example:"2024-12-31T23:59:59Z"`
}

// UserImportResult tracks the result of a bulk import
type UserImportResult struct {
	TotalProcessed int      `json:"total_processed" example:"100"`
	Successful     int      `json:"successful" example:"95"`
	Failed         int      `json:"failed" example:"5"`
	Errors         []string `json:"errors,omitempty" example:"Row 23: Invalid email format,Row 45: Email already exists"`
	UserIDs        []string `json:"created_user_ids" example:"user-123,user-456,user-789"`
}

// UserSession represents an active user session
type UserSession struct {
	ID        string    `json:"id" example:"sess_123e4567-e89b-12d3-a456-426614174000"`
	ExpiresAt time.Time `json:"expires_at" example:"2024-07-18T15:30:00Z"`
	CreatedAt time.Time `json:"created_at" example:"2024-07-17T15:30:00Z"`
	IsActive  bool      `json:"is_active" example:"true"`
	IPAddress string    `json:"ip_address,omitempty" example:"192.168.1.100"`
	UserAgent string    `json:"user_agent,omitempty" example:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"`
}

// TerminateSessionsRequest for session termination
type TerminateSessionsRequest struct {
	Reason string `json:"reason" example:"Security breach detected"`
}

// ResetPasswordRequest for admin password reset
type ResetPasswordRequest struct {
	NewPassword      string `json:"new_password" binding:"required,min=8" example:"NewSecurePassword123!"`
	RequireChange    bool   `json:"require_change" example:"true"`
	NotifyUser       bool   `json:"notify_user" example:"true"`
	NotificationNote string `json:"notification_note,omitempty" example:"Your password has been reset for security reasons. Please change it upon login."`
}

// AuditLogEntry represents an audit log entry
type AuditLogEntry struct {
	ID        string                 `json:"id" example:"log_123e4567-e89b-12d3-a456-426614174000"`
	Action    string                 `json:"action" example:"password_changed"`
	Details   map[string]interface{} `json:"details"`
	IPAddress string                 `json:"ip_address" example:"192.168.1.100"`
	UserAgent string                 `json:"user_agent" example:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"`
	CreatedAt time.Time              `json:"created_at" example:"2024-07-17T14:30:00Z"`
}

// HandleBulkUserOperation performs bulk operations on multiple users
func (h *UserManagementHandlers) HandleBulkUserOperation(c *gin.Context) {
	var req BulkUserOperation
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Log the bulk operation
	h.logger.Info("Performing bulk user operation",
		zap.String("operation", req.Operation),
		zap.Int("user_count", len(req.UserIDs)),
		zap.String("admin_id", c.GetString("user_id")))

	result := BulkOperationResult{
		Operation: req.Operation,
		Total:     len(req.UserIDs),
		Succeeded: 0,
		Failed:    0,
		Errors:    []string{},
	}

	for _, userID := range req.UserIDs {
		var err error

		switch req.Operation {
		case "activate":
			err = h.activateUser(c.Request.Context(), userID)
		case "deactivate":
			err = h.deactivateUser(c.Request.Context(), userID, req.Reason)
		case "delete":
			err = h.deleteUser(c.Request.Context(), userID)
		case "upgrade_tier":
			if tier, ok := req.Params["tier"].(string); ok {
				err = h.upgradeTier(c.Request.Context(), userID, tier)
			} else {
				err = fmt.Errorf("tier parameter required for upgrade_tier operation")
			}
		}

		if err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("User %s: %v", userID, err))
		} else {
			result.Succeeded++
		}
	}

	// Log activity
	h.logBulkOperation(c.Request.Context(), c.GetString("user_id"), req)

	c.JSON(http.StatusOK, result)
}

// HandleExportUsers exports user data in various formats
func (h *UserManagementHandlers) HandleExportUsers(c *gin.Context) {
	var req UserExportRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Build query with filters
	query, args := h.buildUserExportQuery(req.Filters, req.Fields)

	rows, err := h.db.QueryContext(c.Request.Context(), query, args...)
	if err != nil {
		h.logger.Error("Failed to export users", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to export users"})
		return
	}
	defer rows.Close()

	switch req.Format {
	case "csv":
		h.exportAsCSV(c, rows, req.Fields)
	case "json":
		h.exportAsJSON(c, rows, req.Fields)
	}
}

// HandleImportUsers imports users from CSV
func (h *UserManagementHandlers) HandleImportUsers(c *gin.Context) {
	file, _, err := c.Request.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "File required"})
		return
	}
	defer file.Close()

	clientID := c.PostForm("client_id")
	if clientID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "client_id required"})
		return
	}

	// Parse CSV
	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid CSV file"})
		return
	}

	if len(records) < 2 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "CSV must have header and at least one row"})
		return
	}

	result := UserImportResult{
		TotalProcessed: len(records) - 1, // Excluding header
		Errors:         []string{},
		UserIDs:        []string{},
	}

	// Process each row
	headers := records[0]
	for i, row := range records[1:] {
		userReq := h.parseCSVRow(headers, row, clientID)

		createdUser, err := h.userRepo.CreateUser(c.Request.Context(), userReq)
		if err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("Row %d: %v", i+2, err))
		} else {
			result.Successful++
			result.UserIDs = append(result.UserIDs, createdUser.ID)
		}
	}

	c.JSON(http.StatusOK, result)
}

// HandleGetUserSessions returns active sessions for a user
func (h *UserManagementHandlers) HandleGetUserSessions(c *gin.Context) {
	userID := c.Param("user_id")

	sessions, err := h.getUserSessions(c.Request.Context(), userID)
	if err != nil {
		h.logger.Error("Failed to get user sessions", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get sessions"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"user_id":  userID,
		"sessions": sessions,
		"count":    len(sessions),
	})
}

// HandleTerminateUserSessions terminates all sessions for a user
func (h *UserManagementHandlers) HandleTerminateUserSessions(c *gin.Context) {
	userID := c.Param("user_id")

	var req TerminateSessionsRequest
	c.ShouldBindJSON(&req)

	// Invalidate all tokens for the user
	query := `DELETE FROM auth_tokens WHERE user_id = ?`
	result, err := h.db.ExecContext(c.Request.Context(), query, userID)
	if err != nil {
		h.logger.Error("Failed to terminate sessions", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to terminate sessions"})
		return
	}

	rowsAffected, _ := result.RowsAffected()

	// Log the action
	h.logUserActivity(c.Request.Context(), userID, "sessions_terminated", map[string]interface{}{
		"terminated_by": c.GetString("user_id"),
		"reason":        req.Reason,
		"count":         rowsAffected,
	})

	c.JSON(http.StatusOK, gin.H{
		"message":           "All sessions terminated",
		"sessions_affected": rowsAffected,
	})
}

// HandleResetUserPassword resets a user's password
func (h *UserManagementHandlers) HandleResetUserPassword(c *gin.Context) {
	userID := c.Param("user_id")

	var req ResetPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Update password
	err := h.userRepo.UpdatePassword(c.Request.Context(), userID, req.NewPassword)
	if err != nil {
		h.logger.Error("Failed to reset password", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to reset password"})
		return
	}

	// Terminate existing sessions
	h.db.ExecContext(c.Request.Context(), "DELETE FROM auth_tokens WHERE user_id = ?", userID)

	// Log the action
	h.logUserActivity(c.Request.Context(), userID, "password_reset", map[string]interface{}{
		"reset_by":       c.GetString("user_id"),
		"require_change": req.RequireChange,
		"notified":       req.NotifyUser,
	})

	// TODO: Send notification if requested

	c.JSON(http.StatusOK, gin.H{
		"message": "Password reset successfully",
		"user_id": userID,
	})
}

// HandleGetUserAuditLog returns audit log for a user
func (h *UserManagementHandlers) HandleGetUserAuditLog(c *gin.Context) {
	userID := c.Param("user_id")

	// Parse query params
	limit := 100
	if l := c.Query("limit"); l != "" {
		fmt.Sscanf(l, "%d", &limit)
	}

	startDate := time.Now().AddDate(0, -1, 0) // Default: last month
	if s := c.Query("start_date"); s != "" {
		startDate, _ = time.Parse(time.RFC3339, s)
	}

	endDate := time.Now()
	if e := c.Query("end_date"); e != "" {
		endDate, _ = time.Parse(time.RFC3339, e)
	}

	// Get audit logs
	logs, err := h.getUserAuditLog(c.Request.Context(), userID, startDate, endDate, limit)
	if err != nil {
		h.logger.Error("Failed to get audit log", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get audit log"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"user_id": userID,
		"logs":    logs,
		"count":   len(logs),
		"period": gin.H{
			"start": startDate,
			"end":   endDate,
		},
	})
}

// Helper methods

func (h *UserManagementHandlers) activateUser(ctx context.Context, userID string) error {
	query := `UPDATE users SET is_active = true, updated_at = NOW() WHERE id = ?`
	_, err := h.db.ExecContext(ctx, query, userID)
	return err
}

func (h *UserManagementHandlers) deactivateUser(ctx context.Context, userID, reason string) error {
	query := `UPDATE users SET is_active = false, updated_at = NOW() WHERE id = ?`
	_, err := h.db.ExecContext(ctx, query, userID)

	if err == nil {
		// Terminate all sessions
		h.db.ExecContext(ctx, "DELETE FROM auth_tokens WHERE user_id = ?", userID)

		// Log the deactivation
		h.logUserActivity(ctx, userID, "account_deactivated", map[string]interface{}{
			"reason": reason,
		})
	}

	return err
}

func (h *UserManagementHandlers) deleteUser(ctx context.Context, userID string) error {
	// Soft delete
	return h.userRepo.DeleteUser(ctx, userID)
}

func (h *UserManagementHandlers) upgradeTier(ctx context.Context, userID, tier string) error {
	return h.userRepo.UpdateUserTier(ctx, userID, tier)
}

func (h *UserManagementHandlers) buildUserExportQuery(filters UserFilters, fields []string) (string, []interface{}) {
	// Default fields if none specified
	if len(fields) == 0 {
		fields = []string{"id", "email", "role", "client_id", "subscription_tier", "created_at"}
	}

	// Build SELECT clause
	selectFields := []string{}
	for _, field := range fields {
		// Validate field names to prevent SQL injection
		if isValidField(field) {
			selectFields = append(selectFields, field)
		}
	}

	query := fmt.Sprintf("SELECT %s FROM users WHERE 1=1", strings.Join(selectFields, ", "))
	args := []interface{}{}
	argCount := 0

	// Add filters
	if filters.ClientID != "" {
		argCount++
		query += fmt.Sprintf(" AND client_id = ?")
		args = append(args, filters.ClientID)
	}

	if filters.SubscriptionTier != "" {
		argCount++
		query += fmt.Sprintf(" AND subscription_tier = ?")
		args = append(args, filters.SubscriptionTier)
	}

	if filters.Role != "" {
		argCount++
		query += fmt.Sprintf(" AND role = ?")
		args = append(args, filters.Role)
	}

	if filters.IsActive != nil {
		argCount++
		query += fmt.Sprintf(" AND is_active = ?")
		args = append(args, *filters.IsActive)
	}

	if filters.CreatedAfter != nil {
		argCount++
		query += fmt.Sprintf(" AND created_at > ?")
		args = append(args, *filters.CreatedAfter)
	}

	if filters.CreatedBefore != nil {
		argCount++
		query += fmt.Sprintf(" AND created_at < ?")
		args = append(args, *filters.CreatedBefore)
	}

	query += " ORDER BY created_at DESC"

	return query, args
}

func (h *UserManagementHandlers) exportAsCSV(c *gin.Context, rows *sql.Rows, fields []string) {
	c.Header("Content-Type", "text/csv")
	c.Header("Content-Disposition", "attachment; filename=users_export.csv")

	writer := csv.NewWriter(c.Writer)
	defer writer.Flush()

	// Write headers
	writer.Write(fields)

	// Write data
	for rows.Next() {
		values := make([]interface{}, len(fields))
		valuePtrs := make([]interface{}, len(fields))
		for i := range values {
			valuePtrs[i] = &values[i]
		}

		if err := rows.Scan(valuePtrs...); err != nil {
			continue
		}

		record := make([]string, len(fields))
		for i, v := range values {
			record[i] = fmt.Sprintf("%v", v)
		}
		writer.Write(record)
	}
}

func (h *UserManagementHandlers) exportAsJSON(c *gin.Context, rows *sql.Rows, fields []string) {
	users := []map[string]interface{}{}

	for rows.Next() {
		values := make([]interface{}, len(fields))
		valuePtrs := make([]interface{}, len(fields))
		for i := range values {
			valuePtrs[i] = &values[i]
		}

		if err := rows.Scan(valuePtrs...); err != nil {
			continue
		}

		user := make(map[string]interface{})
		for i, field := range fields {
			user[field] = values[i]
		}
		users = append(users, user)
	}

	c.JSON(http.StatusOK, gin.H{
		"users":       users,
		"count":       len(users),
		"exported_at": time.Now(),
	})
}

func (h *UserManagementHandlers) parseCSVRow(headers []string, row []string, clientID string) *user.CreateUserRequest {
	req := &user.CreateUserRequest{
		ClientID: clientID,
	}

	for i, header := range headers {
		if i < len(row) {
			switch strings.ToLower(header) {
			case "email":
				req.Email = row[i]
			case "password":
				req.Password = row[i]
			case "first_name", "firstname":
				req.FirstName = row[i]
			case "last_name", "lastname":
				req.LastName = row[i]
			case "company":
				req.Company = row[i]
			}
		}
	}

	// Generate password if not provided
	if req.Password == "" {
		req.Password = generateRandomPassword()
	}

	return req
}

func (h *UserManagementHandlers) getUserSessions(ctx context.Context, userID string) ([]UserSession, error) {
	sessions := []UserSession{}

	query := `
        SELECT id, token_hash, expires_at, created_at
        FROM auth_tokens
        WHERE user_id = ? AND expires_at > NOW()
        ORDER BY created_at DESC
    `

	rows, err := h.db.QueryContext(ctx, query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var session struct {
			ID        string
			TokenHash string
			ExpiresAt time.Time
			CreatedAt time.Time
		}

		if err := rows.Scan(&session.ID, &session.TokenHash, &session.ExpiresAt, &session.CreatedAt); err != nil {
			continue
		}

		sessions = append(sessions, UserSession{
			ID:        session.ID,
			ExpiresAt: session.ExpiresAt,
			CreatedAt: session.CreatedAt,
			IsActive:  true,
		})
	}

	return sessions, nil
}

func (h *UserManagementHandlers) getUserAuditLog(ctx context.Context, userID string, startDate, endDate time.Time, limit int) ([]AuditLogEntry, error) {
	logs := []AuditLogEntry{}

	query := `
        SELECT id, action, details, ip_address, user_agent, created_at
        FROM user_activity_logs
        WHERE user_id = ? AND created_at BETWEEN ? AND ?
        ORDER BY created_at DESC
        LIMIT ?
    `

	rows, err := h.db.QueryContext(ctx, query, userID, startDate, endDate, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var log user.UserActivity
		if err := rows.Scan(&log.ID, &log.Action, &log.Details, &log.IPAddress, &log.UserAgent, &log.CreatedAt); err != nil {
			continue
		}

		// Parse details JSON
		var details map[string]interface{}
		if err := json.Unmarshal([]byte(log.Details), &details); err != nil {
			details = map[string]interface{}{"raw": log.Details}
		}

		logs = append(logs, AuditLogEntry{
			ID:        log.ID,
			Action:    log.Action,
			Details:   details,
			IPAddress: log.IPAddress,
			UserAgent: log.UserAgent,
			CreatedAt: log.CreatedAt,
		})
	}

	return logs, nil
}

func (h *UserManagementHandlers) logUserActivity(ctx context.Context, userID, action string, details map[string]interface{}) {
	detailsJSON, _ := json.Marshal(details)

	activity := &user.UserActivity{
		ID:        uuid.NewString(),
		UserID:    userID,
		Action:    action,
		Details:   string(detailsJSON),
		CreatedAt: time.Now(),
	}

	h.userRepo.LogUserActivity(ctx, activity)
}

func (h *UserManagementHandlers) logBulkOperation(ctx context.Context, adminID string, operation BulkUserOperation) {
	details := map[string]interface{}{
		"operation":  operation.Operation,
		"user_count": len(operation.UserIDs),
		"reason":     operation.Reason,
		"params":     operation.Params,
	}

	h.logUserActivity(ctx, adminID, "bulk_user_operation", details)
}

func isValidField(field string) bool {
	allowedFields := map[string]bool{
		"id":                true,
		"email":             true,
		"role":              true,
		"client_id":         true,
		"subscription_tier": true,
		"is_active":         true,
		"created_at":        true,
		"updated_at":        true,
		"last_login_at":     true,
	}
	return allowedFields[field]
}

func generateRandomPassword() string {
	const (
		length  = 16
		charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	)
	b := make([]byte, length)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		// Fallback to less secure random generator if crypto/rand fails
		return "fallbackPassword123"
	}

	for i := 0; i < length; i++ {
		b[i] = charset[int(b[i])%len(charset)]
	}
	return string(b)
}
-------------------------------------------------
filepath = ./internal/auth-service/admin/repository.go
// FILE: internal/auth-service/admin/repository.go
package admin

import (
	"database/sql"
	"go.uber.org/zap"
)

// Repository handles admin data access
type Repository struct {
	db     *sql.DB
	logger *zap.Logger
	cfg    interface{} // Temporary for compatibility
}

// NewRepository creates a new admin repository
func NewRepository(db *sql.DB, logger *zap.Logger, cfg interface{}) *Repository {
	return &Repository{
		db:     db,
		logger: logger,
		cfg:    cfg,
	}
}

// Additional admin repository methods would go here
// This is a placeholder for admin-specific database operations
-------------------------------------------------
filepath = ./internal/auth-service/middleware/cors.go
// FILE: internal/auth-service/middleware/cors.go
package middleware

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// CORSMiddleware handles CORS headers
func CORSMiddleware(allowedOrigins []string) gin.HandlerFunc {
	return func(c *gin.Context) {
		origin := c.Request.Header.Get("Origin")

		// Check if origin is allowed
		allowed := false
		for _, allowedOrigin := range allowedOrigins {
			if allowedOrigin == "*" || allowedOrigin == origin {
				allowed = true
				break
			}
		}

		if allowed {
			c.Header("Access-Control-Allow-Origin", origin)
			c.Header("Access-Control-Allow-Credentials", "true")
			c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
			c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")
		}

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}

		c.Next()
	}
}
-------------------------------------------------
filepath = ./internal/auth-service/middleware/logging.go
// FILE: internal/auth-service/middleware/logging.go
package middleware

import (
	"time"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
)

// LoggingMiddleware logs HTTP requests
func LoggingMiddleware(logger *zap.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		raw := c.Request.URL.RawQuery

		// Process request
		c.Next()

		// Log after request is processed
		latency := time.Since(start)

		if raw != "" {
			path = path + "?" + raw
		}

		logger.Info("HTTP Request",
			zap.String("method", c.Request.Method),
			zap.String("path", path),
			zap.Int("status", c.Writer.Status()),
			zap.String("ip", c.ClientIP()),
			zap.Duration("latency", latency),
			zap.String("user_agent", c.Request.UserAgent()),
			zap.String("error", c.Errors.ByType(gin.ErrorTypePrivate).String()),
		)
	}
}
-------------------------------------------------
filepath = ./internal/auth-service/middleware/auth.go
// FILE: internal/auth-service/middleware/auth.go
package middleware

import (
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"go.uber.org/zap"
)

// RequireAuth validates JWT tokens
func RequireAuth(jwtService *jwt.Service, logger *zap.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		tokenString := strings.Replace(authHeader, "Bearer ", "", 1)

		claims, err := jwtService.ValidateToken(tokenString)
		if err != nil {
			logger.Debug("Token validation failed", zap.Error(err))
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		// Set user context
		c.Set("user_id", claims.UserID)
		c.Set("client_id", claims.ClientID)
		c.Set("user_email", claims.Email)
		c.Set("user_role", claims.Role)
		c.Set("user_tier", claims.Tier)
		c.Set("user_permissions", claims.Permissions)

		c.Next()
	}
}

// RequireRole checks if user has specific role
func RequireRole(role string) gin.HandlerFunc {
	return func(c *gin.Context) {
		userRole, exists := c.Get("user_role")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "No role found"})
			c.Abort()
			return
		}

		roleStr, ok := userRole.(string)
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid role format"})
			c.Abort()
			return
		}

		if roleStr != role {
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient role"})
			c.Abort()
			return
		}

		c.Next()
	}
}
-------------------------------------------------
filepath = ./internal/auth-service/API.md
# Auth Service Internal API Documentation

This document describes the internal APIs and message formats used by the auth-service.

## Overview

The auth-service is the API gateway for the AI Persona Platform. It handles:
- User authentication and authorization
- Proxying requests to internal services
- WebSocket connections for real-time features
- User and subscription management

## Internal HTTP Endpoints

These endpoints are only accessible within the Kubernetes cluster and are not exposed externally.

### Internal Health Check
```
GET /internal/health
```

Returns detailed health information including dependency status.

**Response:**
```json
{
  "status": "healthy",
  "service": "auth-service",
  "version": "1.1.0",
  "dependencies": {
    "mysql": "healthy",
    "core-manager": "healthy"
  }
}
```

### Internal Metrics
```
GET /internal/metrics
```

Prometheus metrics endpoint for monitoring.

## Gateway Proxy Routes

The auth-service proxies certain requests to internal services:

### To Core Manager

#### Template Management (Admin Only)
- `GET /api/v1/templates` → `core-manager:8088/api/v1/templates`
- `POST /api/v1/templates` → `core-manager:8088/api/v1/templates`
- `GET /api/v1/templates/{id}` → `core-manager:8088/api/v1/templates/{id}`
- `PUT /api/v1/templates/{id}` → `core-manager:8088/api/v1/templates/{id}`
- `DELETE /api/v1/templates/{id}` → `core-manager:8088/api/v1/templates/{id}`

#### Instance Management
- `GET /api/v1/personas/instances` → `core-manager:8088/api/v1/personas/instances`
- `POST /api/v1/personas/instances` → `core-manager:8088/api/v1/personas/instances`
- `GET /api/v1/personas/instances/{id}` → `core-manager:8088/api/v1/personas/instances/{id}`
- `PUT /api/v1/personas/instances/{id}` → `core-manager:8088/api/v1/personas/instances/{id}`
- `DELETE /api/v1/personas/instances/{id}` → `core-manager:8088/api/v1/personas/instances/{id}`

### Headers Added by Gateway

When proxying requests, the auth-service adds these headers:

```http
X-User-ID: <user_id>
X-Client-ID: <client_id>
X-User-Role: <role>
X-User-Tier: <subscription_tier>
X-User-Email: <email>
X-User-Permissions: <comma-separated-permissions>
```

## WebSocket Protocol

### Connection
```
GET /ws
Authorization: Bearer <token>
```

### Message Format

#### Client to Server
```json
{
  "type": "message_type",
  "id": "unique_message_id",
  "data": {
    // message-specific data
  }
}
```

#### Server to Client
```json
{
  "type": "message_type",
  "id": "message_id",
  "correlation_id": "original_message_id",
  "data": {
    // response data
  },
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable error"
  }
}
```

### Message Types

#### Start Workflow
```json
{
  "type": "start_workflow",
  "id": "msg-123",
  "data": {
    "workflow_type": "content_generation",
    "agent_instance_id": "instance-uuid",
    "project_id": "project-uuid",
    "parameters": {
      // workflow-specific parameters
    }
  }
}
```

#### Workflow Status Update
```json
{
  "type": "workflow_status",
  "correlation_id": "msg-123",
  "data": {
    "status": "in_progress|completed|failed",
    "step": "current_step_name",
    "progress": 0.75,
    "result": {
      // step results
    }
  }
}
```

## Database Schema

The auth-service manages the following tables in the auth database (MySQL):

### users
```sql
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user',
    client_id VARCHAR(100) NOT NULL,
    subscription_tier VARCHAR(50) DEFAULT 'free',
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);
```

### user_profiles
```sql
CREATE TABLE user_profiles (
    user_id VARCHAR(36) PRIMARY KEY REFERENCES users(id),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    company VARCHAR(255),
    phone VARCHAR(50),
    avatar_url VARCHAR(500),
    preferences JSON,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### projects
```sql
CREATE TABLE projects (
    id VARCHAR(36) PRIMARY KEY,
    client_id VARCHAR(100) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    owner_id VARCHAR(36) NOT NULL REFERENCES users(id),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### subscriptions
```sql
CREATE TABLE subscriptions (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL UNIQUE REFERENCES users(id),
    tier VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL,
    start_date TIMESTAMPTZ NOT NULL,
    end_date TIMESTAMPTZ,
    trial_ends_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,
    payment_method VARCHAR(100),
    stripe_customer_id VARCHAR(255),
    stripe_subscription_id VARCHAR(255),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

## Error Codes

The auth-service uses these standard error codes:

| Code | Description |
|------|-------------|
| AUTH001 | Invalid credentials |
| AUTH002 | Token expired |
| AUTH003 | Token invalid |
| AUTH004 | Insufficient permissions |
| USER001 | User not found |
| USER002 | User already exists |
| USER003 | Invalid password format |
| SUB001 | Subscription not found |
| SUB002 | Quota exceeded |
| GW001 | Upstream service unavailable |
| GW002 | Gateway timeout |

## Environment Variables

Required environment variables:

```bash
# Database
AUTH_DB_PASSWORD=<password>

# JWT
JWT_SECRET_KEY=<secret>

# Service URLs
CORE_MANAGER_URL=http://core-manager:8088

# Allowed Origins (CORS)
ALLOWED_ORIGINS=http://localhost:3000,https://app.personaplatform.com
```

## Integration Notes

### For Internal Services

When receiving requests from the auth-service gateway:
1. Trust the `X-User-*` headers for user context
2. Do NOT re-validate the JWT token
3. Use the provided user information for authorization decisions

### For Frontend Applications

1. Always include the JWT token in the Authorization header
2. Refresh tokens before they expire using the `/api/v1/auth/refresh` endpoint
3. Handle 401 responses by refreshing the token or redirecting to login
4. Use WebSocket for real-time updates on long-running operations-------------------------------------------------
filepath = ./internal/auth-service/project/handlers_swagger.go
package project

// NOTE: This file contains swagger annotations for the project handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective files.

// ListProjects godoc
// @Summary      List projects
// @Description  Get a list of all projects for the authenticated user
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Success      200 {object} project.ProjectListResponse "List of projects retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects [get]
// @Security     Bearer
// @ID           listProjects

// CreateProject godoc
// @Summary      Create project
// @Description  Create a new project for the authenticated user
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        request body project.CreateProjectRequest true "Project details"
// @Success      201 {object} project.Project "Project created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      409 {object} map[string]interface{} "Project with this name already exists"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects [post]
// @Security     Bearer
// @ID           createProject

// GetProject godoc
// @Summary      Get project
// @Description  Get detailed information about a specific project
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        id path string true "Project ID"
// @Success      200 {object} project.Project "Project details retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - no access to this project"
// @Failure      404 {object} map[string]interface{} "Project not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects/{id} [get]
// @Security     Bearer
// @ID           getProject

// UpdateProject godoc
// @Summary      Update project
// @Description  Update an existing project
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        id path string true "Project ID"
// @Param        request body project.UpdateProjectRequest true "Project update details"
// @Success      200 {object} project.Project "Project updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - no access to this project"
// @Failure      404 {object} map[string]interface{} "Project not found"
// @Failure      409 {object} map[string]interface{} "Project name already in use"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects/{id} [put]
// @Security     Bearer
// @ID           updateProject

// DeleteProject godoc
// @Summary      Delete project
// @Description  Delete a project and all associated resources
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        id path string true "Project ID"
// @Success      204 {string} string "Project deleted successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - no access to this project"
// @Failure      404 {object} map[string]interface{} "Project not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects/{id} [delete]
// @Security     Bearer
// @ID           deleteProject
-------------------------------------------------
filepath = ./internal/auth-service/project/handlers.go
// FILE: internal/auth-service/project/handlers.go
package project

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"
)

// HTTPHandler handles project-related HTTP requests
type HTTPHandler struct {
	repo   *Repository
	logger *zap.Logger
}

// NewHTTPHandler creates a new project HTTP handler
func NewHTTPHandler(repo *Repository, logger *zap.Logger) *HTTPHandler {
	return &HTTPHandler{
		repo:   repo,
		logger: logger,
	}
}

// CreateProjectRequest for creating a new project
type CreateProjectRequest struct {
	Name        string `json:"name" binding:"required" example:"My AI Assistant Project"`
	Description string `json:"description,omitempty" example:"A project for developing custom AI assistants"`
}

// UpdateProjectRequest for updating a project
type UpdateProjectRequest struct {
	Name        *string `json:"name,omitempty" example:"Updated Project Name"`
	Description *string `json:"description,omitempty" example:"Updated project description"`
}

// ProjectListResponse represents a list of projects
type ProjectListResponse struct {
	Projects []Project `json:"projects"`
	Count    int       `json:"count" example:"5"`
}

// CreateProject handles project creation
func (h *HTTPHandler) CreateProject(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	var req CreateProjectRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	project := &Project{
		ID:          uuid.New().String(),
		ClientID:    clientID,
		Name:        req.Name,
		Description: req.Description,
		OwnerID:     userID,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if err := h.repo.Create(r.Context(), project); err != nil {
		h.logger.Error("Failed to create project", zap.Error(err))
		http.Error(w, "Failed to create project", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(project)
}

// ListProjects returns all projects for a user
func (h *HTTPHandler) ListProjects(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	projects, err := h.repo.ListByUser(r.Context(), clientID, userID)
	if err != nil {
		h.logger.Error("Failed to list projects", zap.Error(err))
		http.Error(w, "Failed to retrieve projects", http.StatusInternalServerError)
		return
	}

	response := ProjectListResponse{
		Projects: projects,
		Count:    len(projects),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetProject returns a specific project
func (h *HTTPHandler) GetProject(w http.ResponseWriter, r *http.Request, projectID string) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	project, err := h.repo.GetByID(r.Context(), projectID)
	if err != nil {
		http.Error(w, "Project not found", http.StatusNotFound)
		return
	}

	// Verify ownership
	if project.ClientID != clientID || project.OwnerID != userID {
		http.Error(w, "Access denied", http.StatusForbidden)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(project)
}

// UpdateProject updates a project
func (h *HTTPHandler) UpdateProject(w http.ResponseWriter, r *http.Request, projectID string) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	// Verify ownership first
	project, err := h.repo.GetByID(r.Context(), projectID)
	if err != nil {
		http.Error(w, "Project not found", http.StatusNotFound)
		return
	}

	if project.ClientID != clientID || project.OwnerID != userID {
		http.Error(w, "Access denied", http.StatusForbidden)
		return
	}

	// Parse update request
	var req UpdateProjectRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Apply updates
	if req.Name != nil {
		project.Name = *req.Name
	}
	if req.Description != nil {
		project.Description = *req.Description
	}
	project.UpdatedAt = time.Now()

	if err := h.repo.Update(r.Context(), project); err != nil {
		h.logger.Error("Failed to update project", zap.Error(err))
		http.Error(w, "Failed to update project", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(project)
}

// DeleteProject deletes a project
func (h *HTTPHandler) DeleteProject(w http.ResponseWriter, r *http.Request, projectID string) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	// Verify ownership
	project, err := h.repo.GetByID(r.Context(), projectID)
	if err != nil {
		http.Error(w, "Project not found", http.StatusNotFound)
		return
	}

	if project.ClientID != clientID || project.OwnerID != userID {
		http.Error(w, "Access denied", http.StatusForbidden)
		return
	}

	if err := h.repo.Delete(r.Context(), projectID); err != nil {
		h.logger.Error("Failed to delete project", zap.Error(err))
		http.Error(w, "Failed to delete project", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}
-------------------------------------------------
filepath = ./internal/auth-service/project/repository.go
// FILE: internal/auth-service/project/repository.go
package project

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"go.uber.org/zap"
)

// Repository handles project data access
type Repository struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewRepository creates a new project repository
func NewRepository(db *sql.DB, logger *zap.Logger) *Repository {
	return &Repository{
		db:     db,
		logger: logger,
	}
}

// Create creates a new project
func (r *Repository) Create(ctx context.Context, project *Project) error {
	query := `
        INSERT INTO projects (id, client_id, name, description, owner_id, is_active, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `

	_, err := r.db.ExecContext(ctx, query,
		project.ID, project.ClientID, project.Name, project.Description,
		project.OwnerID, project.IsActive, project.CreatedAt, project.UpdatedAt,
	)

	if err != nil {
		return fmt.Errorf("failed to create project: %w", err)
	}

	return nil
}

// GetByID retrieves a project by ID
func (r *Repository) GetByID(ctx context.Context, id string) (*Project, error) {
	var p Project
	query := `
        SELECT id, client_id, name, description, owner_id, is_active, created_at, updated_at
        FROM projects
        WHERE id = ? AND is_active = true
    `

	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&p.ID, &p.ClientID, &p.Name, &p.Description,
		&p.OwnerID, &p.IsActive, &p.CreatedAt, &p.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("project not found")
		}
		return nil, err
	}

	return &p, nil
}

// ListByUser returns all projects for a user
func (r *Repository) ListByUser(ctx context.Context, clientID, userID string) ([]Project, error) {
	query := `
        SELECT id, client_id, name, description, owner_id, is_active, created_at, updated_at
        FROM projects
        WHERE client_id = ? AND owner_id = ? AND is_active = true
        ORDER BY created_at DESC
    `

	rows, err := r.db.QueryContext(ctx, query, clientID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var projects []Project
	for rows.Next() {
		var p Project
		if err := rows.Scan(
			&p.ID, &p.ClientID, &p.Name, &p.Description,
			&p.OwnerID, &p.IsActive, &p.CreatedAt, &p.UpdatedAt,
		); err != nil {
			r.logger.Error("Failed to scan project", zap.Error(err))
			continue
		}
		projects = append(projects, p)
	}

	return projects, nil
}

// Update updates a project
func (r *Repository) Update(ctx context.Context, project *Project) error {
	query := `
        UPDATE projects
        SET name = ?, description = ?, updated_at = ?
        WHERE id = ?
    `

	_, err := r.db.ExecContext(ctx, query,
		project.Name, project.Description, project.UpdatedAt, project.ID,
	)

	return err
}

// Delete soft deletes a project
func (r *Repository) Delete(ctx context.Context, id string) error {
	query := `
        UPDATE projects
        SET is_active = false, updated_at = ?
        WHERE id = ?
    `

	_, err := r.db.ExecContext(ctx, query, time.Now(), id)
	return err
}
-------------------------------------------------
filepath = ./internal/auth-service/project/models.go
// FILE: internal/auth-service/project/models.go
package project

import "time"

// Project represents a project in the system
type Project struct {
	ID          string    `json:"id" db:"id" example:"proj_123e4567-e89b-12d3-a456-426614174000"`
	ClientID    string    `json:"client_id" db:"client_id" example:"client-123"`
	Name        string    `json:"name" db:"name" example:"My AI Assistant Project"`
	Description string    `json:"description" db:"description" example:"A project for developing custom AI assistants"`
	OwnerID     string    `json:"owner_id" db:"owner_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	IsActive    bool      `json:"is_active" db:"is_active" example:"true"`
	CreatedAt   time.Time `json:"created_at" db:"created_at" example:"2024-01-15T10:30:00Z"`
	UpdatedAt   time.Time `json:"updated_at" db:"updated_at" example:"2024-07-17T14:45:00Z"`
}
-------------------------------------------------
filepath = ./internal/auth-service/jwt/claims.go
package jwt

import (
	"fmt"
	"github.com/golang-jwt/jwt/v5"
	"time"
)

// GetTokenFromString extracts claims without validation (for logging/debugging only)
func GetTokenFromString(tokenString string) (*Claims, error) {
	token, _, err := new(jwt.Parser).ParseUnverified(tokenString, &Claims{})
	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(*Claims); ok {
		return claims, nil
	}

	return nil, fmt.Errorf("invalid claims type")
}

// IsTokenExpired checks if a token is expired without full validation
func IsTokenExpired(claims *Claims) bool {
	return claims.ExpiresAt.Time.Before(time.Now())
}
-------------------------------------------------
filepath = ./internal/auth-service/jwt/service.go
package jwt

import (
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"go.uber.org/zap"
)

// Service handles JWT operations
type Service struct {
	secretKey       []byte
	accessTokenTTL  time.Duration
	refreshTokenTTL time.Duration
	logger          *zap.Logger
}

// Claims represents the JWT claims
type Claims struct {
	UserID      string   `json:"user_id"`
	Email       string   `json:"email"`
	ClientID    string   `json:"client_id"`
	Role        string   `json:"role"`
	Tier        string   `json:"tier"`
	Permissions []string `json:"permissions,omitempty"`
	jwt.RegisteredClaims
}

// RefreshClaims for refresh tokens
type RefreshClaims struct {
	UserID string `json:"user_id"`
	jwt.RegisteredClaims
}

// NewService creates a new JWT service
func NewService(secretKey string, accessMinutes int, logger *zap.Logger) (*Service, error) {
	if secretKey == "" {
		return nil, fmt.Errorf("JWT secret key cannot be empty")
	}

	return &Service{
		secretKey:       []byte(secretKey),
		accessTokenTTL:  time.Duration(accessMinutes) * time.Minute,
		refreshTokenTTL: 7 * 24 * time.Hour, // 7 days
		logger:          logger,
	}, nil
}

// GenerateTokens creates both access and refresh tokens
func (s *Service) GenerateTokens(userID, email, clientID, role, tier string, permissions []string) (string, string, error) {
	accessToken, err := s.generateAccessToken(userID, email, clientID, role, tier, permissions)
	if err != nil {
		return "", "", fmt.Errorf("failed to generate access token: %w", err)
	}

	refreshToken, err := s.generateRefreshToken(userID)
	if err != nil {
		return "", "", fmt.Errorf("failed to generate refresh token: %w", err)
	}

	return accessToken, refreshToken, nil
}

// generateAccessToken creates an access token with full claims
func (s *Service) generateAccessToken(userID, email, clientID, role, tier string, permissions []string) (string, error) {
	now := time.Now()
	claims := Claims{
		UserID:      userID,
		Email:       email,
		ClientID:    clientID,
		Role:        role,
		Tier:        tier,
		Permissions: permissions,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(now.Add(s.accessTokenTTL)),
			IssuedAt:  jwt.NewNumericDate(now),
			NotBefore: jwt.NewNumericDate(now),
			Issuer:    "ai-persona-system",
			Subject:   userID,
			ID:        fmt.Sprintf("%d", now.Unix()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(s.secretKey)
}

// generateRefreshToken creates a refresh token with minimal claims
func (s *Service) generateRefreshToken(userID string) (string, error) {
	now := time.Now()
	claims := RefreshClaims{
		UserID: userID,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(now.Add(s.refreshTokenTTL)),
			IssuedAt:  jwt.NewNumericDate(now),
			Subject:   userID,
			ID:        fmt.Sprintf("refresh_%d", now.Unix()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(s.secretKey)
}

// ValidateToken validates and parses an access token
func (s *Service) ValidateToken(tokenString string) (*Claims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.secretKey, nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse token: %w", err)
	}

	if claims, ok := token.Claims.(*Claims); ok && token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf("invalid token claims")
}

// ValidateRefreshToken validates a refresh token
func (s *Service) ValidateRefreshToken(tokenString string) (*RefreshClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &RefreshClaims{}, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.secretKey, nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse refresh token: %w", err)
	}

	if claims, ok := token.Claims.(*RefreshClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf("invalid refresh token")
}

// RefreshAccessToken creates a new access token from a refresh token
func (s *Service) RefreshAccessToken(refreshToken string, getUserFunc func(userID string) (*UserInfo, error)) (string, error) {
	claims, err := s.ValidateRefreshToken(refreshToken)
	if err != nil {
		return "", err
	}

	// Get updated user details
	userInfo, err := getUserFunc(claims.UserID)
	if err != nil {
		return "", fmt.Errorf("failed to get user details: %w", err)
	}

	// Generate new access token with current user info
	return s.generateAccessToken(
		userInfo.UserID,
		userInfo.Email,
		userInfo.ClientID,
		userInfo.Role,
		userInfo.Tier,
		userInfo.Permissions,
	)
}

// UserInfo holds user information for token generation
type UserInfo struct {
	UserID      string
	Email       string
	ClientID    string
	Role        string
	Tier        string
	Permissions []string
}
-------------------------------------------------
filepath = ./internal/auth-service/auth/middleware.go
package auth

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"go.uber.org/zap"
)

// AuthMiddleware validates JWT tokens
func AuthMiddleware(jwtService *jwt.Service, logger *zap.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		// Extract token
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
			c.Abort()
			return
		}

		tokenString := parts[1]

		// Validate token
		claims, err := jwtService.ValidateToken(tokenString)
		if err != nil {
			logger.Debug("Token validation failed", zap.Error(err))
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		// Set user context
		c.Set("user_id", claims.UserID)
		c.Set("client_id", claims.ClientID)
		c.Set("user_email", claims.Email)
		c.Set("user_role", claims.Role)
		c.Set("user_tier", claims.Tier)
		c.Set("user_permissions", claims.Permissions)
		c.Set("token_id", claims.ID)
		c.Set("claims", claims)

		c.Next()
	}
}

// RequirePermission checks if user has specific permission
func RequirePermission(permission string) gin.HandlerFunc {
	return func(c *gin.Context) {
		permissions, exists := c.Get("user_permissions")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "No permissions found"})
			c.Abort()
			return
		}

		userPerms, ok := permissions.([]string)
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid permissions format"})
			c.Abort()
			return
		}

		// Check permission
		hasPermission := false
		for _, p := range userPerms {
			if p == permission || p == "*" { // "*" is superuser
				hasPermission = true
				break
			}
		}

		if !hasPermission {
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// RequireRole checks if user has specific role
func RequireRole(roles ...string) gin.HandlerFunc {
	return func(c *gin.Context) {
		userRole, exists := c.Get("user_role")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "No role found"})
			c.Abort()
			return
		}

		role, ok := userRole.(string)
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid role format"})
			c.Abort()
			return
		}

		// Check role
		hasRole := false
		for _, r := range roles {
			if r == role {
				hasRole = true
				break
			}
		}

		if !hasRole {
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient role"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// RequireTier checks if user has minimum subscription tier
func RequireTier(minTier string) gin.HandlerFunc {
	tierLevels := map[string]int{
		"free":       0,
		"basic":      1,
		"premium":    2,
		"enterprise": 3,
	}

	return func(c *gin.Context) {
		userTier, exists := c.Get("user_tier")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "No subscription tier found"})
			c.Abort()
			return
		}

		tier, ok := userTier.(string)
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid tier format"})
			c.Abort()
			return
		}

		userLevel, exists := tierLevels[tier]
		if !exists {
			userLevel = 0 // Default to free
		}

		requiredLevel, exists := tierLevels[minTier]
		if !exists {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid required tier"})
			c.Abort()
			return
		}

		if userLevel < requiredLevel {
			c.JSON(http.StatusForbidden, gin.H{
				"error":         fmt.Sprintf("This feature requires %s tier or higher", minTier),
				"current_tier":  tier,
				"required_tier": minTier,
			})
			c.Abort()
			return
		}

		c.Next()
	}
}
-------------------------------------------------
filepath = ./internal/auth-service/auth/handlers_swagger.go
package auth

// NOTE: This file contains swagger annotations for the auth handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective handler files.

// HandleRegister godoc
// @Summary      Register a new user
// @Description  Creates a new user account with the provided credentials and client association
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Param        request body auth.RegisterRequest true "Registration details"
// @Success      201 {object} auth.TokenResponse "User successfully registered with tokens"
// @Failure      400 {object} map[string]interface{} "Invalid request body or validation error"
// @Failure      409 {object} map[string]interface{} "User already exists"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /auth/register [post]
// @ID           registerUser

// HandleLogin godoc
// @Summary      User login
// @Description  Authenticates a user with email and password, returns access and refresh tokens
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Param        request body auth.LoginRequest true "Login credentials"
// @Success      200 {object} auth.TokenResponse "Login successful with tokens and user info"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Invalid credentials"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /auth/login [post]
// @ID           loginUser

// HandleRefresh godoc
// @Summary      Refresh access token
// @Description  Uses a valid refresh token to obtain a new access token and refresh token pair
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Param        request body auth.RefreshRequest true "Refresh token"
// @Success      200 {object} auth.TokenResponse "New tokens generated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Invalid or expired refresh token"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /auth/refresh [post]
// @ID           refreshToken

// HandleValidate godoc
// @Summary      Validate token
// @Description  Validates the provided access token and returns user information if valid
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Success      200 {object} map[string]interface{} "Token is valid with user details"
// @Failure      401 {object} map[string]interface{} "Invalid or expired token"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /auth/validate [post]
// @Security     Bearer
// @ID           validateToken

// HandleLogout godoc
// @Summary      Logout user
// @Description  Invalidates the current session and revokes the refresh token
// @Tags         Authentication
// @Accept       json
// @Produce      json
// @Success      200 {object} map[string]interface{} "Logout successful"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Failed to logout"
// @Router       /auth/logout [post]
// @Security     Bearer
// @ID           logoutUser
-------------------------------------------------
filepath = ./internal/auth-service/auth/handlers.go
package auth

import (
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/auth-service/user"
)

// Handlers wraps the auth service for HTTP handling
type Handlers struct {
	service ServiceInterface
}

// NewHandlers creates new auth handlers
func NewHandlers(service *Service) *Handlers {
	return &Handlers{service: service}
}

// RegisterRequest represents registration data
type RegisterRequest struct {
	Email     string `json:"email" binding:"required,email" example:"john.doe@example.com"`
	Password  string `json:"password" binding:"required,min=8" example:"SecurePassword123!"`
	ClientID  string `json:"client_id" binding:"required" example:"client-123"`
	FirstName string `json:"first_name" example:"John"`
	LastName  string `json:"last_name" example:"Doe"`
	Company   string `json:"company" example:"Acme Corp"`
}

// LoginRequest represents login data
type LoginRequest struct {
	Email    string `json:"email" binding:"required,email" example:"john.doe@example.com"`
	Password string `json:"password" binding:"required" example:"SecurePassword123!"`
}

// RefreshRequest represents token refresh data
type RefreshRequest struct {
	RefreshToken string `json:"refresh_token" binding:"required" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
}

// HandleRegister handles user registration
func (h *Handlers) HandleRegister(c *gin.Context) {
	var req RegisterRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Convert to user create request
	userReq := &user.CreateUserRequest{
		Email:     req.Email,
		Password:  req.Password,
		ClientID:  req.ClientID,
		FirstName: req.FirstName,
		LastName:  req.LastName,
		Company:   req.Company,
	}

	response, err := h.service.Register(c.Request.Context(), userReq)
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
			return
		}
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, response)
}

// HandleLogin handles user login
func (h *Handlers) HandleLogin(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	response, err := h.service.Login(c.Request.Context(), req.Email, req.Password)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	c.JSON(http.StatusOK, response)
}

// HandleRefresh handles token refresh
func (h *Handlers) HandleRefresh(c *gin.Context) {
	var req RefreshRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	response, err := h.service.RefreshToken(c.Request.Context(), req.RefreshToken)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, response)
}

// HandleLogout handles user logout
func (h *Handlers) HandleLogout(c *gin.Context) {
	// Get token ID from claims
	tokenID := c.GetString("token_id")

	if err := h.service.Logout(c.Request.Context(), tokenID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to logout"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Successfully logged out"})
}

// HandleValidate validates the current token
func (h *Handlers) HandleValidate(c *gin.Context) {
	// Get the token from the Authorization header
	authHeader := c.GetHeader("Authorization")
	if authHeader == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "No token provided"})
		return
	}

	tokenString := strings.Replace(authHeader, "Bearer ", "", 1)

	// Validate the token using the service
	claims, err := h.service.ValidateToken(tokenString)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token", "details": err.Error()})
		return
	}

	// Return the validation result
	c.JSON(http.StatusOK, gin.H{
		"valid": true,
		"user": gin.H{
			"id":          claims.UserID,
			"email":       claims.Email,
			"role":        claims.Role,
			"tier":        claims.Tier,
			"client_id":   claims.ClientID,
			"permissions": claims.Permissions,
		},
	})
}
-------------------------------------------------
filepath = ./internal/auth-service/auth/handlers_test.go
// FILE: internal/auth-service/auth/handlers_test.go
package auth

import (
	"bytes"
	"context" // Add this import
	"encoding/json"
	"fmt"
	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/auth-service/user" // Add this import
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// MockService for testing
type MockService struct {
	mock.Mock
}

func (m *MockService) Register(ctx context.Context, req *user.CreateUserRequest) (*TokenResponse, error) {
	args := m.Called(ctx, req)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*TokenResponse), args.Error(1)
}

func (m *MockService) Login(ctx context.Context, email, password string) (*TokenResponse, error) {
	args := m.Called(ctx, email, password)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*TokenResponse), args.Error(1)
}

func (m *MockService) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) {
	args := m.Called(ctx, refreshToken)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*TokenResponse), args.Error(1)
}

func (m *MockService) Logout(ctx context.Context, tokenID string) error {
	args := m.Called(ctx, tokenID)
	return args.Error(0)
}

func (m *MockService) ValidateToken(tokenString string) (*jwt.Claims, error) {
	args := m.Called(tokenString)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*jwt.Claims), args.Error(1)
}

func TestHandleRegister(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name           string
		requestBody    RegisterRequest
		mockResponse   *TokenResponse
		mockError      error
		expectedStatus int
		expectedBody   string
	}{
		{
			name: "successful registration",
			requestBody: RegisterRequest{
				Email:     "newuser@example.com",
				Password:  "password123",
				ClientID:  "client-1",
				FirstName: "Test",
				LastName:  "User",
			},
			mockResponse: &TokenResponse{
				AccessToken: "new_access_token",
				TokenType:   "Bearer",
			},
			expectedStatus: http.StatusCreated,
			expectedBody:   "new_access_token",
		},
		{
			name: "user already exists",
			requestBody: RegisterRequest{
				Email:    "existing@example.com",
				Password: "password123",
				ClientID: "client-1",
			},
			mockError:      fmt.Errorf("user with email existing@example.com already exists"),
			expectedStatus: http.StatusConflict,
			expectedBody:   "already exists",
		},
		{
			name: "bad request - missing password",
			requestBody: RegisterRequest{
				Email: "test@example.com",
			},
			expectedStatus: http.StatusBadRequest,
			expectedBody:   "Password",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockService := new(MockService)
			handler := &Handlers{service: mockService}

			// Setup mock expectation
			if tt.mockError != nil || tt.mockResponse != nil {
				// We expect the service's Register method to be called
				userReq := &user.CreateUserRequest{
					Email:     tt.requestBody.Email,
					Password:  tt.requestBody.Password,
					ClientID:  tt.requestBody.ClientID,
					FirstName: tt.requestBody.FirstName,
					LastName:  tt.requestBody.LastName,
				}
				mockService.On("Register", mock.Anything, userReq).Return(tt.mockResponse, tt.mockError).Once()
			}

			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			body, _ := json.Marshal(tt.requestBody)
			c.Request = httptest.NewRequest("POST", "/register", bytes.NewBuffer(body))
			c.Request.Header.Set("Content-Type", "application/json")

			handler.HandleRegister(c)

			assert.Equal(t, tt.expectedStatus, w.Code)
			assert.Contains(t, w.Body.String(), tt.expectedBody)

			// Verify that the mock was called if it was expected
			if tt.mockError != nil || tt.mockResponse != nil {
				mockService.AssertExpectations(t)
			}
		})
	}
}

func TestHandleLogin(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name           string
		requestBody    LoginRequest
		mockResponse   *TokenResponse
		mockError      error
		expectedStatus int
	}{
		{
			name: "successful login",
			requestBody: LoginRequest{
				Email:    "test@example.com",
				Password: "password123",
			},
			mockResponse: &TokenResponse{
				AccessToken:  "test_token",
				RefreshToken: "refresh_token",
				TokenType:    "Bearer",
				ExpiresIn:    3600,
			},
			expectedStatus: http.StatusOK,
		},
		{
			name: "invalid credentials",
			requestBody: LoginRequest{
				Email:    "test@example.com",
				Password: "wrong_password",
			},
			mockError:      fmt.Errorf("invalid credentials"),
			expectedStatus: http.StatusUnauthorized,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockService := new(MockService)
			handler := &Handlers{service: mockService}

			if tt.mockResponse != nil {
				mockService.On("Login", mock.Anything, tt.requestBody.Email, tt.requestBody.Password).
					Return(tt.mockResponse, nil)
			} else {
				mockService.On("Login", mock.Anything, tt.requestBody.Email, tt.requestBody.Password).
					Return(nil, tt.mockError)
			}

			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			body, _ := json.Marshal(tt.requestBody)
			c.Request = httptest.NewRequest("POST", "/login", bytes.NewBuffer(body))
			c.Request.Header.Set("Content-Type", "application/json")

			handler.HandleLogin(c)

			assert.Equal(t, tt.expectedStatus, w.Code)
			mockService.AssertExpectations(t)
		})
	}
}

func TestHandleRefresh(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name           string
		requestBody    RefreshRequest
		mockResponse   *TokenResponse
		mockError      error
		expectedStatus int
		expectedBody   string
	}{
		{
			name: "successful refresh",
			requestBody: RefreshRequest{
				RefreshToken: "valid_refresh_token",
			},
			mockResponse: &TokenResponse{
				AccessToken: "new_access_token_from_refresh",
				TokenType:   "Bearer",
			},
			expectedStatus: http.StatusOK,
			expectedBody:   "new_access_token_from_refresh",
		},
		{
			name: "invalid refresh token",
			requestBody: RefreshRequest{
				RefreshToken: "invalid_or_expired_token",
			},
			mockError:      fmt.Errorf("invalid refresh token"),
			expectedStatus: http.StatusUnauthorized,
			expectedBody:   "invalid refresh token",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockService := new(MockService)
			handler := &Handlers{service: mockService}

			// Setup mock expectation
			mockService.On("RefreshToken", mock.Anything, tt.requestBody.RefreshToken).
				Return(tt.mockResponse, tt.mockError).
				Once()

			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			body, _ := json.Marshal(tt.requestBody)
			c.Request = httptest.NewRequest("POST", "/refresh", bytes.NewBuffer(body))
			c.Request.Header.Set("Content-Type", "application/json")

			handler.HandleRefresh(c)

			assert.Equal(t, tt.expectedStatus, w.Code)
			assert.Contains(t, w.Body.String(), tt.expectedBody)
			mockService.AssertExpectations(t)
		})
	}
}
-------------------------------------------------
filepath = ./internal/auth-service/auth/service.go
package auth

import (
	"context"
	"fmt"
	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"github.com/gqls/agentchassis/internal/auth-service/user"
	"go.uber.org/zap"
)

// Service handles authentication logic
type Service struct {
	userService *user.Service
	jwtService  *jwt.Service
	logger      *zap.Logger
}

// NewService creates a new auth service
func NewService(userService *user.Service, jwtService *jwt.Service, logger *zap.Logger) *Service {
	return &Service{
		userService: userService,
		jwtService:  jwtService,
		logger:      logger,
	}
}

// TokenResponse represents the auth response
type TokenResponse struct {
	AccessToken  string    `json:"access_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
	RefreshToken string    `json:"refresh_token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
	TokenType    string    `json:"token_type" example:"Bearer"`
	ExpiresIn    int       `json:"expires_in" example:"3600"`
	User         *UserInfo `json:"user"`
}

// UserInfo in token response
type UserInfo struct {
	ID            string   `json:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
	Email         string   `json:"email" example:"john.doe@example.com"`
	ClientID      string   `json:"client_id" example:"client-123"`
	Role          string   `json:"role" example:"user"`
	Tier          string   `json:"tier" example:"premium"`
	EmailVerified bool     `json:"email_verified" example:"true"`
	Permissions   []string `json:"permissions" example:"read:agents,write:agents,read:workflows"`
}

// Register handles user registration
func (s *Service) Register(ctx context.Context, req *user.CreateUserRequest) (*TokenResponse, error) {
	// Create user
	newUser, err := s.userService.Register(ctx, req)
	if err != nil {
		return nil, err
	}

	// Generate tokens
	accessToken, refreshToken, err := s.jwtService.GenerateTokens(
		newUser.ID,
		newUser.Email,
		newUser.ClientID,
		newUser.Role,
		newUser.SubscriptionTier,
		newUser.Permissions,
	)
	if err != nil {
		s.logger.Error("Failed to generate tokens", zap.Error(err))
		return nil, fmt.Errorf("failed to generate tokens")
	}

	return &TokenResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		TokenType:    "Bearer",
		ExpiresIn:    3600, // 1 hour
		User: &UserInfo{
			ID:            newUser.ID,
			Email:         newUser.Email,
			ClientID:      newUser.ClientID,
			Role:          newUser.Role,
			Tier:          newUser.SubscriptionTier,
			EmailVerified: newUser.EmailVerified,
			Permissions:   newUser.Permissions,
		},
	}, nil
}

// Login handles user login
func (s *Service) Login(ctx context.Context, email, password string) (*TokenResponse, error) {
	// Validate credentials
	user, err := s.userService.Login(ctx, email, password)
	if err != nil {
		return nil, err
	}

	// Generate tokens
	accessToken, refreshToken, err := s.jwtService.GenerateTokens(
		user.ID,
		user.Email,
		user.ClientID,
		user.Role,
		user.SubscriptionTier,
		user.Permissions,
	)
	if err != nil {
		s.logger.Error("Failed to generate tokens", zap.Error(err))
		return nil, fmt.Errorf("failed to generate tokens")
	}

	return &TokenResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		TokenType:    "Bearer",
		ExpiresIn:    3600,
		User: &UserInfo{
			ID:            user.ID,
			Email:         user.Email,
			ClientID:      user.ClientID,
			Role:          user.Role,
			Tier:          user.SubscriptionTier,
			EmailVerified: user.EmailVerified,
			Permissions:   user.Permissions,
		},
	}, nil
}

// RefreshToken handles token refresh
func (s *Service) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) {
	// Validate refresh token and get new access token
	getUserFunc := func(userID string) (*jwt.UserInfo, error) {
		return s.userService.GetUserInfo(ctx, userID)
	}

	accessToken, err := s.jwtService.RefreshAccessToken(refreshToken, getUserFunc)
	if err != nil {
		return nil, fmt.Errorf("invalid refresh token")
	}

	// Get user info for response
	claims, _ := s.jwtService.ValidateToken(accessToken)

	return &TokenResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken, // Return same refresh token
		TokenType:    "Bearer",
		ExpiresIn:    3600,
		User: &UserInfo{
			ID:          claims.UserID,
			Email:       claims.Email,
			ClientID:    claims.ClientID,
			Role:        claims.Role,
			Tier:        claims.Tier,
			Permissions: claims.Permissions,
		},
	}, nil
}

// Logout handles user logout (for future implementation with token blacklisting)
func (s *Service) Logout(ctx context.Context, tokenID string) error {
	// In a stateless JWT system, logout is typically handled client-side
	// For added security, you could implement token blacklisting here
	s.logger.Info("User logged out", zap.String("token_id", tokenID))
	return nil
}

// ValidateToken validates an access token
func (s *Service) ValidateToken(tokenString string) (*jwt.Claims, error) {
	return s.jwtService.ValidateToken(tokenString)
}
-------------------------------------------------
filepath = ./internal/auth-service/auth/interfaces.go
// FILE: internal/auth-service/auth/interfaces.go
package auth

import (
	"context"
	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"github.com/gqls/agentchassis/internal/auth-service/user"
)

// ServiceInterface defines the methods that the auth service must implement
type ServiceInterface interface {
	Register(ctx context.Context, req *user.CreateUserRequest) (*TokenResponse, error)
	Login(ctx context.Context, email, password string) (*TokenResponse, error)
	RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error)
	Logout(ctx context.Context, tokenID string) error
	ValidateToken(tokenString string) (*jwt.Claims, error)
}
-------------------------------------------------
filepath = ./internal/auth-service/API2.md
# Auth Service API Endpoints Summary

This document provides a quick reference for all available API endpoints in the Auth Service.

## Base URL
- Local Development: `http://localhost:8081`
- Production: `https://api.persona-platform.com`

## Authentication
Most endpoints require a Bearer token in the Authorization header:
```
Authorization: Bearer <your-jwt-token>
```

## Endpoints by Category

### 🔐 Authentication (`/api/v1/auth`)
| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| POST | `/auth/register` | Register a new user | No |
| POST | `/auth/login` | Login with email/password | No |
| POST | `/auth/refresh` | Refresh access token | No |
| POST | `/auth/validate` | Validate access token | No |
| POST | `/auth/logout` | Logout and invalidate token | Yes |

### 👤 User Management (`/api/v1/user`)
| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/user/profile` | Get current user profile | Yes |
| PUT | `/user/profile` | Update user profile | Yes |
| POST | `/user/password` | Change password | Yes |
| DELETE | `/user/delete` | Delete account | Yes |

### 💳 Subscription (`/api/v1/subscription`)
| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/subscription` | Get current subscription | Yes |
| GET | `/subscription/usage` | Get usage statistics | Yes |
| GET | `/subscription/check-quota` | Check resource quota | Yes |

### 📁 Projects (`/api/v1/projects`)
| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/projects` | List all projects | Yes |
| POST | `/projects` | Create new project | Yes |
| GET | `/projects/{id}` | Get project details | Yes |
| PUT | `/projects/{id}` | Update project | Yes |
| DELETE | `/projects/{id}` | Delete project | Yes |

### 🛡️ Admin - Users (`/api/v1/admin`)
| Method | Endpoint | Description | Auth Required | Role |
|--------|----------|-------------|---------------|------|
| GET | `/admin/users` | List all users | Yes | Admin |
| GET | `/admin/users/{user_id}` | Get user details | Yes | Admin |
| PUT | `/admin/users/{user_id}` | Update user | Yes | Admin |
| DELETE | `/admin/users/{user_id}` | Delete user | Yes | Admin |
| GET | `/admin/users/{user_id}/activity` | Get user activity | Yes | Admin |
| POST | `/admin/users/{user_id}/permissions` | Grant permission | Yes | Admin |
| DELETE | `/admin/users/{user_id}/permissions/{permission_name}` | Revoke permission | Yes | Admin |

### 🛡️ Admin - Subscriptions (`/api/v1/admin`)
| Method | Endpoint | Description | Auth Required | Role |
|--------|----------|-------------|---------------|------|
| GET | `/admin/subscriptions` | List all subscriptions | Yes | Admin |
| POST | `/admin/subscriptions` | Create subscription | Yes | Admin |
| PUT | `/admin/subscriptions/{user_id}` | Update subscription | Yes | Admin |

### 🔧 System
| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/health` | Health check | No |
| GET | `/ws` | WebSocket connection | Yes |

## Common Response Formats

### Success Response
```json
{
  "data": { ... },
  "message": "Operation successful"
}
```

### Error Response
```json
{
  "error": "ERROR_CODE",
  "message": "Human readable error message",
  "details": { ... }
}
```

### Pagination Response
```json
{
  "data": [ ... ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 100,
    "total_pages": 5
  }
}
```

## Status Codes
- `200 OK` - Request successful
- `201 Created` - Resource created successfully
- `400 Bad Request` - Invalid request data
- `401 Unauthorized` - Authentication required or invalid token
- `403 Forbidden` - Access denied (insufficient permissions)
- `404 Not Found` - Resource not found
- `409 Conflict` - Resource already exists
- `500 Internal Server Error` - Server error

## Rate Limiting
API requests are rate-limited based on subscription tier:
- Free: 60 requests/minute
- Basic: 300 requests/minute
- Premium: 1000 requests/minute
- Enterprise: Unlimited

Rate limit headers are included in responses:
- `X-RateLimit-Limit`: Maximum requests allowed
- `X-RateLimit-Remaining`: Requests remaining
- `X-RateLimit-Reset`: Timestamp when limit resets-------------------------------------------------
filepath = ./internal/auth-service/subscription/handlers_swagger.go
package subscription

// NOTE: This file contains swagger annotations for the subscription handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective files.

// HandleGetSubscription godoc
// @Summary      Get current subscription
// @Description  Returns the current user's subscription details including tier, status, and expiry dates
// @Tags         Subscription
// @Accept       json
// @Produce      json
// @Success      200 {object} subscription.Subscription "Subscription retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "Subscription not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /subscription [get]
// @Security     Bearer
// @ID           getSubscription

// HandleGetUsageStats godoc
// @Summary      Get usage statistics
// @Description  Returns usage statistics for the current billing period including personas, projects, and content counts
// @Tags         Subscription
// @Accept       json
// @Produce      json
// @Success      200 {object} subscription.UsageStats "Usage statistics retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Failed to get usage stats"
// @Router       /subscription/usage [get]
// @Security     Bearer
// @ID           getUsageStats

// HandleCheckQuota godoc
// @Summary      Check resource quota
// @Description  Checks if the user has available quota for a specific resource type
// @Tags         Subscription
// @Accept       json
// @Produce      json
// @Param        resource query string true "Resource type to check" Enums(personas,projects,content)
// @Success      200 {object} subscription.QuotaCheckResponse "Quota check result"
// @Failure      400 {object} map[string]interface{} "Resource parameter required"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /subscription/check-quota [get]
// @Security     Bearer
// @ID           checkQuota

// Admin endpoints

// HandleCreateSubscription godoc
// @Summary      Create subscription
// @Description  Creates a new subscription for a user (admin only)
// @Tags         Admin - Subscription
// @Accept       json
// @Produce      json
// @Param        request body subscription.CreateSubscriptionRequest true "Subscription creation details"
// @Success      201 {object} subscription.Subscription "Subscription created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      409 {object} map[string]interface{} "User already has a subscription"
// @Failure      500 {object} map[string]interface{} "Failed to create subscription"
// @Router       /admin/subscriptions [post]
// @Security     Bearer
// @ID           adminCreateSubscription

// HandleUpdateSubscription godoc
// @Summary      Update subscription
// @Description  Updates an existing subscription tier or payment method (admin only)
// @Tags         Admin - Subscription
// @Accept       json
// @Produce      json
// @Param        user_id path string true "User ID"
// @Param        request body subscription.UpdateSubscriptionRequest true "Subscription update details"
// @Success      200 {object} subscription.Subscription "Subscription updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      404 {object} map[string]interface{} "Subscription not found"
// @Failure      500 {object} map[string]interface{} "Failed to update subscription"
// @Router       /admin/subscriptions/{user_id} [put]
// @Security     Bearer
// @ID           adminUpdateSubscription

// HandleListSubscriptions godoc
// @Summary      List subscriptions
// @Description  Lists all subscriptions with pagination and filtering options (admin only)
// @Tags         Admin - Subscription
// @Accept       json
// @Produce      json
// @Param        page query int false "Page number" default(1) minimum(1)
// @Param        limit query int false "Items per page" default(50) minimum(1) maximum(200)
// @Param        status query string false "Filter by status" Enums(active,trialing,past_due,canceled,expired)
// @Param        tier query string false "Filter by tier" Enums(free,basic,premium,enterprise)
// @Success      200 {object} subscription.SubscriptionListResponse "List of subscriptions retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to retrieve subscriptions"
// @Router       /admin/subscriptions [get]
// @Security     Bearer
// @ID           adminListSubscriptions
-------------------------------------------------
filepath = ./internal/auth-service/subscription/handlers.go
// FILE: internal/auth-service/subscription/handlers.go
package subscription

import (
	"go.uber.org/zap"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

// Handlers wraps the subscription service for HTTP handling
type Handlers struct {
	service *Service
}

// NewHandlers creates new subscription handlers
func NewHandlers(service *Service) *Handlers {
	return &Handlers{service: service}
}

// QuotaCheckResponse for quota verification results
type QuotaCheckResponse struct {
	HasQuota     bool   `json:"has_quota" example:"true"`
	Resource     string `json:"resource" example:"personas"`
	CurrentUsage int    `json:"current_usage,omitempty" example:"12"`
	MaxAllowed   int    `json:"max_allowed,omitempty" example:"50"`
	Remaining    int    `json:"remaining,omitempty" example:"38"`
}

// HandleGetSubscription returns the current user's subscription
func (h *Handlers) HandleGetSubscription(c *gin.Context) {
	userID := c.GetString("user_id")

	subscription, err := h.service.GetSubscription(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Subscription not found"})
		return
	}

	c.JSON(http.StatusOK, subscription)
}

// HandleGetUsageStats returns usage statistics
func (h *Handlers) HandleGetUsageStats(c *gin.Context) {
	userID := c.GetString("user_id")

	stats, err := h.service.GetUsageStats(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get usage stats"})
		return
	}

	c.JSON(http.StatusOK, stats)
}

// HandleCheckQuota checks if user has quota for a resource
func (h *Handlers) HandleCheckQuota(c *gin.Context) {
	userID := c.GetString("user_id")
	resource := c.Query("resource")

	if resource == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Resource parameter required"})
		return
	}

	hasQuota, err := h.service.CheckQuota(c.Request.Context(), userID, resource)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	response := QuotaCheckResponse{
		HasQuota: hasQuota,
		Resource: resource,
	}

	c.JSON(http.StatusOK, response)
}

// AdminHandlers for admin operations
type AdminHandlers struct {
	service *Service
	logger  *zap.Logger
}

// NewAdminHandlers creates admin handlers
func NewAdminHandlers(service *Service, logger *zap.Logger) *AdminHandlers {
	return &AdminHandlers{service: service, logger: logger}
}

// SubscriptionListResponse for paginated subscription lists
type SubscriptionListResponse struct {
	Subscriptions []Subscription `json:"subscriptions"`
	TotalCount    int            `json:"total_count" example:"156"`
	Page          int            `json:"page" example:"1"`
	Limit         int            `json:"limit" example:"50"`
	TotalPages    int            `json:"total_pages,omitempty" example:"4"`
}

// HandleCreateSubscription creates a subscription (admin only)
func (h *AdminHandlers) HandleCreateSubscription(c *gin.Context) {
	var req CreateSubscriptionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	subscription, err := h.service.CreateSubscription(c.Request.Context(), &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create subscription"})
		return
	}

	c.JSON(http.StatusCreated, subscription)
}

// HandleUpdateSubscription updates a subscription (admin only)
func (h *AdminHandlers) HandleUpdateSubscription(c *gin.Context) {
	userID := c.Param("user_id")

	var req UpdateSubscriptionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	subscription, err := h.service.UpdateSubscription(c.Request.Context(), userID, &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update subscription"})
		return
	}

	c.JSON(http.StatusOK, subscription)
}

// HandleListSubscriptions lists all subscriptions with filtering (admin only)
func (h *AdminHandlers) HandleListSubscriptions(c *gin.Context) {
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	if limit > 200 {
		limit = 200
	}
	if page < 1 {
		page = 1
	}

	params := ListSubscriptionsParams{
		Limit:  limit,
		Offset: (page - 1) * limit,
		Status: c.Query("status"),
		Tier:   c.Query("tier"),
	}

	subscriptions, total, err := h.service.repo.ListAll(c.Request.Context(), params)
	if err != nil {
		h.logger.Error("Failed to list subscriptions", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve subscriptions"})
		return
	}

	totalPages := (total + limit - 1) / limit

	response := SubscriptionListResponse{
		Subscriptions: subscriptions,
		TotalCount:    total,
		Page:          page,
		Limit:         limit,
		TotalPages:    totalPages,
	}

	c.JSON(http.StatusOK, response)
}
-------------------------------------------------
filepath = ./internal/auth-service/subscription/repository.go
// FILE: internal/auth-service/subscription/repository.go
package subscription

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"go.uber.org/zap"
)

// Repository handles subscription data access
type Repository struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewRepository creates a new subscription repository
func NewRepository(db *sql.DB, logger *zap.Logger) *Repository {
	return &Repository{
		db:     db,
		logger: logger,
	}
}

// GetByUserID retrieves a subscription by user ID
func (r *Repository) GetByUserID(ctx context.Context, userID string) (*Subscription, error) {
	var s Subscription
	query := `
		SELECT id, user_id, tier, status, start_date, end_date, trial_ends_at, 
		       cancelled_at, payment_method, stripe_customer_id, stripe_subscription_id,
		       created_at, updated_at
		FROM subscriptions
		WHERE user_id = ?
	`

	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&s.ID, &s.UserID, &s.Tier, &s.Status, &s.StartDate, &s.EndDate,
		&s.TrialEndsAt, &s.CancelledAt, &s.PaymentMethod,
		&s.StripeCustomerID, &s.StripeSubscriptionID,
		&s.CreatedAt, &s.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("subscription not found")
		}
		return nil, err
	}

	return &s, nil
}

// Create creates a new subscription
func (r *Repository) Create(ctx context.Context, s *Subscription) error {
	query := `
		INSERT INTO subscriptions (id, user_id, tier, status, start_date, payment_method,
		                          trial_ends_at, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
	`

	_, err := r.db.ExecContext(ctx, query,
		s.ID, s.UserID, s.Tier, s.Status, s.StartDate,
		s.PaymentMethod, s.TrialEndsAt, s.CreatedAt, s.UpdatedAt,
	)

	return err
}

// Update updates an existing subscription
func (r *Repository) Update(ctx context.Context, s *Subscription) error {
	query := `
		UPDATE subscriptions 
		SET tier = ?, status = ?, payment_method = ?, updated_at = ?
		WHERE id = ?
	`

	_, err := r.db.ExecContext(ctx, query,
		s.Tier, s.Status, s.PaymentMethod, s.UpdatedAt, s.ID,
	)

	return err
}

// Cancel cancels a subscription
func (r *Repository) Cancel(ctx context.Context, userID string, cancelledAt time.Time) error {
	query := `
		UPDATE subscriptions 
		SET status = ?, cancelled_at = ?, updated_at = ?
		WHERE user_id = ?
	`

	_, err := r.db.ExecContext(ctx, query,
		StatusCanceled, cancelledAt, time.Now(), userID,
	)

	return err
}

// GetTier retrieves tier information
func (r *Repository) GetTier(ctx context.Context, tierName string) (*SubscriptionTier, error) {
	var t SubscriptionTier
	var featuresJSON string

	query := `
		SELECT id, name, display_name, description, price_monthly, price_yearly,
		       max_personas, max_projects, max_content_items, features, is_active
		FROM subscription_tiers
		WHERE name = ? AND is_active = true
	`

	err := r.db.QueryRowContext(ctx, query, tierName).Scan(
		&t.ID, &t.Name, &t.DisplayName, &t.Description,
		&t.PriceMonthly, &t.PriceYearly,
		&t.MaxPersonas, &t.MaxProjects, &t.MaxContentItems,
		&featuresJSON, &t.IsActive,
	)

	if err != nil {
		return nil, err
	}

	json.Unmarshal([]byte(featuresJSON), &t.Features)

	return &t, nil
}

// GetUsageStats retrieves usage statistics
func (r *Repository) GetUsageStats(ctx context.Context, userID string) (*UsageStats, error) {
	var stats UsageStats
	stats.UserID = userID

	// This would need to query across multiple tables/schemas
	// For now, returning mock data
	stats.PersonasCount = 0
	stats.ProjectsCount = 0
	stats.ContentCount = 0
	stats.LastUpdated = time.Now()

	return &stats, nil
}

// ListSubscriptionsParams contains parameters for listing subscriptions
type ListSubscriptionsParams struct {
	Limit  int
	Offset int
	Status string
	Tier   string
}

// ListAll retrieves a paginated list of all subscriptions
func (r *Repository) ListAll(ctx context.Context, params ListSubscriptionsParams) ([]Subscription, int, error) {
	query := `SELECT id, user_id, tier, status, start_date, end_date, created_at FROM subscriptions WHERE 1=1`
	countQuery := `SELECT COUNT(*) FROM subscriptions WHERE 1=1`

	args := []interface{}{}
	count := 1

	if params.Status != "" {
		query += fmt.Sprintf(" AND status = $%d", count)
		countQuery += fmt.Sprintf(" AND status = $%d", count)
		args = append(args, params.Status)
		count++
	}
	if params.Tier != "" {
		query += fmt.Sprintf(" AND tier = $%d", count)
		countQuery += fmt.Sprintf(" AND tier = $%d", count)
		args = append(args, params.Tier)
		count++
	}

	query += fmt.Sprintf(" ORDER BY created_at DESC LIMIT $%d OFFSET $%d", count, count+1)
	args = append(args, params.Limit, params.Offset)

	// Get total count
	var total int
	if err := r.db.QueryRowContext(ctx, countQuery, args[:count-1]...).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("failed to get subscription count: %w", err)
	}

	// Get subscriptions
	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list subscriptions: %w", err)
	}
	defer rows.Close()

	var subscriptions []Subscription
	for rows.Next() {
		var s Subscription
		if err := rows.Scan(&s.ID, &s.UserID, &s.Tier, &s.Status, &s.StartDate, &s.EndDate, &s.CreatedAt); err != nil {
			r.logger.Error("Failed to scan subscription row", zap.Error(err))
			continue
		}
		subscriptions = append(subscriptions, s)
	}

	return subscriptions, total, nil
}
-------------------------------------------------
filepath = ./internal/auth-service/subscription/models.go
package subscription

import (
	"time"
)

// Subscription represents a user's subscription
type Subscription struct {
	ID                   string     `json:"id" db:"id" example:"sub_123e4567-e89b-12d3-a456-426614174000"`
	UserID               string     `json:"user_id" db:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	Tier                 string     `json:"tier" db:"tier" example:"premium"`
	Status               string     `json:"status" db:"status" example:"active"`
	StartDate            time.Time  `json:"start_date" db:"start_date" example:"2024-01-15T10:30:00Z"`
	EndDate              *time.Time `json:"end_date,omitempty" db:"end_date" example:"2024-12-31T23:59:59Z"`
	TrialEndsAt          *time.Time `json:"trial_ends_at,omitempty" db:"trial_ends_at" example:"2024-02-14T23:59:59Z"`
	CancelledAt          *time.Time `json:"cancelled_at,omitempty" db:"cancelled_at" example:"2024-06-30T15:00:00Z"`
	PaymentMethod        string     `json:"payment_method" db:"payment_method" example:"pm_1234567890"`
	StripeCustomerID     string     `json:"-" db:"stripe_customer_id"`
	StripeSubscriptionID string     `json:"-" db:"stripe_subscription_id"`
	CreatedAt            time.Time  `json:"created_at" db:"created_at" example:"2024-01-15T10:30:00Z"`
	UpdatedAt            time.Time  `json:"updated_at" db:"updated_at" example:"2024-07-17T14:45:00Z"`
}

// SubscriptionTier defines tier details
type SubscriptionTier struct {
	ID              string   `json:"id" db:"id" example:"tier_premium"`
	Name            string   `json:"name" db:"name" example:"premium"`
	DisplayName     string   `json:"display_name" db:"display_name" example:"Premium Plan"`
	Description     string   `json:"description" db:"description" example:"Perfect for growing teams and businesses"`
	PriceMonthly    float64  `json:"price_monthly" db:"price_monthly" example:"49.99"`
	PriceYearly     float64  `json:"price_yearly" db:"price_yearly" example:"479.99"`
	MaxPersonas     int      `json:"max_personas" db:"max_personas" example:"50"`
	MaxProjects     int      `json:"max_projects" db:"max_projects" example:"20"`
	MaxContentItems int      `json:"max_content_items" db:"max_content_items" example:"10000"`
	Features        []string `json:"features" db:"features" example:"Advanced Analytics,API Access,Priority Support,Custom Integrations"`
	IsActive        bool     `json:"is_active" db:"is_active" example:"true"`
}

// UsageStats tracks user's resource usage
type UsageStats struct {
	UserID        string    `json:"user_id" db:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	PersonasCount int       `json:"personas_count" db:"personas_count" example:"12"`
	ProjectsCount int       `json:"projects_count" db:"projects_count" example:"5"`
	ContentCount  int       `json:"content_count" db:"content_count" example:"1234"`
	LastUpdated   time.Time `json:"last_updated" db:"last_updated" example:"2024-07-17T14:30:00Z"`
}

// SubscriptionStatus constants
const (
	StatusActive   = "active"
	StatusTrialing = "trialing"
	StatusPastDue  = "past_due"
	StatusCanceled = "canceled"
	StatusExpired  = "expired"
)

// Tier constants
const (
	TierFree       = "free"
	TierBasic      = "basic"
	TierPremium    = "premium"
	TierEnterprise = "enterprise"
)

// CreateSubscriptionRequest for new subscriptions
type CreateSubscriptionRequest struct {
	UserID          string `json:"user_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
	Tier            string `json:"tier" binding:"required" example:"premium"`
	PaymentMethodID string `json:"payment_method_id" example:"pm_1234567890"`
	TrialDays       int    `json:"trial_days" example:"14"`
}

// UpdateSubscriptionRequest for subscription changes
type UpdateSubscriptionRequest struct {
	Tier            *string `json:"tier" example:"enterprise"`
	PaymentMethodID *string `json:"payment_method_id" example:"pm_0987654321"`
}

// CheckoutSession for payment processing
type CheckoutSession struct {
	ID         string `json:"id" example:"cs_test_a1b2c3d4e5f6"`
	URL        string `json:"url" example:"https://checkout.stripe.com/pay/cs_test_a1b2c3d4e5f6"`
	SuccessURL string `json:"success_url" example:"https://app.example.com/subscription/success"`
	CancelURL  string `json:"cancel_url" example:"https://app.example.com/subscription/cancelled"`
	ExpiresAt  int64  `json:"expires_at" example:"1689696000"`
}
-------------------------------------------------
filepath = ./internal/auth-service/subscription/service.go
// FILE: internal/auth-service/subscription/service.go
package subscription

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"
)

// Service handles subscription business logic
type Service struct {
	repo   *Repository
	logger *zap.Logger
}

// NewService creates a new subscription service
func NewService(repo *Repository, logger *zap.Logger) *Service {
	return &Service{
		repo:   repo,
		logger: logger,
	}
}

// GetSubscription retrieves a user's subscription
func (s *Service) GetSubscription(ctx context.Context, userID string) (*Subscription, error) {
	return s.repo.GetByUserID(ctx, userID)
}

// CreateSubscription creates a new subscription
func (s *Service) CreateSubscription(ctx context.Context, req *CreateSubscriptionRequest) (*Subscription, error) {
	subscription := &Subscription{
		ID:            uuid.New().String(),
		UserID:        req.UserID,
		Tier:          req.Tier,
		Status:        StatusActive,
		StartDate:     time.Now(),
		PaymentMethod: req.PaymentMethodID,
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	if req.TrialDays > 0 {
		trialEnd := time.Now().AddDate(0, 0, req.TrialDays)
		subscription.TrialEndsAt = &trialEnd
		subscription.Status = StatusTrialing
	}

	if err := s.repo.Create(ctx, subscription); err != nil {
		return nil, fmt.Errorf("failed to create subscription: %w", err)
	}

	return subscription, nil
}

// UpdateSubscription updates an existing subscription
func (s *Service) UpdateSubscription(ctx context.Context, userID string, req *UpdateSubscriptionRequest) (*Subscription, error) {
	subscription, err := s.repo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	if req.Tier != nil {
		subscription.Tier = *req.Tier
	}

	if req.PaymentMethodID != nil {
		subscription.PaymentMethod = *req.PaymentMethodID
	}

	subscription.UpdatedAt = time.Now()

	if err := s.repo.Update(ctx, subscription); err != nil {
		return nil, fmt.Errorf("failed to update subscription: %w", err)
	}

	return subscription, nil
}

// CancelSubscription cancels a subscription
func (s *Service) CancelSubscription(ctx context.Context, userID string) error {
	now := time.Now()
	return s.repo.Cancel(ctx, userID, now)
}

// GetUsageStats retrieves usage statistics for a user
func (s *Service) GetUsageStats(ctx context.Context, userID string) (*UsageStats, error) {
	return s.repo.GetUsageStats(ctx, userID)
}

// CheckQuota checks if a user has quota for a specific resource
func (s *Service) CheckQuota(ctx context.Context, userID string, resource string) (bool, error) {
	subscription, err := s.GetSubscription(ctx, userID)
	if err != nil {
		return false, err
	}

	tier, err := s.repo.GetTier(ctx, subscription.Tier)
	if err != nil {
		return false, err
	}

	usage, err := s.GetUsageStats(ctx, userID)
	if err != nil {
		return false, err
	}

	switch resource {
	case "personas":
		return tier.MaxPersonas == -1 || usage.PersonasCount < tier.MaxPersonas, nil
	case "projects":
		return tier.MaxProjects == -1 || usage.ProjectsCount < tier.MaxProjects, nil
	case "content":
		return tier.MaxContentItems == -1 || usage.ContentCount < tier.MaxContentItems, nil
	default:
		return false, fmt.Errorf("unknown resource type: %s", resource)
	}
}
-------------------------------------------------
filepath = ./internal/auth-service/API3.md
# Auth Service Complete API Documentation

## Overview

The Auth Service provides comprehensive authentication, authorization, user management, and subscription handling for the AI Persona Platform. This document covers all available endpoints including standard user operations and administrative functions.

## API Structure

### Base URLs
- **Local Development**: `http://localhost:8081/api/v1`
- **Staging**: `https://staging-api.persona-platform.com/api/v1`
- **Production**: `https://api.persona-platform.com/api/v1`

### Authentication
Most endpoints require Bearer token authentication:
```
Authorization: Bearer <jwt-token>
```

### Response Format
All responses follow a consistent format:

**Success Response**:
```json
{
  "data": { ... },
  "message": "Operation successful"
}
```

**Error Response**:
```json
{
  "error": "ERROR_CODE",
  "message": "Human-readable error message",
  "details": { ... }
}
```

## Endpoint Categories

### 1. Authentication Endpoints (`/auth`)

Core authentication functionality for user registration, login, and token management.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| POST | `/auth/register` | Register new user | No | - |
| POST | `/auth/login` | User login | No | - |
| POST | `/auth/refresh` | Refresh access token | No | - |
| POST | `/auth/validate` | Validate access token | No | - |
| POST | `/auth/logout` | Logout user | Yes | Any |

### 2. User Management Endpoints (`/user`)

User profile management and account operations.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| GET | `/user/profile` | Get current user profile | Yes | Any |
| PUT | `/user/profile` | Update user profile | Yes | Any |
| POST | `/user/password` | Change password | Yes | Any |
| DELETE | `/user/delete` | Delete account | Yes | Any |

### 3. Subscription Endpoints (`/subscription`)

Subscription and usage management for users.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| GET | `/subscription` | Get current subscription | Yes | Any |
| GET | `/subscription/usage` | Get usage statistics | Yes | Any |
| GET | `/subscription/check-quota` | Check resource quota | Yes | Any |

### 4. Project Management Endpoints (`/projects`)

Project creation and management.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| GET | `/projects` | List all projects | Yes | Any |
| POST | `/projects` | Create new project | Yes | Any |
| GET | `/projects/{id}` | Get project details | Yes | Any |
| PUT | `/projects/{id}` | Update project | Yes | Any |
| DELETE | `/projects/{id}` | Delete project | Yes | Any |

### 5. Admin - User Management (`/admin/users`)

Administrative endpoints for managing users.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| GET | `/admin/users` | List all users with filters | Yes | Admin |
| GET | `/admin/users/{user_id}` | Get user details with stats | Yes | Admin |
| PUT | `/admin/users/{user_id}` | Update user (role, tier, status) | Yes | Admin |
| DELETE | `/admin/users/{user_id}` | Delete user account | Yes | Admin |
| GET | `/admin/users/{user_id}/activity` | Get user activity logs | Yes | Admin |
| POST | `/admin/users/{user_id}/permissions` | Grant permission | Yes | Admin |
| DELETE | `/admin/users/{user_id}/permissions/{name}` | Revoke permission | Yes | Admin |

### 6. Admin - Bulk Operations (`/admin/users`)

Bulk user management operations.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| POST | `/admin/users/bulk` | Bulk user operations | Yes | Admin |
| POST | `/admin/users/export` | Export user data (CSV/JSON) | Yes | Admin |
| POST | `/admin/users/import` | Import users from CSV | Yes | Admin |

### 7. Admin - Session Management (`/admin/users`)

Session and security management.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| GET | `/admin/users/{user_id}/sessions` | Get user sessions | Yes | Admin |
| DELETE | `/admin/users/{user_id}/sessions` | Terminate all sessions | Yes | Admin |
| POST | `/admin/users/{user_id}/password` | Reset user password | Yes | Admin |
| GET | `/admin/users/{user_id}/audit` | Get audit log | Yes | Admin |

### 8. Admin - Subscription Management (`/admin/subscriptions`)

Administrative subscription operations.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| GET | `/admin/subscriptions` | List all subscriptions | Yes | Admin |
| POST | `/admin/subscriptions` | Create subscription | Yes | Admin |
| PUT | `/admin/subscriptions/{user_id}` | Update subscription | Yes | Admin |

### 9. System Endpoints

System health and real-time communication.

| Method | Endpoint | Description | Auth | Role |
|--------|----------|-------------|------|------|
| GET | `/health` | Health check | No | - |
| GET | `/ws` | WebSocket connection | Yes | Any |

## Detailed Endpoint Documentation

### Authentication Flow

1. **Registration**: POST `/auth/register`
    - Creates new user account
    - Returns JWT tokens
    - Supports multi-tenant via `client_id`

2. **Login**: POST `/auth/login`
    - Authenticates with email/password
    - Returns access and refresh tokens
    - Tokens expire after configured duration

3. **Token Refresh**: POST `/auth/refresh`
    - Uses refresh token to get new access token
    - Maintains user session continuity

### User Roles and Permissions

**Roles**:
- `user`: Standard user access
- `moderator`: Extended permissions
- `admin`: Full administrative access

**Permissions** (examples):
- `read:users`: View user information
- `write:users`: Modify user information
- `manage:subscriptions`: Manage subscriptions
- `system:admin`: System administration

### Subscription Tiers

- **Free**: Basic access, limited resources
- **Basic**: Enhanced limits, standard support
- **Premium**: High limits, priority support
- **Enterprise**: Unlimited resources, dedicated support

### Rate Limiting

API requests are rate-limited based on subscription tier:

| Tier | Requests/Minute | Requests/Hour | Requests/Day |
|------|----------------|---------------|--------------|
| Free | 60 | 1,000 | 10,000 |
| Basic | 300 | 5,000 | 50,000 |
| Premium | 1,000 | 20,000 | 200,000 |
| Enterprise | Unlimited | Unlimited | Unlimited |

### Error Codes

Common error codes returned by the API:

| Code | Description |
|------|-------------|
| `INVALID_CREDENTIALS` | Invalid login credentials |
| `TOKEN_EXPIRED` | JWT token has expired |
| `INSUFFICIENT_PERMISSIONS` | User lacks required permissions |
| `RESOURCE_NOT_FOUND` | Requested resource doesn't exist |
| `QUOTA_EXCEEDED` | Usage quota exceeded |
| `VALIDATION_ERROR` | Request validation failed |
| `INTERNAL_ERROR` | Internal server error |

### Webhook Events

The system can send webhooks for the following events:

- `user.created`: New user registration
- `user.updated`: User profile updated
- `user.deleted`: User account deleted
- `subscription.created`: New subscription
- `subscription.updated`: Subscription changed
- `subscription.cancelled`: Subscription cancelled
- `security.suspicious_activity`: Suspicious activity detected

## Security Considerations

1. **Token Security**:
    - Access tokens expire in 1 hour
    - Refresh tokens expire in 30 days
    - Tokens are invalidated on logout

2. **Password Requirements**:
    - Minimum 8 characters
    - Must contain uppercase, lowercase, number
    - Checked against common passwords

3. **Session Management**:
    - Sessions tracked per device
    - Admins can terminate sessions
    - Automatic timeout after inactivity

4. **Audit Logging**:
    - All admin actions logged
    - User activities tracked
    - IP addresses recorded

## Best Practices

1. **Authentication**:
    - Store tokens securely
    - Refresh tokens before expiry
    - Implement proper logout

2. **Error Handling**:
    - Check response status codes
    - Parse error messages
    - Implement retry logic

3. **Rate Limiting**:
    - Monitor rate limit headers
    - Implement backoff strategies
    - Cache responses when possible

4. **Data Security**:
    - Use HTTPS for all requests
    - Validate input data
    - Sanitize user content

## Support

For additional support or questions:
- Documentation: https://docs.persona-platform.com
- Support: support@persona-platform.com
- Status: https://status.persona-platform.com-------------------------------------------------
filepath = ./internal/agents/reasoning/API.md
# Reasoning Agent Internal API Documentation

## Overview

The Reasoning Agent is a code-driven agent that performs logical analysis, decision making, and complex reasoning tasks. It processes requests via Kafka messages and returns structured reasoning results.

## Kafka Topics

### Consumed Topics

#### agents.reasoning.process
Main processing topic for reasoning requests.

**Message Format:**
```json
{
  "action": "analyze|decide|evaluate|reason",
  "data": {
    "context": "Background information for reasoning",
    "question": "What needs to be analyzed or decided",
    "constraints": [
      "List of constraints to consider"
    ],
    "options": [
      {
        "id": "option1",
        "description": "First option to consider"
      }
    ],
    "criteria": {
      "factors": ["cost", "time", "quality"],
      "weights": {
        "cost": 0.3,
        "time": 0.2,
        "quality": 0.5
      }
    }
  }
}
```

**Required Headers:**
- `correlation_id`: Unique request identifier
- `request_id`: Request tracking ID
- `client_id`: Client identifier
- `agent_instance_id`: Specific agent instance
- `fuel_budget`: Available fuel for this operation

### Produced Topics

#### agents.reasoning.results
Results of reasoning operations.

**Message Format:**
```json
{
  "success": true,
  "data": {
    "reasoning_type": "analysis|decision|evaluation",
    "conclusion": "Main conclusion or recommendation",
    "reasoning_steps": [
      {
        "step": 1,
        "description": "Identified key factors",
        "findings": ["Factor 1", "Factor 2"]
      },
      {
        "step": 2,
        "description": "Evaluated options",
        "analysis": {
          "option1": {
            "score": 0.85,
            "pros": ["Pro 1", "Pro 2"],
            "cons": ["Con 1"]
          }
        }
      }
    ],
    "confidence": 0.85,
    "assumptions": [
      "List of assumptions made"
    ],
    "recommendations": [
      {
        "priority": "high",
        "action": "Recommended action",
        "rationale": "Why this is recommended"
      }
    ]
  }
}
```

#### system.agent.metrics
Performance metrics and usage data.

**Message Format:**
```json
{
  "agent_type": "reasoning",
  "agent_instance_id": "instance-uuid",
  "metrics": {
    "processing_time_ms": 1500,
    "fuel_consumed": 25,
    "reasoning_depth": 3,
    "options_evaluated": 5
  },
  "timestamp": "2024-01-01T00:00:00Z"
}
```

## Agent Configuration

The reasoning agent accepts the following configuration parameters:

```json
{
  "model": "claude-3-opus",
  "temperature": 0.2,
  "max_reasoning_steps": 10,
  "reasoning_style": "analytical|creative|balanced",
  "output_format": "structured|narrative",
  "enable_assumptions": true,
  "confidence_threshold": 0.7,
  "parallel_evaluation": true,
  "memory_enabled": true,
  "memory_context_limit": 5
}
```

## Supported Actions

### analyze
Performs deep analysis of a situation or problem.

**Input:**
```json
{
  "action": "analyze",
  "data": {
    "subject": "Market entry strategy for Product X",
    "context": "Current market conditions and company capabilities",
    "aspects": ["market_size", "competition", "regulatory", "timing"]
  }
}
```

### decide
Makes decisions based on given criteria and options.

**Input:**
```json
{
  "action": "decide",
  "data": {
    "decision": "Which cloud provider to choose",
    "options": ["AWS", "GCP", "Azure"],
    "criteria": {
      "factors": ["cost", "features", "support"],
      "constraints": ["Must support Kubernetes", "Budget < $10k/month"]
    }
  }
}
```

### evaluate
Evaluates proposals, plans, or strategies.

**Input:**
```json
{
  "action": "evaluate",
  "data": {
    "proposal": "Details of the proposal",
    "evaluation_criteria": ["feasibility", "roi", "risk"],
    "benchmark": "Optional benchmark for comparison"
  }
}
```

### reason
General reasoning about complex scenarios.

**Input:**
```json
{
  "action": "reason",
  "data": {
    "scenario": "Description of the scenario",
    "question": "What needs to be determined",
    "approach": "deductive|inductive|abductive"
  }
}
```

## Memory Integration

When memory is enabled, the agent:
- Retrieves relevant past reasoning for similar problems
- Stores successful reasoning patterns
- Learns from previous decisions and their outcomes

**Memory Entry Format:**
```json
{
  "type": "reasoning_pattern",
  "content": {
    "problem_type": "decision|analysis|evaluation",
    "pattern": "Description of successful reasoning approach",
    "effectiveness": 0.9,
    "context_tags": ["finance", "strategy", "risk"]
  }
}
```

## Error Handling

The agent returns errors in the following format:

```json
{
  "success": false,
  "error": {
    "code": "REASONING_001",
    "message": "Unable to complete reasoning",
    "details": {
      "reason": "Insufficient context provided",
      "missing_elements": ["criteria", "constraints"]
    }
  }
}
```

### Error Codes
- `REASONING_001`: Invalid input format
- `REASONING_002`: Insufficient context
- `REASONING_003`: Reasoning timeout
- `REASONING_004`: Conflicting constraints
- `REASONING_005`: Low confidence result

## Performance Characteristics

- Average processing time: 1-3 seconds
- Fuel consumption: 10-50 units depending on complexity
- Memory usage: ~100MB baseline + variable based on context
- Concurrent request handling: Yes
- Max context size: 100KB

## Integration Notes

### For Orchestrators
- Provide comprehensive context for better reasoning
- Include all relevant constraints upfront
- Specify desired output format
- Handle low-confidence results appropriately

### For Other Agents
- Can chain reasoning results with other agents
- Use structured output for easier parsing
- Consider confidence scores in workflows

## Environment Variables

```bash
# Agent Configuration
AGENT_TYPE=reasoning
KAFKA_CONSUMER_GROUP=reasoning-agent-group
KAFKA_TOPICS=agents.reasoning.process

# AI Service
AI_PROVIDER=anthropic
ANTHROPIC_API_KEY=<api-key>

# Performance
MAX_CONCURRENT_REQUESTS=10
REQUEST_TIMEOUT=30s
MEMORY_LIMIT=512MB

# Monitoring
METRICS_ENABLED=true
METRICS_INTERVAL=60s
```-------------------------------------------------
filepath = ./internal/agents/reasoning/agent.go
// FILE: internal/agents/reasoning/agent.go
package reasoning

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/gqls/agentchassis/platform/aiservice"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/kafka"
	"go.uber.org/zap"
)

const (
	requestTopic  = "system.agent.reasoning.process"
	responseTopic = "system.responses.reasoning"
	consumerGroup = "reasoning-agent-group"
)

// RequestPayload defines the data this agent expects
type RequestPayload struct {
	Action string `json:"action"`
	Data   struct {
		ContentToReview string                 `json:"content_to_review"`
		ReviewCriteria  []string               `json:"review_criteria"`
		BriefContext    map[string]interface{} `json:"brief_context"`
	} `json:"data"`
}

// ResponsePayload defines the response format
type ResponsePayload struct {
	ReviewPassed bool     `json:"review_passed"`
	Score        float64  `json:"score"`
	Suggestions  []string `json:"suggestions"`
	Reasoning    string   `json:"reasoning"`
}

// Agent is the reasoning specialist
type Agent struct {
	ctx      context.Context
	logger   *zap.Logger
	consumer *kafka.Consumer
	producer kafka.Producer
	aiClient aiservice.AIService
}

// NewAgent creates a new reasoning agent
func NewAgent(ctx context.Context, cfg *config.ServiceConfig, logger *zap.Logger) (*Agent, error) {
	consumer, err := kafka.NewConsumer(cfg.Infrastructure.KafkaBrokers, requestTopic, consumerGroup, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create consumer: %w", err)
	}

	producer, err := kafka.NewProducer(cfg.Infrastructure.KafkaBrokers, logger)
	if err != nil {
		consumer.Close()
		return nil, fmt.Errorf("failed to create producer: %w", err)
	}

	// Initialize AI client from custom config
	aiConfig := cfg.Custom["ai_service"].(map[string]interface{})
	aiClient, err := aiservice.NewAnthropicClient(ctx, aiConfig)
	if err != nil {
		consumer.Close()
		producer.Close()
		return nil, fmt.Errorf("failed to create AI client: %w", err)
	}

	return &Agent{
		ctx:      ctx,
		logger:   logger,
		consumer: consumer,
		producer: producer,
		aiClient: aiClient,
	}, nil
}

// Run starts the agent's main loop
func (a *Agent) Run() error {
	a.logger.Info("Reasoning Agent is running and waiting for tasks...")

	for {
		select {
		case <-a.ctx.Done():
			a.consumer.Close()
			a.producer.Close()
			return nil
		default:
			msg, err := a.consumer.FetchMessage(a.ctx)
			if err != nil {
				if err == context.Canceled {
					continue
				}
				a.logger.Error("Failed to fetch message", zap.Error(err))
				continue
			}
			go a.handleMessage(msg)
		}
	}
}

// handleMessage processes a single reasoning request
func (a *Agent) handleMessage(msg kafka.Message) {
	headers := kafka.HeadersToMap(msg.Headers)
	l := a.logger.With(zap.String("correlation_id", headers["correlation_id"]))

	var req RequestPayload
	if err := json.Unmarshal(msg.Value, &req); err != nil {
		l.Error("Failed to unmarshal request", zap.Error(err))
		a.consumer.CommitMessages(context.Background(), msg)
		return
	}

	// Build the reasoning prompt
	prompt := a.buildReasoningPrompt(req)

	// Call the AI service
	result, err := a.aiClient.GenerateText(a.ctx, prompt, nil)
	if err != nil {
		l.Error("AI reasoning call failed", zap.Error(err))
		a.sendErrorResponse(headers, "Failed to perform reasoning")
		a.consumer.CommitMessages(context.Background(), msg)
		return
	}

	// Parse the AI response
	var responsePayload ResponsePayload
	if err := json.Unmarshal([]byte(result), &responsePayload); err != nil {
		l.Error("Failed to parse AI response", zap.Error(err))
		// Fallback response
		responsePayload = ResponsePayload{
			ReviewPassed: false,
			Score:        0,
			Suggestions:  []string{"Could not parse AI response"},
			Reasoning:    result,
		}
	}

	// Send response
	a.sendResponse(headers, responsePayload)

	// Commit message
	a.consumer.CommitMessages(context.Background(), msg)
}

// buildReasoningPrompt creates the prompt for the LLM
func (a *Agent) buildReasoningPrompt(req RequestPayload) string {
	return fmt.Sprintf(`You are a logical reasoning engine. Review the following content based on these criteria: %v.

Context: %v

Content to review: "%s"

Provide your analysis as a JSON object with the following structure:
{
    "review_passed": boolean,
    "score": number (0-10),
    "suggestions": ["suggestion1", "suggestion2", ...],
    "reasoning": "detailed explanation of your analysis"
}

Be thorough but concise in your reasoning.`,
		req.Data.ReviewCriteria,
		req.Data.BriefContext,
		req.Data.ContentToReview,
	)
}

// sendResponse sends a successful response
func (a *Agent) sendResponse(headers map[string]string, payload ResponsePayload) {
	responseBytes, _ := json.Marshal(payload)
	responseHeaders := map[string]string{
		"correlation_id": headers["correlation_id"],
		"causation_id":   headers["request_id"],
		"request_id":     uuid.NewString(),
	}

	if err := a.producer.Produce(a.ctx, responseTopic, responseHeaders,
		[]byte(headers["correlation_id"]), responseBytes); err != nil {
		a.logger.Error("Failed to produce response", zap.Error(err))
	}
}

// sendErrorResponse sends an error response
func (a *Agent) sendErrorResponse(headers map[string]string, errorMsg string) {
	payload := map[string]interface{}{
		"success": false,
		"error":   errorMsg,
	}
	responseBytes, _ := json.Marshal(payload)
	responseHeaders := map[string]string{
		"correlation_id": headers["correlation_id"],
		"causation_id":   headers["request_id"],
		"request_id":     uuid.NewString(),
	}

	a.producer.Produce(a.ctx, responseTopic, responseHeaders,
		[]byte(headers["correlation_id"]), responseBytes)
}

// StartHealthServer starts a simple HTTP server for health checks
func (a *Agent) StartHealthServer(port string) {
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{
			"status": "healthy",
			"agent":  "reasoning-agent",
		})
	})

	go func() {
		a.logger.Info("Starting health server", zap.String("port", port))
		if err := http.ListenAndServe(":"+port, nil); err != nil {
			a.logger.Error("Health server failed", zap.Error(err))
		}
	}()
}
-------------------------------------------------
filepath = ./internal/core-manager/api/server.go
package api

import (
	"context"
	"fmt"
	"github.com/gqls/agentchassis/internal/core-manager/handlers"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/core-manager/admin"
	"github.com/gqls/agentchassis/internal/core-manager/database"
	"github.com/gqls/agentchassis/internal/core-manager/middleware"
	"github.com/gqls/agentchassis/pkg/models"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/kafka"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// Server represents the Core Manager API server
type Server struct {
	ctx           context.Context
	cfg           *config.ServiceConfig
	logger        *zap.Logger
	router        *gin.Engine
	httpServer    *http.Server
	personaRepo   models.PersonaRepository
	kafkaProducer kafka.Producer
}

// NewServer creates a new API server instance
func NewServer(ctx context.Context, cfg *config.ServiceConfig, logger *zap.Logger, templatesDB, clientsDB *pgxpool.Pool) (*Server, error) {
	// Initialize repositories
	personaRepo := database.NewPersonaRepository(templatesDB, clientsDB, logger)

	// Create Gin router
	router := gin.New()
	router.Use(gin.Recovery())

	// Initialize Kafka Producer for admin handlers
	kafkaProducer, err := kafka.NewProducer(cfg.Infrastructure.KafkaBrokers, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create kafka producer for admin handlers: %w", err)
	}

	// Initialize auth middleware config
	authConfig, err := middleware.NewAuthMiddlewareConfig(cfg, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize auth middleware: %w", err)
	}

	server := &Server{
		ctx:           ctx,
		cfg:           cfg,
		logger:        logger,
		router:        router,
		personaRepo:   personaRepo,
		kafkaProducer: kafkaProducer,
	}

	// Setup routes with configured auth middleware
	server.setupRoutes(authConfig)

	// Create HTTP server
	server.httpServer = &http.Server{
		Addr:    ":" + cfg.Server.Port,
		Handler: router,
	}

	return server, nil
}

// setupRoutes configures all API routes with auth config
func (s *Server) setupRoutes(authConfig *middleware.AuthMiddlewareConfig) {
	// Initialize handlers
	healthHandler := handlers.NewHealthHandler(s.cfg, s.logger)
	templateHandler := handlers.NewTemplateHandler(s.personaRepo, s.logger)
	instanceHandler := handlers.NewInstanceHandler(s.personaRepo, s.logger)

	// Initialize admin handlers
	personaRepoImpl := s.personaRepo.(*database.PersonaRepository)
	clientHandlers := admin.NewClientHandlers(personaRepoImpl.ClientsDB(), s.logger)
	systemHandlers := admin.NewSystemHandlers(personaRepoImpl.ClientsDB(), personaRepoImpl.TemplatesDB(), s.kafkaProducer, s.logger)
	agentAdminHandlers := admin.NewAgentHandlers(personaRepoImpl.ClientsDB(), personaRepoImpl.TemplatesDB(), s.kafkaProducer, s.logger, s.personaRepo)

	// Health check (no auth)
	s.router.GET("/health", healthHandler.HandleHealth)

	// API v1 group with authentication
	apiV1 := s.router.Group("/api/v1")
	apiV1.Use(middleware.AuthMiddleware(authConfig))
	{
		// Template Management (Admin Only)
		templates := apiV1.Group("/templates")
		templates.Use(middleware.AdminOnly())
		{
			templates.POST("", templateHandler.HandleCreateTemplate)
			templates.GET("", templateHandler.HandleListTemplates)
			templates.GET("/:id", templateHandler.HandleGetTemplate)
			templates.PUT("/:id", templateHandler.HandleUpdateTemplate)
			templates.DELETE("/:id", templateHandler.HandleDeleteTemplate)
		}

		// Persona Instance Management (Tenant-scoped)
		instances := apiV1.Group("/personas/instances")
		instances.Use(middleware.TenantMiddleware(s.logger))
		{
			instances.POST("", instanceHandler.HandleCreateInstance)
			instances.GET("", instanceHandler.HandleListInstances)
			instances.GET("/:id", instanceHandler.HandleGetInstance)
			instances.PATCH("/:id", instanceHandler.HandleUpdateInstance)
			instances.DELETE("/:id", instanceHandler.HandleDeleteInstance)
		}

		// Admin Management (Admin Only)
		adminGroup := apiV1.Group("/admin")
		adminGroup.Use(middleware.AdminOnly())
		{
			// Client Management
			adminGroup.POST("/clients", clientHandlers.HandleCreateClient)
			adminGroup.GET("/clients", clientHandlers.HandleListClients)
			adminGroup.GET("/clients/:client_id/usage", clientHandlers.HandleGetClientUsage)

			// System & Workflow Management
			adminGroup.GET("/system/status", systemHandlers.HandleGetSystemStatus)
			adminGroup.GET("/system/kafka/topics", systemHandlers.HandleListKafkaTopics)
			adminGroup.GET("/workflows", systemHandlers.HandleListWorkflows)
			adminGroup.GET("/workflows/:correlation_id", systemHandlers.HandleGetWorkflow)
			adminGroup.POST("/workflows/:correlation_id/resume", systemHandlers.HandleResumeWorkflow)

			// Agent Definition Management
			adminGroup.GET("/agent-definitions", systemHandlers.HandleListAgentDefinitions)
			adminGroup.PUT("/agent-definitions/:type_name", systemHandlers.HandleUpdateAgentDefinition)

			// Agent Instance Management
			adminGroup.PUT("/clients/:client_id/instances/:instance_id/config", agentAdminHandlers.HandleUpdateInstanceConfig)
		}
	}
}

// Start starts the HTTP server
func (s *Server) Start() error {
	s.logger.Info("Starting Core Manager API server", zap.String("address", s.httpServer.Addr))
	return s.httpServer.ListenAndServe()
}

// Shutdown gracefully shuts down the server
func (s *Server) Shutdown(ctx context.Context) error {
	s.kafkaProducer.Close()
	return s.httpServer.Shutdown(ctx)
}

// Address returns the server's address
func (s *Server) Address() string {
	return s.httpServer.Addr
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/client_handlers.go
// FILE: internal/core-manager/admin/client_handlers.go
package admin

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// ClientHandlers handles admin operations for client management
type ClientHandlers struct {
	clientsDB *pgxpool.Pool
	logger    *zap.Logger
}

// NewClientHandlers creates new client admin handlers
func NewClientHandlers(clientsDB *pgxpool.Pool, logger *zap.Logger) *ClientHandlers {
	return &ClientHandlers{
		clientsDB: clientsDB,
		logger:    logger,
	}
}

// CreateClientRequest represents a request to create a new client
type CreateClientRequest struct {
	ClientID    string                 `json:"client_id" binding:"required,alphanum,min=3,max=50"`
	DisplayName string                 `json:"display_name" binding:"required"`
	Settings    map[string]interface{} `json:"settings,omitempty"`
}

// ClientInfo represents client information
type ClientInfo struct {
	ClientID    string                 `json:"client_id"`
	DisplayName string                 `json:"display_name"`
	Settings    map[string]interface{} `json:"settings,omitempty"`
	CreatedAt   string                 `json:"created_at"`
	IsActive    bool                   `json:"is_active"`
}

// HandleCreateClient creates a new client with schema
func (h *ClientHandlers) HandleCreateClient(c *gin.Context) {
	var req CreateClientRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate client_id format (alphanumeric, underscores allowed)
	if !isValidClientID(req.ClientID) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid client_id format. Use only alphanumeric characters and underscores"})
		return
	}

	// Check if client already exists
	exists, err := h.clientExists(c.Request.Context(), req.ClientID)
	if err != nil {
		h.logger.Error("Failed to check client existence", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check client existence"})
		return
	}

	if exists {
		c.JSON(http.StatusConflict, gin.H{"error": "Client already exists"})
		return
	}

	// Create client schema
	if err := h.createClientSchema(c.Request.Context(), req.ClientID); err != nil {
		h.logger.Error("Failed to create client schema", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create client schema"})
		return
	}

	// Store client info in a clients table (we'll need to create this)
	if err := h.storeClientInfo(c.Request.Context(), &req); err != nil {
		h.logger.Error("Failed to store client info", zap.Error(err))
		// Note: Schema is already created, this is a partial failure
	}

	h.logger.Info("Client created successfully", zap.String("client_id", req.ClientID))
	c.JSON(http.StatusCreated, gin.H{
		"message":   "Client created successfully",
		"client_id": req.ClientID,
	})
}

// HandleListClients lists all clients
func (h *ClientHandlers) HandleListClients(c *gin.Context) {
	clients, err := h.listClients(c.Request.Context())
	if err != nil {
		h.logger.Error("Failed to list clients", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list clients"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"clients": clients,
		"count":   len(clients),
	})
}

// HandleGetClientUsage gets usage statistics for a client
func (h *ClientHandlers) HandleGetClientUsage(c *gin.Context) {
	clientID := c.Param("client_id")

	if !isValidClientID(clientID) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid client_id format"})
		return
	}

	usage, err := h.getClientUsage(c.Request.Context(), clientID)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Client not found"})
			return
		}
		h.logger.Error("Failed to get client usage", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get client usage"})
		return
	}

	c.JSON(http.StatusOK, usage)
}

// Helper functions

func isValidClientID(clientID string) bool {
	// Only allow alphanumeric and underscores
	for _, char := range clientID {
		if !((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9') || char == '_') {
			return false
		}
	}
	return len(clientID) >= 3 && len(clientID) <= 50
}

func (h *ClientHandlers) clientExists(ctx context.Context, clientID string) (bool, error) {
	// Check if schema exists
	query := `
		SELECT EXISTS (
			SELECT 1 FROM information_schema.schemata 
			WHERE schema_name = $1
		)
	`
	schemaName := fmt.Sprintf("client_%s", clientID)

	var exists bool
	err := h.clientsDB.QueryRow(ctx, query, schemaName).Scan(&exists)
	return exists, err
}

func (h *ClientHandlers) createClientSchema(ctx context.Context, clientID string) error {
	// Call the stored procedure to create client schema
	query := `SELECT create_client_schema($1)`
	_, err := h.clientsDB.Exec(ctx, query, clientID)
	return err
}

func (h *ClientHandlers) storeClientInfo(ctx context.Context, req *CreateClientRequest) error {
	// First, ensure we have a clients info table
	createTableQuery := `
		CREATE TABLE IF NOT EXISTS clients_info (
			client_id VARCHAR(50) PRIMARY KEY,
			display_name VARCHAR(255) NOT NULL,
			settings JSONB DEFAULT '{}',
			is_active BOOLEAN DEFAULT true,
			created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
			updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
		)
	`

	if _, err := h.clientsDB.Exec(ctx, createTableQuery); err != nil {
		return fmt.Errorf("failed to create clients_info table: %w", err)
	}

	// Insert client info
	insertQuery := `
		INSERT INTO clients_info (client_id, display_name, settings)
		VALUES ($1, $2, $3)
		ON CONFLICT (client_id) DO NOTHING
	`

	_, err := h.clientsDB.Exec(ctx, insertQuery, req.ClientID, req.DisplayName, req.Settings)
	return err
}

func (h *ClientHandlers) listClients(ctx context.Context) ([]ClientInfo, error) {
	// First ensure the table exists
	h.storeClientInfo(ctx, &CreateClientRequest{}) // This will create table if needed

	query := `
		SELECT client_id, display_name, settings, is_active, created_at
		FROM clients_info
		WHERE is_active = true
		ORDER BY created_at DESC
	`

	rows, err := h.clientsDB.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var clients []ClientInfo
	for rows.Next() {
		var client ClientInfo
		var createdAt sql.NullTime
		var settings sql.NullString

		err := rows.Scan(&client.ClientID, &client.DisplayName, &settings, &client.IsActive, &createdAt)
		if err != nil {
			h.logger.Error("Failed to scan client row", zap.Error(err))
			continue
		}

		if createdAt.Valid {
			client.CreatedAt = createdAt.Time.Format("2006-01-02T15:04:05Z")
		}

		clients = append(clients, client)
	}

	// Also check for schemas without entries in clients_info
	schemaQuery := `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
		AND schema_name NOT IN (
			SELECT 'client_' || client_id FROM clients_info
		)
	`

	schemaRows, err := h.clientsDB.Query(ctx, schemaQuery)
	if err == nil {
		defer schemaRows.Close()
		for schemaRows.Next() {
			var schemaName string
			if err := schemaRows.Scan(&schemaName); err == nil {
				clientID := strings.TrimPrefix(schemaName, "client_")
				clients = append(clients, ClientInfo{
					ClientID:    clientID,
					DisplayName: clientID + " (Legacy)",
					IsActive:    true,
					CreatedAt:   "Unknown",
				})
			}
		}
	}

	return clients, nil
}

// ClientUsageStats represents usage statistics for a client
type ClientUsageStats struct {
	ClientID            string `json:"client_id"`
	TotalUsers          int    `json:"total_users"`
	ActiveUsers         int    `json:"active_users"`
	TotalInstances      int    `json:"total_instances"`
	ActiveInstances     int    `json:"active_instances"`
	TotalWorkflows      int    `json:"total_workflows"`
	WorkflowsLast30Days int    `json:"workflows_last_30_days"`
	TotalMemoryEntries  int    `json:"total_memory_entries"`
	TotalFuelConsumed   int64  `json:"total_fuel_consumed"`
}

func (h *ClientHandlers) getClientUsage(ctx context.Context, clientID string) (*ClientUsageStats, error) {
	stats := &ClientUsageStats{ClientID: clientID}

	// Get user counts from auth database (would need access to auth DB)
	// For now, we'll focus on what we can get from clients DB

	// Count agent instances
	instanceQuery := fmt.Sprintf(`
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE is_active = true) as active
		FROM client_%s.agent_instances
	`, clientID)

	err := h.clientsDB.QueryRow(ctx, instanceQuery).Scan(&stats.TotalInstances, &stats.ActiveInstances)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		return nil, err
	}

	// Count workflows
	workflowQuery := fmt.Sprintf(`
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE started_at > NOW() - INTERVAL '30 days') as recent
		FROM client_%s.workflow_executions
	`, clientID)

	err = h.clientsDB.QueryRow(ctx, workflowQuery).Scan(&stats.TotalWorkflows, &stats.WorkflowsLast30Days)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		h.logger.Warn("Failed to get workflow stats", zap.Error(err))
	}

	// Count memory entries
	memoryQuery := fmt.Sprintf(`
		SELECT COUNT(*) FROM client_%s.agent_memory
	`, clientID)

	err = h.clientsDB.QueryRow(ctx, memoryQuery).Scan(&stats.TotalMemoryEntries)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		h.logger.Warn("Failed to get memory stats", zap.Error(err))
	}

	// Get fuel consumption
	fuelQuery := fmt.Sprintf(`
		SELECT COALESCE(SUM(fuel_consumed), 0)
		FROM client_%s.usage_analytics
	`, clientID)

	err = h.clientsDB.QueryRow(ctx, fuelQuery).Scan(&stats.TotalFuelConsumed)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		h.logger.Warn("Failed to get fuel stats", zap.Error(err))
	}

	return stats, nil
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/dashboard_handlers.go
// FILE: internal/core-manager/admin/dashboard_handlers.go
package admin

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// DashboardHandlers provides admin dashboard endpoints
type DashboardHandlers struct {
	clientsDB   *pgxpool.Pool
	templatesDB *pgxpool.Pool
	authDB      *sql.DB // For accessing auth database
	logger      *zap.Logger
}

// NewDashboardHandlers creates new dashboard handlers
func NewDashboardHandlers(clientsDB, templatesDB *pgxpool.Pool, authDB *sql.DB, logger *zap.Logger) *DashboardHandlers {
	return &DashboardHandlers{
		clientsDB:   clientsDB,
		templatesDB: templatesDB,
		authDB:      authDB,
		logger:      logger,
	}
}

// DashboardMetrics represents overall system metrics
type DashboardMetrics struct {
	Overview       OverviewMetrics     `json:"overview"`
	UserMetrics    UserMetrics         `json:"user_metrics"`
	AgentMetrics   AgentMetrics        `json:"agent_metrics"`
	UsageMetrics   UsageMetrics        `json:"usage_metrics"`
	SystemHealth   SystemHealthMetrics `json:"system_health"`
	RecentActivity []ActivityEntry     `json:"recent_activity"`
}

type OverviewMetrics struct {
	TotalClients        int     `json:"total_clients"`
	TotalUsers          int     `json:"total_users"`
	ActiveUsers30Days   int     `json:"active_users_30_days"`
	TotalAgentInstances int     `json:"total_agent_instances"`
	TotalWorkflows      int     `json:"total_workflows"`
	SuccessRate         float64 `json:"success_rate"`
	TotalRevenue        float64 `json:"total_revenue_mtd"`
}

type UserMetrics struct {
	UsersByTier      map[string]int `json:"users_by_tier"`
	NewUsersToday    int            `json:"new_users_today"`
	NewUsersThisWeek int            `json:"new_users_this_week"`
	ChurnRate        float64        `json:"churn_rate_monthly"`
}

type AgentMetrics struct {
	AgentsByType        map[string]int `json:"agents_by_type"`
	MostUsedAgents      []AgentUsage   `json:"most_used_agents"`
	AverageResponseTime float64        `json:"avg_response_time_ms"`
}

type AgentUsage struct {
	AgentType  string `json:"agent_type"`
	UsageCount int    `json:"usage_count"`
}

type UsageMetrics struct {
	TotalFuelConsumed int64            `json:"total_fuel_consumed"`
	FuelByAgentType   map[string]int64 `json:"fuel_by_agent_type"`
	APICallsToday     int              `json:"api_calls_today"`
	StorageUsedGB     float64          `json:"storage_used_gb"`
}

type SystemHealthMetrics struct {
	DatabaseStatus  string  `json:"database_status"`
	KafkaStatus     string  `json:"kafka_status"`
	AverageLatency  float64 `json:"average_latency_ms"`
	ErrorRate       float64 `json:"error_rate_percent"`
	ActiveWorkflows int     `json:"active_workflows"`
	QueueDepth      int     `json:"queue_depth"`
}

type ActivityEntry struct {
	Timestamp   time.Time `json:"timestamp"`
	Type        string    `json:"type"`
	Description string    `json:"description"`
	UserID      string    `json:"user_id,omitempty"`
	ClientID    string    `json:"client_id,omitempty"`
}

// HandleGetDashboard returns comprehensive dashboard metrics
func (h *DashboardHandlers) HandleGetDashboard(c *gin.Context) {
	ctx := c.Request.Context()

	metrics := &DashboardMetrics{
		Overview:       h.getOverviewMetrics(ctx),
		UserMetrics:    h.getUserMetrics(ctx),
		AgentMetrics:   h.getAgentMetrics(ctx),
		UsageMetrics:   h.getUsageMetrics(ctx),
		SystemHealth:   h.getSystemHealth(ctx),
		RecentActivity: h.getRecentActivity(ctx),
	}

	c.JSON(http.StatusOK, metrics)
}

// getOverviewMetrics collects high-level system metrics
func (h *DashboardHandlers) getOverviewMetrics(ctx context.Context) OverviewMetrics {
	metrics := OverviewMetrics{}

	// Count total clients
	var totalClients int
	err := h.clientsDB.QueryRow(ctx, `
		SELECT COUNT(DISTINCT schema_name) 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`).Scan(&totalClients)
	if err != nil {
		h.logger.Error("Failed to count clients", zap.Error(err))
	}
	metrics.TotalClients = totalClients

	// Count total users from auth DB
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM users WHERE is_active = true
	`).Scan(&metrics.TotalUsers)
	if err != nil {
		h.logger.Error("Failed to count users", zap.Error(err))
	}

	// Count active users in last 30 days
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(DISTINCT user_id) 
		FROM user_activity_logs 
		WHERE created_at > NOW() - INTERVAL 30 DAY
	`).Scan(&metrics.ActiveUsers30Days)
	if err != nil {
		h.logger.Error("Failed to count active users", zap.Error(err))
	}

	// Count total agent instances across all clients
	rows, err := h.clientsDB.Query(ctx, `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var schemaName string
			if err := rows.Scan(&schemaName); err == nil {
				var count int
				query := fmt.Sprintf("SELECT COUNT(*) FROM %s.agent_instances WHERE is_active = true", schemaName)
				h.clientsDB.QueryRow(ctx, query).Scan(&count)
				metrics.TotalAgentInstances += count
			}
		}
	}

	// Count total workflows and calculate success rate
	var successCount int
	err = h.clientsDB.QueryRow(ctx, `
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE status = 'COMPLETED') as success
		FROM orchestrator_state
		WHERE created_at > NOW() - INTERVAL '30 days'
	`).Scan(&metrics.TotalWorkflows, &successCount)
	if err == nil && metrics.TotalWorkflows > 0 {
		metrics.SuccessRate = float64(successCount) / float64(metrics.TotalWorkflows) * 100
	}

	// Calculate total revenue (simplified - would need proper billing integration)
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COALESCE(SUM(
			CASE 
				WHEN st.name = 'basic' THEN st.price_monthly
				WHEN st.name = 'premium' THEN st.price_monthly
				WHEN st.name = 'enterprise' THEN st.price_monthly
				ELSE 0
			END
		), 0) as total_revenue
		FROM users u
		JOIN subscriptions s ON u.id = s.user_id
		JOIN subscription_tiers st ON s.tier = st.name
		WHERE u.is_active = true AND s.status = 'active'
	`).Scan(&metrics.TotalRevenue)
	if err != nil {
		h.logger.Error("Failed to calculate revenue", zap.Error(err))
	}

	return metrics
}

// getUserMetrics collects user-related metrics
func (h *DashboardHandlers) getUserMetrics(ctx context.Context) UserMetrics {
	metrics := UserMetrics{
		UsersByTier: make(map[string]int),
	}

	// Count users by subscription tier
	rows, err := h.authDB.QueryContext(ctx, `
		SELECT subscription_tier, COUNT(*) 
		FROM users 
		WHERE is_active = true 
		GROUP BY subscription_tier
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var tier string
			var count int
			if err := rows.Scan(&tier, &count); err == nil {
				metrics.UsersByTier[tier] = count
			}
		}
	}

	// Count new users today
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM users 
		WHERE DATE(created_at) = CURDATE()
	`).Scan(&metrics.NewUsersToday)

	// Count new users this week
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM users 
		WHERE created_at > NOW() - INTERVAL 7 DAY
	`).Scan(&metrics.NewUsersThisWeek)

	// Calculate churn rate (simplified)
	var totalLastMonth, churnedThisMonth int
	h.authDB.QueryRowContext(ctx, `
		SELECT 
			(SELECT COUNT(*) FROM users WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 MONTH)) as total_last_month,
			(SELECT COUNT(*) FROM users WHERE is_active = false AND updated_at > DATE_SUB(NOW(), INTERVAL 1 MONTH)) as churned
	`).Scan(&totalLastMonth, &churnedThisMonth)

	if totalLastMonth > 0 {
		metrics.ChurnRate = float64(churnedThisMonth) / float64(totalLastMonth) * 100
	}

	return metrics
}

// getAgentMetrics collects agent-related metrics
func (h *DashboardHandlers) getAgentMetrics(ctx context.Context) AgentMetrics {
	metrics := AgentMetrics{
		AgentsByType: make(map[string]int),
	}

	// Count agents by type
	rows, err := h.clientsDB.Query(ctx, `
		SELECT type, COUNT(*) 
		FROM agent_definitions 
		WHERE is_active = true 
		GROUP BY type
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var agentType string
			var count int
			if err := rows.Scan(&agentType, &count); err == nil {
				metrics.AgentsByType[agentType] = count
			}
		}
	}

	// Get most used agents (from all client schemas)
	// This is simplified - in production you'd aggregate across all client schemas
	mostUsedQuery := `
		SELECT 
			ad.type,
			COUNT(*) as usage_count
		FROM orchestrator_state os
		JOIN agent_definitions ad ON true
		WHERE os.created_at > NOW() - INTERVAL '7 days'
		GROUP BY ad.type
		ORDER BY usage_count DESC
		LIMIT 5
	`

	rows, err = h.clientsDB.Query(ctx, mostUsedQuery)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var usage AgentUsage
			if err := rows.Scan(&usage.AgentType, &usage.UsageCount); err == nil {
				metrics.MostUsedAgents = append(metrics.MostUsedAgents, usage)
			}
		}
	}

	// Calculate average response time (simplified)
	// In production, this would come from your metrics system
	metrics.AverageResponseTime = 245.7 // Mock value

	return metrics
}

// getUsageMetrics collects resource usage metrics
func (h *DashboardHandlers) getUsageMetrics(ctx context.Context) UsageMetrics {
	metrics := UsageMetrics{
		FuelByAgentType: make(map[string]int64),
	}

	// Get total fuel consumed across all clients
	// This would need to aggregate from all client schemas
	metrics.TotalFuelConsumed = 125000 // Mock value

	// Fuel by agent type (mock data)
	metrics.FuelByAgentType = map[string]int64{
		"copywriter":      45000,
		"researcher":      35000,
		"reasoning":       25000,
		"image-generator": 20000,
	}

	// API calls today (mock)
	metrics.APICallsToday = 8543

	// Storage used (would query actual storage metrics)
	metrics.StorageUsedGB = 45.7

	return metrics
}

// getSystemHealth checks current system health
func (h *DashboardHandlers) getSystemHealth(ctx context.Context) SystemHealthMetrics {
	metrics := SystemHealthMetrics{}

	// Check database status
	if err := h.clientsDB.Ping(ctx); err != nil {
		metrics.DatabaseStatus = "unhealthy"
	} else {
		metrics.DatabaseStatus = "healthy"
	}

	// Kafka status (simplified)
	metrics.KafkaStatus = "healthy"

	// Get active workflows count
	h.clientsDB.QueryRow(ctx, `
		SELECT COUNT(*) FROM orchestrator_state 
		WHERE status IN ('RUNNING', 'AWAITING_RESPONSES', 'PAUSED_FOR_HUMAN_INPUT')
	`).Scan(&metrics.ActiveWorkflows)

	// Mock metrics - in production these would come from Prometheus
	metrics.AverageLatency = 123.5
	metrics.ErrorRate = 0.02
	metrics.QueueDepth = 42

	return metrics
}

// getRecentActivity returns recent system activity
func (h *DashboardHandlers) getRecentActivity(ctx context.Context) []ActivityEntry {
	activities := []ActivityEntry{}

	// Get recent user registrations
	rows, err := h.authDB.QueryContext(ctx, `
		SELECT created_at, 'user_registration' as type, email, client_id
		FROM users
		ORDER BY created_at DESC
		LIMIT 10
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var activity ActivityEntry
			var email string
			rows.Scan(&activity.Timestamp, &activity.Type, &email, &activity.ClientID)
			activity.Description = fmt.Sprintf("New user registered: %s", email)
			activities = append(activities, activity)
		}
	}

	// Get recent workflow completions
	workflowRows, err := h.clientsDB.Query(ctx, `
		SELECT updated_at, status, correlation_id, client_id
		FROM orchestrator_state
		WHERE status IN ('COMPLETED', 'FAILED')
		ORDER BY updated_at DESC
		LIMIT 10
	`)
	if err == nil {
		defer workflowRows.Close()
		for workflowRows.Next() {
			var activity ActivityEntry
			var status, correlationID string
			workflowRows.Scan(&activity.Timestamp, &status, &correlationID, &activity.ClientID)
			activity.Type = "workflow_" + strings.ToLower(status)
			activity.Description = fmt.Sprintf("Workflow %s: %s", status, correlationID[:8])
			activities = append(activities, activity)
		}
	}

	// Sort by timestamp
	sort.Slice(activities, func(i, j int) bool {
		return activities[i].Timestamp.After(activities[j].Timestamp)
	})

	// Return top 20
	if len(activities) > 20 {
		activities = activities[:20]
	}

	return activities
}

// HandleGetSystemLogs returns recent system logs
func (h *DashboardHandlers) HandleGetSystemLogs(c *gin.Context) {
	service := c.Query("service")
	level := c.Query("level")
	limit := 100

	if limitStr := c.Query("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 1000 {
			limit = l
		}
	}

	// In production, this would query your centralized logging system
	// For now, return mock data
	logs := []LogEntry{
		{
			Timestamp: time.Now(),
			Service:   "auth-service",
			Level:     "info",
			Message:   "User login successful",
			Metadata: map[string]interface{}{
				"user_id": "123",
				"ip":      "192.168.1.1",
			},
		},
	}

	c.JSON(http.StatusOK, gin.H{
		"logs":  logs,
		"total": len(logs),
		"query": gin.H{
			"service": service,
			"level":   level,
			"limit":   limit,
		},
	})
}

type LogEntry struct {
	Timestamp time.Time              `json:"timestamp"`
	Service   string                 `json:"service"`
	Level     string                 `json:"level"`
	Message   string                 `json:"message"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/system_handlers.go
// FILE: internal/core-manager/admin/system_handlers.go
package admin

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/platform/kafka"
	"github.com/gqls/agentchassis/platform/orchestration"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// SystemHandlers handles admin system monitoring operations
type SystemHandlers struct {
	clientsDB     *pgxpool.Pool
	templatesDB   *pgxpool.Pool
	kafkaProducer kafka.Producer
	logger        *zap.Logger
}

// NewSystemHandlers creates new system monitoring handlers
func NewSystemHandlers(clientsDB, templatesDB *pgxpool.Pool, kafkaProducer kafka.Producer, logger *zap.Logger) *SystemHandlers {
	return &SystemHandlers{
		clientsDB:     clientsDB,
		templatesDB:   templatesDB,
		kafkaProducer: kafkaProducer,
		logger:        logger,
	}
}

// SystemStatus represents overall system health
type SystemStatus struct {
	Status      string                    `json:"status"`
	Timestamp   time.Time                 `json:"timestamp"`
	Services    map[string]ServiceStatus  `json:"services"`
	Databases   map[string]DatabaseStatus `json:"databases"`
	KafkaStatus KafkaStatus               `json:"kafka"`
}

// ServiceStatus represents a service health status
type ServiceStatus struct {
	Name    string `json:"name"`
	Status  string `json:"status"`
	Version string `json:"version,omitempty"`
	Uptime  string `json:"uptime,omitempty"`
}

// DatabaseStatus represents database health
type DatabaseStatus struct {
	Name        string `json:"name"`
	Status      string `json:"status"`
	Connections int    `json:"active_connections"`
	Size        string `json:"size,omitempty"`
}

// KafkaStatus represents Kafka cluster status
type KafkaStatus struct {
	Status      string `json:"status"`
	BrokerCount int    `json:"broker_count"`
	TopicCount  int    `json:"topic_count"`
	ConsumerLag int64  `json:"total_consumer_lag,omitempty"`
}

// HandleGetSystemStatus returns aggregated system status
func (h *SystemHandlers) HandleGetSystemStatus(c *gin.Context) {
	status := SystemStatus{
		Status:    "healthy",
		Timestamp: time.Now(),
		Services:  make(map[string]ServiceStatus),
		Databases: make(map[string]DatabaseStatus),
	}

	// Check database connections
	// Clients DB
	if err := h.clientsDB.Ping(c.Request.Context()); err != nil {
		status.Status = "degraded"
		status.Databases["clients_db"] = DatabaseStatus{
			Name:   "clients_db",
			Status: "unhealthy",
		}
	} else {
		stats := h.clientsDB.Stat()
		status.Databases["clients_db"] = DatabaseStatus{
			Name:        "clients_db",
			Status:      "healthy",
			Connections: int(stats.AcquiredConns()),
		}
	}

	// Templates DB
	if err := h.templatesDB.Ping(c.Request.Context()); err != nil {
		status.Status = "degraded"
		status.Databases["templates_db"] = DatabaseStatus{
			Name:   "templates_db",
			Status: "unhealthy",
		}
	} else {
		stats := h.templatesDB.Stat()
		status.Databases["templates_db"] = DatabaseStatus{
			Name:        "templates_db",
			Status:      "healthy",
			Connections: int(stats.AcquiredConns()),
		}
	}

	// Get database sizes
	h.getDatabaseSizes(c.Request.Context(), &status)

	// Check Kafka (simplified - in production you'd want more detailed checks)
	status.KafkaStatus = h.getKafkaStatus(c.Request.Context())

	c.JSON(http.StatusOK, status)
}

// HandleListKafkaTopics lists all Kafka topics
func (h *SystemHandlers) HandleListKafkaTopics(c *gin.Context) {
	// This would require a Kafka admin client
	// For now, return known topics
	knownTopics := []string{
		"orchestrator.state-changes",
		"human.approvals",
		"system.events",
		"system.notifications.ui",
		"system.commands.workflow.resume",
		"system.agent.reasoning.process",
		"system.responses.reasoning",
		"system.adapter.image.generate",
		"system.responses.image",
		"system.adapter.web.search",
		"system.responses.websearch",
		"system.agent.generic.process",
		"system.tasks.copywriter",
		"system.tasks.researcher",
		"system.tasks.content-creator",
		"system.tasks.multimedia-creator",
	}

	c.JSON(http.StatusOK, gin.H{
		"topics": knownTopics,
		"count":  len(knownTopics),
	})
}

// WorkflowListRequest represents workflow filtering parameters
type WorkflowListRequest struct {
	Status    string `form:"status"`
	ClientID  string `form:"client_id"`
	StartDate string `form:"start_date"`
	EndDate   string `form:"end_date"`
	Limit     int    `form:"limit,default=50"`
	Offset    int    `form:"offset,default=0"`
}

// HandleListWorkflows lists workflow executions
func (h *SystemHandlers) HandleListWorkflows(c *gin.Context) {
	var req WorkflowListRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	workflows, err := h.listWorkflows(c.Request.Context(), req)
	if err != nil {
		h.logger.Error("Failed to list workflows", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list workflows"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"workflows": workflows,
		"count":     len(workflows),
	})
}

// HandleGetWorkflow returns detailed workflow state
func (h *SystemHandlers) HandleGetWorkflow(c *gin.Context) {
	correlationID := c.Param("correlation_id")

	workflow, err := h.getWorkflowState(c.Request.Context(), correlationID)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
			return
		}
		h.logger.Error("Failed to get workflow", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get workflow"})
		return
	}

	c.JSON(http.StatusOK, workflow)
}

// HandleResumeWorkflow manually resumes or terminates a workflow
func (h *SystemHandlers) HandleResumeWorkflow(c *gin.Context) {
	correlationID := c.Param("correlation_id")

	var req struct {
		Action   string                 `json:"action" binding:"required,oneof=resume terminate"`
		Feedback map[string]interface{} `json:"feedback,omitempty"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get workflow state to find client_id
	workflow, err := h.getWorkflowState(c.Request.Context(), correlationID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		return
	}

	if req.Action == "terminate" {
		// Update workflow status to FAILED
		err = h.updateWorkflowStatus(c.Request.Context(), correlationID, "FAILED", "Manually terminated by admin")
		if err != nil {
			h.logger.Error("Failed to terminate workflow", zap.Error(err))
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to terminate workflow"})
			return
		}
	} else if req.Action == "resume" {
		// Send resume command via Kafka
		resumePayload := map[string]interface{}{
			"approved": true,
			"feedback": req.Feedback,
		}

		payloadBytes, _ := json.Marshal(resumePayload)
		headers := map[string]string{
			"correlation_id": correlationID,
			"client_id":      workflow["client_id"].(string),
			"admin_action":   "true",
		}

		err = h.kafkaProducer.Produce(c.Request.Context(),
			orchestration.ResumeWorkflowTopic,
			headers,
			[]byte(correlationID),
			payloadBytes,
		)

		if err != nil {
			h.logger.Error("Failed to send resume command", zap.Error(err))
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to resume workflow"})
			return
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"message":        fmt.Sprintf("Workflow %s successfully", req.Action+"d"),
		"correlation_id": correlationID,
	})
}

// HandleListAgentDefinitions lists all agent types
func (h *SystemHandlers) HandleListAgentDefinitions(c *gin.Context) {
	query := `
		SELECT id, type, display_name, description, category, default_config, is_active
		FROM agent_definitions
		WHERE deleted_at IS NULL
		ORDER BY category, type
	`

	rows, err := h.clientsDB.Query(c.Request.Context(), query)
	if err != nil {
		h.logger.Error("Failed to list agent definitions", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list agent definitions"})
		return
	}
	defer rows.Close()

	var definitions []map[string]interface{}
	for rows.Next() {
		var def struct {
			ID            string
			Type          string
			DisplayName   string
			Description   string
			Category      string
			DefaultConfig json.RawMessage
			IsActive      bool
		}

		err := rows.Scan(&def.ID, &def.Type, &def.DisplayName,
			&def.Description, &def.Category, &def.DefaultConfig, &def.IsActive)
		if err != nil {
			h.logger.Error("Failed to scan agent definition", zap.Error(err))
			continue
		}

		var config map[string]interface{}
		json.Unmarshal(def.DefaultConfig, &config)

		definitions = append(definitions, map[string]interface{}{
			"id":             def.ID,
			"type":           def.Type,
			"display_name":   def.DisplayName,
			"description":    def.Description,
			"category":       def.Category,
			"default_config": config,
			"is_active":      def.IsActive,
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"definitions": definitions,
		"count":       len(definitions),
	})
}

// HandleUpdateAgentDefinition updates an agent type configuration
func (h *SystemHandlers) HandleUpdateAgentDefinition(c *gin.Context) {
	typeName := c.Param("type_name")

	var req struct {
		DisplayName   *string                `json:"display_name"`
		Description   *string                `json:"description"`
		DefaultConfig map[string]interface{} `json:"default_config"`
		IsActive      *bool                  `json:"is_active"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Build update query
	updates := []string{"updated_at = NOW()"}
	args := []interface{}{}
	argCount := 0

	if req.DisplayName != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("display_name = $%d", argCount))
		args = append(args, *req.DisplayName)
	}

	if req.Description != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("description = $%d", argCount))
		args = append(args, *req.Description)
	}

	if req.DefaultConfig != nil {
		argCount++
		configBytes, _ := json.Marshal(req.DefaultConfig)
		updates = append(updates, fmt.Sprintf("default_config = $%d", argCount))
		args = append(args, configBytes)
	}

	if req.IsActive != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("is_active = $%d", argCount))
		args = append(args, *req.IsActive)
	}

	argCount++
	args = append(args, typeName)

	query := fmt.Sprintf(
		"UPDATE agent_definitions SET %s WHERE type = $%d AND deleted_at IS NULL",
		strings.Join(updates, ", "),
		argCount,
	)

	result, err := h.clientsDB.Exec(c.Request.Context(), query, args...)
	if err != nil {
		h.logger.Error("Failed to update agent definition", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update agent definition"})
		return
	}

	if result.RowsAffected() == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Agent definition not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Agent definition updated successfully",
		"type":    typeName,
	})
}

// Helper methods

func (h *SystemHandlers) getDatabaseSizes(ctx context.Context, status *SystemStatus) {
	// Get clients DB size
	var clientsSize string
	err := h.clientsDB.QueryRow(ctx,
		"SELECT pg_size_pretty(pg_database_size(current_database()))").Scan(&clientsSize)
	if err == nil {
		dbStatus := status.Databases["clients_db"]
		dbStatus.Size = clientsSize
		status.Databases["clients_db"] = dbStatus
	}

	// Get templates DB size
	var templatesSize string
	err = h.templatesDB.QueryRow(ctx,
		"SELECT pg_size_pretty(pg_database_size(current_database()))").Scan(&templatesSize)
	if err == nil {
		dbStatus := status.Databases["templates_db"]
		dbStatus.Size = templatesSize
		status.Databases["templates_db"] = dbStatus
	}
}

func (h *SystemHandlers) getKafkaStatus(ctx context.Context) KafkaStatus {
	// In a real implementation, you'd use a Kafka admin client
	// For now, return a simplified status
	return KafkaStatus{
		Status:      "healthy",
		BrokerCount: 3,  // Based on the k8s config
		TopicCount:  20, // Approximate
	}
}

func (h *SystemHandlers) listWorkflows(ctx context.Context, req WorkflowListRequest) ([]map[string]interface{}, error) {
	query := `
		SELECT correlation_id, client_id, status, current_step, 
		       created_at, updated_at, error
		FROM orchestrator_state
		WHERE 1=1
	`

	args := []interface{}{}
	argCount := 0

	if req.Status != "" {
		argCount++
		query += fmt.Sprintf(" AND status = $%d", argCount)
		args = append(args, req.Status)
	}

	if req.ClientID != "" {
		argCount++
		query += fmt.Sprintf(" AND client_id = $%d", argCount)
		args = append(args, req.ClientID)
	}

	if req.StartDate != "" {
		argCount++
		query += fmt.Sprintf(" AND created_at >= $%d", argCount)
		args = append(args, req.StartDate)
	}

	if req.EndDate != "" {
		argCount++
		query += fmt.Sprintf(" AND created_at <= $%d", argCount)
		args = append(args, req.EndDate)
	}

	query += " ORDER BY created_at DESC"

	argCount++
	query += fmt.Sprintf(" LIMIT $%d", argCount)
	args = append(args, req.Limit)

	argCount++
	query += fmt.Sprintf(" OFFSET $%d", argCount)
	args = append(args, req.Offset)

	rows, err := h.clientsDB.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var workflows []map[string]interface{}
	for rows.Next() {
		var w struct {
			CorrelationID string
			ClientID      string
			Status        string
			CurrentStep   string
			CreatedAt     time.Time
			UpdatedAt     time.Time
			Error         sql.NullString
		}

		err := rows.Scan(&w.CorrelationID, &w.ClientID, &w.Status,
			&w.CurrentStep, &w.CreatedAt, &w.UpdatedAt, &w.Error)
		if err != nil {
			continue
		}

		workflow := map[string]interface{}{
			"correlation_id": w.CorrelationID,
			"client_id":      w.ClientID,
			"status":         w.Status,
			"current_step":   w.CurrentStep,
			"created_at":     w.CreatedAt,
			"updated_at":     w.UpdatedAt,
		}

		if w.Error.Valid {
			workflow["error"] = w.Error.String
		}

		workflows = append(workflows, workflow)
	}

	return workflows, nil
}

func (h *SystemHandlers) getWorkflowState(ctx context.Context, correlationID string) (map[string]interface{}, error) {
	var state orchestration.OrchestrationState
	var awaitedStepsJSON, collectedDataJSON, initialRequestDataJSON, finalResultJSON []byte
	var errorNull sql.NullString

	query := `
		SELECT correlation_id, client_id, status, current_step, awaited_steps, 
		       collected_data, initial_request_data, final_result, error, 
		       created_at, updated_at
		FROM orchestrator_state
		WHERE correlation_id = $1
	`

	err := h.clientsDB.QueryRow(ctx, query, correlationID).Scan(
		&state.CorrelationID,
		&state.ClientID,
		&state.Status,
		&state.CurrentStep,
		&awaitedStepsJSON,
		&collectedDataJSON,
		&initialRequestDataJSON,
		&finalResultJSON,
		&errorNull,
		&state.CreatedAt,
		&state.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	// Parse JSON fields
	json.Unmarshal(awaitedStepsJSON, &state.AwaitedSteps)
	json.Unmarshal(collectedDataJSON, &state.CollectedData)
	state.InitialRequestData = initialRequestDataJSON
	state.FinalResult = finalResultJSON

	if errorNull.Valid {
		state.Error = errorNull.String
	}

	// Convert to map for response
	result := map[string]interface{}{
		"correlation_id":       state.CorrelationID,
		"client_id":            state.ClientID,
		"status":               state.Status,
		"current_step":         state.CurrentStep,
		"awaited_steps":        state.AwaitedSteps,
		"collected_data":       state.CollectedData,
		"initial_request_data": json.RawMessage(state.InitialRequestData),
		"final_result":         json.RawMessage(state.FinalResult),
		"error":                state.Error,
		"created_at":           state.CreatedAt,
		"updated_at":           state.UpdatedAt,
	}

	return result, nil
}

func (h *SystemHandlers) updateWorkflowStatus(ctx context.Context, correlationID, status, errorMsg string) error {
	query := `
		UPDATE orchestrator_state 
		SET status = $2, error = $3, updated_at = NOW()
		WHERE correlation_id = $1
	`

	_, err := h.clientsDB.Exec(ctx, query, correlationID, status, errorMsg)
	return err
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/agent_handlers.go
// FILE: internal/core-manager/admin/agent_handlers.go
package admin

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/gqls/agentchassis/pkg/models"
	"github.com/gqls/agentchassis/platform/kafka"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// AgentHandlers manages agent-related admin operations
type AgentHandlers struct {
	clientsDB     *pgxpool.Pool
	templatesDB   *pgxpool.Pool
	kafkaProducer kafka.Producer
	logger        *zap.Logger
	personaRepo   models.PersonaRepository
}

// NewAgentHandlers creates new agent management handlers
func NewAgentHandlers(clientsDB, templatesDB *pgxpool.Pool, kafkaProducer kafka.Producer, logger *zap.Logger, personaRepo models.PersonaRepository) *AgentHandlers {
	return &AgentHandlers{
		clientsDB:     clientsDB,
		templatesDB:   templatesDB,
		kafkaProducer: kafkaProducer,
		logger:        logger,
		personaRepo:   personaRepo,
	}
}

// AgentDefinitionRequest for creating/updating agent definitions
type AgentDefinitionRequest struct {
	Type          string                 `json:"type" binding:"required"`
	DisplayName   string                 `json:"display_name" binding:"required"`
	Description   string                 `json:"description"`
	Category      string                 `json:"category" binding:"required,oneof=data-driven code-driven adapter"`
	DefaultConfig map[string]interface{} `json:"default_config"`
}

// AgentInstanceDetails provides detailed info about an agent instance
type AgentInstanceDetails struct {
	ID           string                 `json:"id"`
	TemplateID   string                 `json:"template_id"`
	TemplateName string                 `json:"template_name"`
	ClientID     string                 `json:"client_id"`
	OwnerUserID  string                 `json:"owner_user_id"`
	Name         string                 `json:"name"`
	Config       map[string]interface{} `json:"config"`
	IsActive     bool                   `json:"is_active"`
	CreatedAt    time.Time              `json:"created_at"`
	UpdatedAt    time.Time              `json:"updated_at"`
	Usage        AgentUsageStats        `json:"usage"`
	Health       AgentHealthStatus      `json:"health"`
}

// AgentUsageStats tracks usage metrics for an agent
type AgentUsageStats struct {
	TotalExecutions   int        `json:"total_executions"`
	SuccessfulRuns    int        `json:"successful_runs"`
	FailedRuns        int        `json:"failed_runs"`
	AverageRunTime    float64    `json:"average_run_time_ms"`
	LastExecutionTime *time.Time `json:"last_execution_time,omitempty"`
	FuelConsumed      int64      `json:"fuel_consumed"`
}

// AgentHealthStatus represents current health of an agent
type AgentHealthStatus struct {
	Status        string    `json:"status"` // healthy, degraded, unhealthy
	LastCheckTime time.Time `json:"last_check_time"`
	ErrorRate     float64   `json:"error_rate_percent"`
	ResponseTime  float64   `json:"avg_response_time_ms"`
	QueueDepth    int       `json:"queue_depth"`
}

// HandleCreateAgentDefinition creates a new agent type
func (h *AgentHandlers) HandleCreateAgentDefinition(c *gin.Context) {
	var req AgentDefinitionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if type already exists
	var exists bool
	err := h.clientsDB.QueryRow(c.Request.Context(),
		"SELECT EXISTS(SELECT 1 FROM agent_definitions WHERE type = $1 AND deleted_at IS NULL)",
		req.Type,
	).Scan(&exists)

	if err != nil {
		h.logger.Error("Failed to check agent existence", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check agent existence"})
		return
	}

	if exists {
		c.JSON(http.StatusConflict, gin.H{"error": "Agent type already exists"})
		return
	}

	// Insert new agent definition
	id := uuid.New()
	configBytes, _ := json.Marshal(req.DefaultConfig)

	query := `
		INSERT INTO agent_definitions 
		(id, type, display_name, description, category, default_config, is_active)
		VALUES ($1, $2, $3, $4, $5, $6, true)
	`

	_, err = h.clientsDB.Exec(c.Request.Context(), query,
		id, req.Type, req.DisplayName, req.Description, req.Category, configBytes,
	)

	if err != nil {
		h.logger.Error("Failed to create agent definition", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create agent definition"})
		return
	}

	// Create Kafka topics for the new agent type
	h.createAgentTopics(c.Request.Context(), req.Type)

	h.logger.Info("Agent definition created",
		zap.String("id", id.String()),
		zap.String("type", req.Type))

	c.JSON(http.StatusCreated, gin.H{
		"id":      id.String(),
		"type":    req.Type,
		"message": "Agent definition created successfully",
	})
}

// HandleListAgentInstances lists all agent instances with filtering
func (h *AgentHandlers) HandleListAgentInstances(c *gin.Context) {
	clientID := c.Query("client_id")
	agentType := c.Query("agent_type")
	isActive := c.Query("is_active")

	instances := []AgentInstanceDetails{}

	// Get all client schemas
	schemaRows, err := h.clientsDB.Query(c.Request.Context(), `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`)
	if err != nil {
		h.logger.Error("Failed to list schemas", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list instances"})
		return
	}
	defer schemaRows.Close()

	for schemaRows.Next() {
		var schemaName string
		if err := schemaRows.Scan(&schemaName); err != nil {
			continue
		}

		currentClientID := strings.TrimPrefix(schemaName, "client_")
		if clientID != "" && currentClientID != clientID {
			continue
		}

		// Query instances from this client schema
		query := fmt.Sprintf(`
			SELECT 
				ai.id, ai.template_id, ai.owner_user_id, ai.name, 
				ai.config, ai.is_active, ai.created_at, ai.updated_at,
				pt.name as template_name
			FROM %s.agent_instances ai
			LEFT JOIN persona_templates pt ON ai.template_id = pt.id
			WHERE 1=1
		`, schemaName)

		args := []interface{}{}
		argCount := 0

		if agentType != "" {
			argCount++
			query += fmt.Sprintf(" AND pt.category = $%d", argCount)
			args = append(args, agentType)
		}

		if isActive != "" {
			argCount++
			query += fmt.Sprintf(" AND ai.is_active = $%d", argCount)
			args = append(args, isActive == "true")
		}

		rows, err := h.clientsDB.Query(c.Request.Context(), query, args...)
		if err != nil {
			h.logger.Error("Failed to query instances", zap.Error(err))
			continue
		}

		for rows.Next() {
			var instance AgentInstanceDetails
			var configJSON []byte
			var templateName sql.NullString

			err := rows.Scan(
				&instance.ID, &instance.TemplateID, &instance.OwnerUserID,
				&instance.Name, &configJSON, &instance.IsActive,
				&instance.CreatedAt, &instance.UpdatedAt, &templateName,
			)
			if err != nil {
				continue
			}

			instance.ClientID = currentClientID
			if templateName.Valid {
				instance.TemplateName = templateName.String
			}
			json.Unmarshal(configJSON, &instance.Config)

			// Get usage stats
			instance.Usage = h.getAgentUsageStats(c.Request.Context(), currentClientID, instance.ID)
			instance.Health = h.getAgentHealth(c.Request.Context(), instance.ID)

			instances = append(instances, instance)
		}
		rows.Close()
	}

	c.JSON(http.StatusOK, gin.H{
		"instances": instances,
		"count":     len(instances),
	})
}

// HandleGetAgentInstance returns detailed information about a specific agent
func (h *AgentHandlers) HandleGetAgentInstance(c *gin.Context) {
	agentID := c.Param("agent_id")
	clientID := c.Param("client_id")

	if clientID == "" {
		// Need to find which client owns this agent
		clientID = h.findClientForAgent(c.Request.Context(), agentID)
		if clientID == "" {
			c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
			return
		}
	}

	query := fmt.Sprintf(`
		SELECT 
			ai.id, ai.template_id, ai.owner_user_id, ai.name, 
			ai.config, ai.is_active, ai.created_at, ai.updated_at,
			pt.name as template_name
		FROM client_%s.agent_instances ai
		LEFT JOIN persona_templates pt ON ai.template_id = pt.id
		WHERE ai.id = $1
	`, clientID)

	var instance AgentInstanceDetails
	var configJSON []byte
	var templateName sql.NullString

	err := h.clientsDB.QueryRow(c.Request.Context(), query, agentID).Scan(
		&instance.ID, &instance.TemplateID, &instance.OwnerUserID,
		&instance.Name, &configJSON, &instance.IsActive,
		&instance.CreatedAt, &instance.UpdatedAt, &templateName,
	)

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
		return
	}

	instance.ClientID = clientID
	if templateName.Valid {
		instance.TemplateName = templateName.String
	}
	json.Unmarshal(configJSON, &instance.Config)

	// Get detailed usage and health
	instance.Usage = h.getAgentUsageStats(c.Request.Context(), clientID, agentID)
	instance.Health = h.getAgentHealth(c.Request.Context(), agentID)

	// Get recent executions
	executions := h.getRecentExecutions(c.Request.Context(), clientID, agentID, 10)

	c.JSON(http.StatusOK, gin.H{
		"agent":      instance,
		"executions": executions,
	})
}

// HandleToggleAgentStatus enables/disables an agent instance
func (h *AgentHandlers) HandleToggleAgentStatus(c *gin.Context) {
	agentID := c.Param("agent_id")
	clientID := c.Param("client_id")

	if clientID == "" {
		clientID = h.findClientForAgent(c.Request.Context(), agentID)
		if clientID == "" {
			c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
			return
		}
	}

	var req struct {
		IsActive bool   `json:"is_active"`
		Reason   string `json:"reason"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	query := fmt.Sprintf(`
		UPDATE client_%s.agent_instances 
		SET is_active = $2, updated_at = NOW()
		WHERE id = $1
	`, clientID)

	result, err := h.clientsDB.Exec(c.Request.Context(), query, agentID, req.IsActive)
	if err != nil {
		h.logger.Error("Failed to toggle agent status", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update agent status"})
		return
	}

	if result.RowsAffected() == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
		return
	}

	// Log the action
	h.logger.Info("Agent status toggled",
		zap.String("agent_id", agentID),
		zap.String("client_id", clientID),
		zap.Bool("is_active", req.IsActive),
		zap.String("reason", req.Reason))

	// Send notification if disabling
	if !req.IsActive {
		h.notifyAgentDisabled(c.Request.Context(), clientID, agentID, req.Reason)
	}

	c.JSON(http.StatusOK, gin.H{
		"message":   fmt.Sprintf("Agent %s successfully", map[bool]string{true: "enabled", false: "disabled"}[req.IsActive]),
		"agent_id":  agentID,
		"is_active": req.IsActive,
	})
}

// HandleRestartAgent sends a restart command to an agent
func (h *AgentHandlers) HandleRestartAgent(c *gin.Context) {
	agentID := c.Param("agent_id")

	// Send restart command via Kafka
	command := map[string]interface{}{
		"command":   "restart",
		"agent_id":  agentID,
		"timestamp": time.Now().UTC(),
	}

	commandBytes, _ := json.Marshal(command)
	headers := map[string]string{
		"correlation_id": uuid.NewString(),
		"command_type":   "agent_restart",
		"agent_id":       agentID,
	}

	err := h.kafkaProducer.Produce(c.Request.Context(),
		"system.agent.commands",
		headers,
		[]byte(agentID),
		commandBytes,
	)

	if err != nil {
		h.logger.Error("Failed to send restart command", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send restart command"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":  "Restart command sent",
		"agent_id": agentID,
	})
}

// Helper methods

func (h *AgentHandlers) createAgentTopics(ctx context.Context, agentType string) {
	topics := []string{
		fmt.Sprintf("tasks.high.%s", agentType),
		fmt.Sprintf("tasks.normal.%s", agentType),
		fmt.Sprintf("tasks.low.%s", agentType),
		fmt.Sprintf("responses.%s", agentType),
		fmt.Sprintf("dlq.%s", agentType),
	}

	for _, topic := range topics {
		// In production, you'd use Kafka admin client
		h.logger.Info("Would create Kafka topic", zap.String("topic", topic))
	}
}

func (h *AgentHandlers) findClientForAgent(ctx context.Context, agentID string) string {
	// Search through all client schemas
	rows, err := h.clientsDB.Query(ctx, `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`)
	if err != nil {
		return ""
	}
	defer rows.Close()

	for rows.Next() {
		var schemaName string
		if err := rows.Scan(&schemaName); err != nil {
			continue
		}

		var exists bool
		query := fmt.Sprintf("SELECT EXISTS(SELECT 1 FROM %s.agent_instances WHERE id = $1)", schemaName)
		if err := h.clientsDB.QueryRow(ctx, query, agentID).Scan(&exists); err == nil && exists {
			return strings.TrimPrefix(schemaName, "client_")
		}
	}

	return ""
}

func (h *AgentHandlers) getAgentUsageStats(ctx context.Context, clientID, agentID string) AgentUsageStats {
	stats := AgentUsageStats{}

	// Get execution stats from workflow_executions
	query := fmt.Sprintf(`
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE status = 'COMPLETED') as successful,
			COUNT(*) FILTER (WHERE status = 'FAILED') as failed,
			AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) * 1000) as avg_runtime,
			MAX(completed_at) as last_execution
		FROM client_%s.workflow_executions
		WHERE agent_instance_id = $1
	`, clientID)

	var lastExecution sql.NullTime
	h.clientsDB.QueryRow(ctx, query, agentID).Scan(
		&stats.TotalExecutions,
		&stats.SuccessfulRuns,
		&stats.FailedRuns,
		&stats.AverageRunTime,
		&lastExecution,
	)

	if lastExecution.Valid {
		stats.LastExecutionTime = &lastExecution.Time
	}

	// Get fuel consumption
	fuelQuery := fmt.Sprintf(`
		SELECT COALESCE(SUM(fuel_consumed), 0)
		FROM client_%s.usage_analytics
		WHERE metadata->>'agent_id' = $1
	`, clientID)
	h.clientsDB.QueryRow(ctx, fuelQuery, agentID).Scan(&stats.FuelConsumed)

	return stats
}

func (h *AgentHandlers) getAgentHealth(ctx context.Context, agentID string) AgentHealthStatus {
	// In production, this would query your metrics system
	return AgentHealthStatus{
		Status:        "healthy",
		LastCheckTime: time.Now(),
		ErrorRate:     2.5,
		ResponseTime:  145.3,
		QueueDepth:    3,
	}
}

func (h *AgentHandlers) getRecentExecutions(ctx context.Context, clientID, agentID string, limit int) []map[string]interface{} {
	executions := []map[string]interface{}{}

	query := fmt.Sprintf(`
		SELECT 
			id, correlation_id, status, started_at, completed_at,
			input_data, output_data, error_message
		FROM client_%s.workflow_executions
		WHERE agent_instance_id = $1
		ORDER BY started_at DESC
		LIMIT $2
	`, clientID)

	rows, err := h.clientsDB.Query(ctx, query, agentID, limit)
	if err != nil {
		return executions
	}
	defer rows.Close()

	for rows.Next() {
		var exec struct {
			ID            string
			CorrelationID string
			Status        string
			StartedAt     time.Time
			CompletedAt   sql.NullTime
			InputData     json.RawMessage
			OutputData    json.RawMessage
			ErrorMessage  sql.NullString
		}

		if err := rows.Scan(&exec.ID, &exec.CorrelationID, &exec.Status,
			&exec.StartedAt, &exec.CompletedAt, &exec.InputData,
			&exec.OutputData, &exec.ErrorMessage); err != nil {
			continue
		}

		execution := map[string]interface{}{
			"id":             exec.ID,
			"correlation_id": exec.CorrelationID,
			"status":         exec.Status,
			"started_at":     exec.StartedAt,
			"duration_ms":    nil,
		}

		if exec.CompletedAt.Valid {
			duration := exec.CompletedAt.Time.Sub(exec.StartedAt).Milliseconds()
			execution["completed_at"] = exec.CompletedAt.Time
			execution["duration_ms"] = duration
		}

		if exec.ErrorMessage.Valid {
			execution["error"] = exec.ErrorMessage.String
		}

		executions = append(executions, execution)
	}

	return executions
}

func (h *AgentHandlers) notifyAgentDisabled(ctx context.Context, clientID, agentID, reason string) {
	notification := map[string]interface{}{
		"event_type": "AGENT_DISABLED",
		"client_id":  clientID,
		"agent_id":   agentID,
		"reason":     reason,
		"timestamp":  time.Now().UTC(),
	}

	notificationBytes, _ := json.Marshal(notification)
	headers := map[string]string{
		"correlation_id": uuid.NewString(),
		"event_type":     "agent_disabled",
	}

	h.kafkaProducer.Produce(ctx, "system.notifications.admin", headers,
		[]byte(agentID), notificationBytes)
}

// HandleUpdateInstanceConfig updates the configuration of a specific agent instance.
func (h *AgentHandlers) HandleUpdateInstanceConfig(c *gin.Context) {
	agentID := c.Param("agent_id")
	clientID := c.Param("client_id")

	var req struct {
		Config map[string]interface{} `json:"config" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body: " + err.Error()})
		return
	}

	// Now you can call the repository method directly from the handler
	err := h.personaRepo.AdminUpdateInstanceConfig(c.Request.Context(), clientID, agentID, req.Config)
	if err != nil {
		h.logger.Error("Failed to update instance config", zap.Error(err), zap.String("agent_id", agentID))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update instance config"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":   "Configuration updated successfully.",
		"agent_id":  agentID,
		"client_id": clientID,
	})
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/instance_swagger.go
package handlers

// NOTE: This file contains swagger annotations for the instance handlers.
// All types are defined in instance.go

// HandleCreateInstance godoc
// @Summary      Create instance
// @Description  Creates a new persona instance from a template
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        request body handlers.CreateInstanceRequest true "Instance creation details"
// @Success      201 {object} models.Persona "Instance created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Could not create instance"
// @Router       /api/v1/personas/instances [post]
// @Security     Bearer
// @ID           createInstance

// HandleListInstances godoc
// @Summary      List instances
// @Description  Returns all persona instances for the authenticated user
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Success      200 {object} handlers.InstanceListResponse "List of instances retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Could not retrieve instances"
// @Router       /api/v1/personas/instances [get]
// @Security     Bearer
// @ID           listInstances

// HandleGetInstance godoc
// @Summary      Get instance
// @Description  Returns a specific persona instance by ID
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        id path string true "Instance ID"
// @Success      200 {object} models.Persona "Instance details retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "Instance not found"
// @Router       /api/v1/personas/instances/{id} [get]
// @Security     Bearer
// @ID           getInstance

// HandleUpdateInstance godoc
// @Summary      Update instance
// @Description  Updates an existing persona instance
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        id path string true "Instance ID"
// @Param        request body handlers.UpdateInstanceRequest true "Instance update details"
// @Success      200 {object} models.Persona "Instance updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Failed to update instance"
// @Router       /api/v1/personas/instances/{id} [patch]
// @Security     Bearer
// @ID           updateInstance

// HandleDeleteInstance godoc
// @Summary      Delete instance
// @Description  Deletes a persona instance
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        id path string true "Instance ID"
// @Success      204 {string} string "Instance deleted successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Failed to delete instance"
// @Router       /api/v1/personas/instances/{id} [delete]
// @Security     Bearer
// @ID           deleteInstance
-------------------------------------------------
filepath = ./internal/core-manager/handlers/template_swagger.go
package handlers

// NOTE: This file contains swagger annotations for the template handlers.
// All types are defined in template.go

// HandleCreateTemplate godoc
// @Summary      Create template
// @Description  Creates a new persona template (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        request body handlers.CreateTemplateRequest true "Template creation details"
// @Success      201 {object} models.Persona "Template created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to create template"
// @Router       /api/v1/templates [post]
// @Security     Bearer
// @ID           createTemplate

// HandleListTemplates godoc
// @Summary      List templates
// @Description  Returns all available persona templates (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Success      200 {object} handlers.TemplateListResponse "List of templates retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to retrieve templates"
// @Router       /api/v1/templates [get]
// @Security     Bearer
// @ID           listTemplates

// HandleGetTemplate godoc
// @Summary      Get template
// @Description  Returns a specific persona template by ID (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        id path string true "Template ID"
// @Success      200 {object} models.Persona "Template details retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      404 {object} map[string]interface{} "Template not found"
// @Router       /api/v1/templates/{id} [get]
// @Security     Bearer
// @ID           getTemplate

// HandleUpdateTemplate godoc
// @Summary      Update template
// @Description  Updates an existing persona template (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        id path string true "Template ID"
// @Param        request body handlers.CreateTemplateRequest true "Template update details"
// @Success      200 {object} models.Persona "Template updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to update template"
// @Router       /api/v1/templates/{id} [put]
// @Security     Bearer
// @ID           updateTemplate

// HandleDeleteTemplate godoc
// @Summary      Delete template
// @Description  Deletes a persona template (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        id path string true "Template ID"
// @Success      204 {string} string "Template deleted successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to delete template"
// @Router       /api/v1/templates/{id} [delete]
// @Security     Bearer
// @ID           deleteTemplate
-------------------------------------------------
filepath = ./internal/core-manager/handlers/health.go
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/platform/config"
	"go.uber.org/zap"
)

// HealthHandler handles health check endpoints
type HealthHandler struct {
	cfg    *config.ServiceConfig
	logger *zap.Logger
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(cfg *config.ServiceConfig, logger *zap.Logger) *HealthHandler {
	return &HealthHandler{
		cfg:    cfg,
		logger: logger,
	}
}

// HealthResponse represents the health check response
type HealthResponse struct {
	Status  string `json:"status" example:"healthy"`
	Service string `json:"service" example:"core-manager"`
	Version string `json:"version" example:"1.0.0"`
}

// HandleHealth returns the service health status
func (h *HealthHandler) HandleHealth(c *gin.Context) {
	response := HealthResponse{
		Status:  "healthy",
		Service: h.cfg.ServiceInfo.Name,
		Version: h.cfg.ServiceInfo.Version,
	}
	c.JSON(http.StatusOK, response)
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/template.go
// FILE: internal/core-manager/handlers/template.go
package handlers

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/gqls/agentchassis/pkg/models"
	"go.uber.org/zap"
)

// TemplateHandler handles template-related operations
type TemplateHandler struct {
	personaRepo models.PersonaRepository
	logger      *zap.Logger
}

// NewTemplateHandler creates a new template handler
func NewTemplateHandler(personaRepo models.PersonaRepository, logger *zap.Logger) *TemplateHandler {
	return &TemplateHandler{
		personaRepo: personaRepo,
		logger:      logger,
	}
}

// CreateTemplateRequest represents a request to create a template
type CreateTemplateRequest struct {
	Name        string                 `json:"name" binding:"required" example:"Customer Support Agent"`
	Description string                 `json:"description" example:"A helpful customer support agent template"`
	Category    string                 `json:"category" binding:"required" example:"support"`
	Config      map[string]interface{} `json:"config" binding:"required"`
}

// TemplateListResponse represents a list of templates
type TemplateListResponse struct {
	Templates []models.Persona `json:"templates"`
	Count     int              `json:"count" example:"10"`
}

// HandleCreateTemplate creates a new template
func (h *TemplateHandler) HandleCreateTemplate(c *gin.Context) {
	var req CreateTemplateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body: " + err.Error()})
		return
	}

	template := &models.Persona{
		ID:          uuid.New(),
		Name:        req.Name,
		Description: req.Description,
		Category:    req.Category,
		Config:      req.Config,
		IsTemplate:  true,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	createdTemplate, err := h.personaRepo.CreateTemplate(c.Request.Context(), template)
	if err != nil {
		h.logger.Error("Failed to create template", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create template"})
		return
	}

	c.JSON(http.StatusCreated, createdTemplate)
}

// HandleListTemplates returns all templates
func (h *TemplateHandler) HandleListTemplates(c *gin.Context) {
	templates, err := h.personaRepo.ListTemplates(c.Request.Context())
	if err != nil {
		h.logger.Error("Failed to list templates", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve templates"})
		return
	}

	response := TemplateListResponse{
		Templates: templates,
		Count:     len(templates),
	}
	c.JSON(http.StatusOK, response)
}

// HandleGetTemplate returns a specific template
func (h *TemplateHandler) HandleGetTemplate(c *gin.Context) {
	templateID := c.Param("id")
	template, err := h.personaRepo.GetTemplateByID(c.Request.Context(), templateID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Template not found"})
		return
	}
	c.JSON(http.StatusOK, template)
}

// HandleUpdateTemplate updates an existing template
func (h *TemplateHandler) HandleUpdateTemplate(c *gin.Context) {
	templateID := c.Param("id")

	var req CreateTemplateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	template := &models.Persona{
		ID:          uuid.MustParse(templateID),
		Name:        req.Name,
		Description: req.Description,
		Category:    req.Category,
		Config:      req.Config,
		UpdatedAt:   time.Now(),
	}

	updatedTemplate, err := h.personaRepo.UpdateTemplate(c.Request.Context(), template)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update template"})
		return
	}
	c.JSON(http.StatusOK, updatedTemplate)
}

// HandleDeleteTemplate deletes a template
func (h *TemplateHandler) HandleDeleteTemplate(c *gin.Context) {
	templateID := c.Param("id")
	if err := h.personaRepo.DeleteTemplate(c.Request.Context(), templateID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete template"})
		return
	}
	c.Status(http.StatusNoContent)
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/instance.go
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/core-manager/middleware"
	"github.com/gqls/agentchassis/pkg/models"
	"go.uber.org/zap"
)

// InstanceHandler handles persona instance operations
type InstanceHandler struct {
	personaRepo models.PersonaRepository
	logger      *zap.Logger
}

// NewInstanceHandler creates a new instance handler
func NewInstanceHandler(personaRepo models.PersonaRepository, logger *zap.Logger) *InstanceHandler {
	return &InstanceHandler{
		personaRepo: personaRepo,
		logger:      logger,
	}
}

// CreateInstanceRequest represents a request to create an instance
type CreateInstanceRequest struct {
	TemplateID   string `json:"template_id" binding:"required,uuid" example:"123e4567-e89b-12d3-a456-426614174000"`
	InstanceName string `json:"instance_name" binding:"required" example:"My Support Agent"`
}

// UpdateInstanceRequest represents a request to update an instance
type UpdateInstanceRequest struct {
	Name   *string                `json:"name,omitempty" example:"Updated Agent Name"`
	Config map[string]interface{} `json:"config,omitempty"`
}

// InstanceListResponse represents a list of instances
type InstanceListResponse struct {
	Instances []models.Persona `json:"instances"`
	Count     int              `json:"count" example:"5"`
}

// HandleCreateInstance creates a new instance from a template
func (h *InstanceHandler) HandleCreateInstance(c *gin.Context) {
	claims := c.MustGet("user_claims").(*middleware.AuthClaims)

	var req CreateInstanceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	instance, err := h.personaRepo.CreateInstanceFromTemplate(c.Request.Context(),
		req.TemplateID, claims.UserID, req.InstanceName)
	if err != nil {
		h.logger.Error("Failed to create instance", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not create instance"})
		return
	}
	c.JSON(http.StatusCreated, instance)
}

// HandleGetInstance returns a specific instance
func (h *InstanceHandler) HandleGetInstance(c *gin.Context) {
	instanceID := c.Param("id")
	instance, err := h.personaRepo.GetInstanceByID(c.Request.Context(), instanceID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Instance not found"})
		return
	}
	c.JSON(http.StatusOK, instance)
}

// HandleListInstances returns all instances for the current user
func (h *InstanceHandler) HandleListInstances(c *gin.Context) {
	claims := c.MustGet("user_claims").(*middleware.AuthClaims)
	instances, err := h.personaRepo.ListInstances(c.Request.Context(), claims.UserID)
	if err != nil {
		h.logger.Error("Failed to list instances", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not retrieve instances"})
		return
	}

	response := InstanceListResponse{
		Instances: instances,
		Count:     len(instances),
	}
	c.JSON(http.StatusOK, response)
}

// HandleUpdateInstance updates an existing instance
func (h *InstanceHandler) HandleUpdateInstance(c *gin.Context) {
	instanceID := c.Param("id")

	var req UpdateInstanceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	updatedInstance, err := h.personaRepo.UpdateInstance(c.Request.Context(), instanceID, req.Name, req.Config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update instance"})
		return
	}
	c.JSON(http.StatusOK, updatedInstance)
}

// HandleDeleteInstance deletes an instance
func (h *InstanceHandler) HandleDeleteInstance(c *gin.Context) {
	instanceID := c.Param("id")
	if err := h.personaRepo.DeleteInstance(c.Request.Context(), instanceID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete instance"})
		return
	}
	c.Status(http.StatusNoContent)
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/health_swagger.go
package handlers

// NOTE: This file contains swagger annotations for the health handler.
// All types are defined in health.go

// HandleHealth godoc
// @Summary      Health check
// @Description  Returns the health status of the Core Manager service
// @Tags         System
// @Accept       json
// @Produce      json
// @Success      200 {object} handlers.HealthResponse "Service is healthy"
// @Router       /health [get]
// @ID           healthCheck
-------------------------------------------------
filepath = ./internal/core-manager/middleware/auth.go
// FILE: internal/core-manager/middleware/auth.go
package middleware

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/gqls/agentchassis/platform/config"
	"go.uber.org/zap"
)

// AuthClaims represents the JWT claims
type AuthClaims struct {
	UserID      string   `json:"user_id"`
	Email       string   `json:"email"`
	ClientID    string   `json:"client_id"`
	Role        string   `json:"role"`
	Tier        string   `json:"tier"`
	Permissions []string `json:"permissions,omitempty"`
	jwt.RegisteredClaims
}

// AuthMiddlewareConfig holds configuration for auth middleware
type AuthMiddlewareConfig struct {
	JWTSecret      []byte
	AuthServiceURL string
	Logger         *zap.Logger
}

// NewAuthMiddlewareConfig creates auth middleware configuration from service config
func NewAuthMiddlewareConfig(cfg *config.ServiceConfig, logger *zap.Logger) (*AuthMiddlewareConfig, error) {
	// Get JWT secret from environment
	jwtSecretEnvVar := "JWT_SECRET_KEY"
	if cfg.Custom != nil {
		if envVar, ok := cfg.Custom["jwt_secret_env_var"].(string); ok {
			jwtSecretEnvVar = envVar
		}
	}

	jwtSecret := os.Getenv(jwtSecretEnvVar)
	if jwtSecret == "" {
		return nil, fmt.Errorf("JWT secret not found in environment variable %s", jwtSecretEnvVar)
	}

	// Get auth service URL
	authServiceURL := "http://auth-service:8081"
	if cfg.Custom != nil {
		if url, ok := cfg.Custom["auth_service_url"].(string); ok {
			authServiceURL = url
		}
	}

	return &AuthMiddlewareConfig{
		JWTSecret:      []byte(jwtSecret),
		AuthServiceURL: authServiceURL,
		Logger:         logger,
	}, nil
}

// AuthMiddleware validates JWT tokens
func AuthMiddleware(config *AuthMiddlewareConfig) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			// Also check X-Authorization header (for proxied requests)
			authHeader = c.GetHeader("X-Authorization")
		}

		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		tokenString := strings.Replace(authHeader, "Bearer ", "", 1)

		// Parse and validate token
		token, err := jwt.ParseWithClaims(tokenString, &AuthClaims{}, func(token *jwt.Token) (interface{}, error) {
			// Validate signing method
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return config.JWTSecret, nil
		})

		if err != nil {
			config.Logger.Debug("Token validation failed", zap.Error(err))

			// Optionally validate with auth service
			if isValid := validateWithAuthService(config, tokenString); !isValid {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
				c.Abort()
				return
			}
		}

		if claims, ok := token.Claims.(*AuthClaims); ok && token.Valid {
			// Set user context
			c.Set("user_claims", claims)
			c.Set("user_id", claims.UserID)
			c.Set("client_id", claims.ClientID)
			c.Set("user_email", claims.Email)
			c.Set("user_role", claims.Role)
			c.Set("user_tier", claims.Tier)
			c.Set("user_permissions", claims.Permissions)
			c.Next()
		} else {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			c.Abort()
			return
		}
	}
}

// validateWithAuthService validates token with auth service (optional fallback)
func validateWithAuthService(config *AuthMiddlewareConfig, token string) bool {
	client := &http.Client{Timeout: 5 * time.Second}

	req, err := http.NewRequest("POST", config.AuthServiceURL+"/api/v1/auth/validate", nil)
	if err != nil {
		config.Logger.Error("Failed to create validation request", zap.Error(err))
		return false
	}

	req.Header.Set("Authorization", "Bearer "+token)

	resp, err := client.Do(req)
	if err != nil {
		config.Logger.Error("Failed to validate with auth service", zap.Error(err))
		return false
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return false
	}

	var result struct {
		Valid bool `json:"valid"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return false
	}

	return result.Valid
}

// TenantMiddleware sets up tenant context
func TenantMiddleware(logger *zap.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		claims, exists := c.Get("user_claims")
		if !exists {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "No user claims found"})
			c.Abort()
			return
		}

		authClaims, ok := claims.(*AuthClaims)
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid claims type"})
			c.Abort()
			return
		}

		// Set tenant context for database operations
		c.Set("client_id", authClaims.ClientID)
		c.Set("user_id", authClaims.UserID)

		c.Next()
	}
}

// AdminOnly restricts access to admin users
func AdminOnly() gin.HandlerFunc {
	return func(c *gin.Context) {
		role, exists := c.Get("user_role")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "No role found"})
			c.Abort()
			return
		}

		if role != "admin" {
			c.JSON(http.StatusForbidden, gin.H{"error": "Admin access required"})
			c.Abort()
			return
		}

		c.Next()
	}
}
-------------------------------------------------
filepath = ./internal/core-manager/API.md
# Core Manager Internal API Documentation

## Overview

The Core Manager service is responsible for managing persona templates and instances. It serves as the central management hub for all persona-related operations.

## Internal HTTP Endpoints

### Health Check
```
GET /internal/health
```

Returns the health status of the service.

**Response:**
```json
{
  "status": "healthy",
  "service": "core-manager",
  "version": "1.0.0",
  "database": "connected"
}
```

## External HTTP Endpoints (via Auth Service Gateway)

These endpoints are accessed through the auth-service gateway with authentication.

### Persona Templates

#### List Templates
```
GET /api/v1/templates
```

Returns all available persona templates.

**Required Role:** Admin

**Response:**
```json
{
  "templates": [
    {
      "id": "uuid",
      "name": "Copywriter",
      "description": "Creates compelling marketing copy",
      "category": "data-driven",
      "config": {
        "model": "claude-3-sonnet",
        "temperature": 0.7
      },
      "is_active": true,
      "created_at": "2024-01-01T00:00:00Z",
      "updated_at": "2024-01-01T00:00:00Z"
    }
  ],
  "count": 1
}
```

### Persona Instances

#### Create Instance
```
POST /api/v1/personas/instances
```

Creates a new persona instance from a template.

**Request:**
```json
{
  "template_id": "template-uuid",
  "name": "My Marketing Assistant",
  "project_id": "project-uuid",
  "config": {
    "custom_prompt": "Focus on B2B technology companies"
  }
}
```

**Response:**
```json
{
  "id": "instance-uuid",
  "template_id": "template-uuid",
  "name": "My Marketing Assistant",
  "owner_user_id": "user-uuid",
  "config": {
    "model": "claude-3-sonnet",
    "temperature": 0.7,
    "custom_prompt": "Focus on B2B technology companies"
  },
  "is_active": true,
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-01T00:00:00Z"
}
```

## Kafka Topics

### Consumed Topics

#### system.personas.commands
Commands for persona management operations.

**Message Format:**
```json
{
  "action": "create_instance|update_instance|delete_instance",
  "data": {
    // Action-specific data
  }
}
```

**Required Headers:**
- `correlation_id`: Unique request identifier
- `request_id`: Request tracking ID
- `client_id`: Client identifier
- `user_id`: User performing the action

### Produced Topics

#### system.personas.events
Events related to persona lifecycle.

**Message Format:**
```json
{
  "event": "instance_created|instance_updated|instance_deleted",
  "data": {
    "instance_id": "uuid",
    "template_id": "uuid",
    "user_id": "uuid",
    // Event-specific data
  },
  "timestamp": "2024-01-01T00:00:00Z"
}
```

## Database Schema

The Core Manager uses the `clients` PostgreSQL database with client-specific schemas.

### Global Tables

#### agent_definitions
```sql
CREATE TABLE agent_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(100) NOT NULL UNIQUE,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL,
    default_config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);
```

### Client-Specific Tables (in schema `client_{client_id}`)

#### agent_instances
```sql
CREATE TABLE agent_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id UUID NOT NULL,
    owner_user_id VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

## Environment Variables

```bash
# Database
CLIENTS_DB_HOST=postgres-clients
CLIENTS_DB_PORT=5432
CLIENTS_DB_NAME=clients_db
CLIENTS_DB_USER=clients_user
CLIENTS_DB_PASSWORD=<password>

# Templates Database
TEMPLATES_DB_HOST=postgres-templates
TEMPLATES_DB_PORT=5432
TEMPLATES_DB_NAME=templates_db
TEMPLATES_DB_USER=templates_user
TEMPLATES_DB_PASSWORD=<password>

# Kafka
KAFKA_BROKERS=kafka-0:9092,kafka-1:9092,kafka-2:9092

# Service
SERVICE_PORT=8088
LOG_LEVEL=info
```

## Integration Notes

### For Auth Service
- All requests should include user context headers
- Validate quota limits before creating instances
- Check user permissions for admin operations

### For Agent Services
- Subscribe to `system.personas.events` for instance lifecycle events
- Use instance configuration when processing requests
- Report usage metrics back to core-manager

### Error Handling
The service returns standard HTTP status codes:
- 200: Success
- 201: Created
- 400: Bad Request
- 401: Unauthorized
- 403: Forbidden (quota exceeded or insufficient permissions)
- 404: Not Found
- 500: Internal Server Error

Error responses follow the format:
```json
{
  "error": {
    "code": "PERSONA_001",
    "message": "Human-readable error message",
    "details": {
      // Additional context
    }
  }
}
```-------------------------------------------------
filepath = ./internal/core-manager/database/personas.go
// FILE: internal/core-manager/database/personas.go

package database

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/gqls/agentchassis/pkg/models"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

type PersonaRepository struct {
	templatesDB *pgxpool.Pool
	clientsDB   *pgxpool.Pool
	logger      *zap.Logger
}

// NewPersonaRepository creates a new repository instance
func NewPersonaRepository(templatesDB, clientsDB *pgxpool.Pool, logger *zap.Logger) *PersonaRepository {
	return &PersonaRepository{
		templatesDB: templatesDB,
		clientsDB:   clientsDB,
		logger:      logger,
	}
}

// ClientsDB returns the clients database pool
func (r *PersonaRepository) ClientsDB() *pgxpool.Pool {
	return r.clientsDB
}

// TemplatesDB returns the templates database pool
func (r *PersonaRepository) TemplatesDB() *pgxpool.Pool {
	return r.templatesDB
}

// Template Methods

func (r *PersonaRepository) CreateTemplate(ctx context.Context, template *models.Persona) (*models.Persona, error) {
	r.logger.Info("Creating new persona template", zap.String("name", template.Name))

	configJSON, _ := json.Marshal(template.Config)

	query := `
        INSERT INTO persona_templates (id, name, description, category, config, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id
    `

	err := r.templatesDB.QueryRow(ctx, query,
		template.ID,
		template.Name,
		template.Description,
		template.Category,
		configJSON,
		true,
		template.CreatedAt,
		template.UpdatedAt,
	).Scan(&template.ID)

	if err != nil {
		r.logger.Error("Failed to create template", zap.Error(err))
		return nil, fmt.Errorf("failed to create template: %w", err)
	}

	return template, nil
}

func (r *PersonaRepository) GetTemplateByID(ctx context.Context, id string) (*models.Persona, error) {
	r.logger.Info("Getting template by ID", zap.String("id", id))

	var template models.Persona
	var configJSON []byte

	query := `
        SELECT id, name, description, category, config, is_active, created_at, updated_at
        FROM persona_templates
        WHERE id = $1 AND is_active = true
    `

	err := r.templatesDB.QueryRow(ctx, query, id).Scan(
		&template.ID,
		&template.Name,
		&template.Description,
		&template.Category,
		&configJSON,
		&template.IsActive,
		&template.CreatedAt,
		&template.UpdatedAt,
	)

	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, fmt.Errorf("template not found")
		}
		return nil, fmt.Errorf("failed to get template: %w", err)
	}

	json.Unmarshal(configJSON, &template.Config)
	template.IsTemplate = true

	return &template, nil
}

func (r *PersonaRepository) ListTemplates(ctx context.Context) ([]models.Persona, error) {
	r.logger.Info("Listing all templates")

	query := `
        SELECT id, name, description, category, config, is_active, created_at, updated_at
        FROM persona_templates
        WHERE is_active = true
        ORDER BY category, name
    `

	rows, err := r.templatesDB.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to list templates: %w", err)
	}
	defer rows.Close()

	var templates []models.Persona
	for rows.Next() {
		var template models.Persona
		var configJSON []byte

		err := rows.Scan(
			&template.ID,
			&template.Name,
			&template.Description,
			&template.Category,
			&configJSON,
			&template.IsActive,
			&template.CreatedAt,
			&template.UpdatedAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan template row", zap.Error(err))
			continue
		}

		json.Unmarshal(configJSON, &template.Config)
		template.IsTemplate = true
		templates = append(templates, template)
	}

	return templates, nil
}

func (r *PersonaRepository) UpdateTemplate(ctx context.Context, template *models.Persona) (*models.Persona, error) {
	r.logger.Info("Updating template", zap.String("id", template.ID.String()))

	configJSON, _ := json.Marshal(template.Config)

	query := `
        UPDATE persona_templates
        SET name = $2, description = $3, category = $4, config = $5, updated_at = $6
        WHERE id = $1
        RETURNING updated_at
    `

	err := r.templatesDB.QueryRow(ctx, query,
		template.ID,
		template.Name,
		template.Description,
		template.Category,
		configJSON,
		time.Now(),
	).Scan(&template.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to update template: %w", err)
	}

	return template, nil
}

func (r *PersonaRepository) DeleteTemplate(ctx context.Context, id string) error {
	r.logger.Info("Deleting template", zap.String("id", id))

	// Soft delete
	query := `UPDATE persona_templates SET is_active = false, updated_at = $2 WHERE id = $1`

	_, err := r.templatesDB.Exec(ctx, query, id, time.Now())
	if err != nil {
		return fmt.Errorf("failed to delete template: %w", err)
	}

	return nil
}

// Instance Methods

func (r *PersonaRepository) CreateInstanceFromTemplate(ctx context.Context, templateID string, userID string, instanceName string) (*models.Persona, error) {
	r.logger.Info("Creating instance from template",
		zap.String("templateID", templateID),
		zap.String("userID", userID))

	// Get client ID from context
	clientID, ok := ctx.Value("client_id").(string)
	if !ok {
		return nil, fmt.Errorf("client_id not found in context")
	}

	// First, fetch the template
	template, err := r.GetTemplateByID(ctx, templateID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch template: %w", err)
	}

	// Create the instance
	instance := &models.Persona{
		ID:          uuid.New(),
		Name:        instanceName,
		Description: template.Description,
		Category:    template.Category,
		Config:      template.Config,
		IsTemplate:  false,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	configJSON, _ := json.Marshal(instance.Config)

	// Use client-specific schema
	query := fmt.Sprintf(`
        INSERT INTO client_%s.agent_instances 
        (id, template_id, owner_user_id, name, config, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `, clientID)

	_, err = r.clientsDB.Exec(ctx, query,
		instance.ID,
		templateID,
		userID,
		instance.Name,
		configJSON,
		true,
		instance.CreatedAt,
		instance.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create instance: %w", err)
	}

	return instance, nil
}

func (r *PersonaRepository) GetInstanceByID(ctx context.Context, id string) (*models.Persona, error) {
	clientID, _ := ctx.Value("client_id").(string)

	var instance models.Persona
	var configJSON []byte

	query := fmt.Sprintf(`
        SELECT id, name, config, is_active, created_at, updated_at
        FROM client_%s.agent_instances
        WHERE id = $1 AND is_active = true
    `, clientID)

	err := r.clientsDB.QueryRow(ctx, query, id).Scan(
		&instance.ID,
		&instance.Name,
		&configJSON,
		&instance.IsActive,
		&instance.CreatedAt,
		&instance.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to get instance: %w", err)
	}

	json.Unmarshal(configJSON, &instance.Config)
	return &instance, nil
}

func (r *PersonaRepository) ListInstances(ctx context.Context, userID string) ([]models.Persona, error) {
	clientID, _ := ctx.Value("client_id").(string)

	query := fmt.Sprintf(`
        SELECT id, name, config, is_active, created_at, updated_at
        FROM client_%s.agent_instances
        WHERE owner_user_id = $1 AND is_active = true
        ORDER BY created_at DESC
    `, clientID)

	rows, err := r.clientsDB.Query(ctx, query, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to list instances: %w", err)
	}
	defer rows.Close()

	var instances []models.Persona
	for rows.Next() {
		var instance models.Persona
		var configJSON []byte

		err := rows.Scan(
			&instance.ID,
			&instance.Name,
			&configJSON,
			&instance.IsActive,
			&instance.CreatedAt,
			&instance.UpdatedAt,
		)
		if err != nil {
			continue
		}

		json.Unmarshal(configJSON, &instance.Config)
		instances = append(instances, instance)
	}

	return instances, nil
}

func (r *PersonaRepository) UpdateInstance(ctx context.Context, id string, name *string, config map[string]interface{}) (*models.Persona, error) {
	clientID, _ := ctx.Value("client_id").(string)

	// First get the current instance
	instance, err := r.GetInstanceByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Update fields
	if name != nil {
		instance.Name = *name
	}
	if config != nil {
		// Merge configs
		for k, v := range config {
			instance.Config[k] = v
		}
	}

	configJSON, _ := json.Marshal(instance.Config)

	query := fmt.Sprintf(`
        UPDATE client_%s.agent_instances
        SET name = $2, config = $3, updated_at = $4
        WHERE id = $1
    `, clientID)

	_, err = r.clientsDB.Exec(ctx, query, id, instance.Name, configJSON, time.Now())
	if err != nil {
		return nil, fmt.Errorf("failed to update instance: %w", err)
	}

	return instance, nil
}

func (r *PersonaRepository) DeleteInstance(ctx context.Context, id string) error {
	clientID, _ := ctx.Value("client_id").(string)

	query := fmt.Sprintf(`
        UPDATE client_%s.agent_instances
        SET is_active = false, updated_at = $2
        WHERE id = $1
    `, clientID)

	_, err := r.clientsDB.Exec(ctx, query, id, time.Now())
	if err != nil {
		return fmt.Errorf("failed to delete instance: %w", err)
	}

	return nil
}

// AdminUpdateInstanceConfig allows an admin to update an instance's config
func (r *PersonaRepository) AdminUpdateInstanceConfig(ctx context.Context, clientID, instanceID string, config map[string]interface{}) error {
	r.logger.Info("Admin updating instance config", zap.String("instance_id", instanceID), zap.String("client_id", clientID))

	configJSON, err := json.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	query := fmt.Sprintf(`
        UPDATE client_%s.agent_instances
        SET config = $2, updated_at = NOW()
        WHERE id = $1
    `, clientID)

	res, err := r.clientsDB.Exec(ctx, query, instanceID, configJSON)
	if err != nil {
		return fmt.Errorf("failed to execute update: %w", err)
	}

	if res.RowsAffected() == 0 {
		return fmt.Errorf("instance not found")
	}

	return nil
}
-------------------------------------------------
filepath = ./pkg/models/database.go
// FILE: pkg/models/database.go
package models

import (
	"context"
	"github.com/google/uuid"
	"time"
)

// Persona represents both templates and instances
type Persona struct {
	ID          uuid.UUID              `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Category    string                 `json:"category"`
	Config      map[string]interface{} `json:"config"`
	IsTemplate  bool                   `json:"is_template"`
	IsActive    bool                   `json:"is_active"`
	CreatedAt   time.Time              `json:"created_at"`
	UpdatedAt   time.Time              `json:"updated_at"`
}

// PersonaRepository defines the interface for persona data access
type PersonaRepository interface {
	// Template methods
	CreateTemplate(ctx context.Context, template *Persona) (*Persona, error)
	GetTemplateByID(ctx context.Context, id string) (*Persona, error)
	ListTemplates(ctx context.Context) ([]Persona, error)
	UpdateTemplate(ctx context.Context, template *Persona) (*Persona, error)
	DeleteTemplate(ctx context.Context, id string) error

	// Instance methods
	CreateInstanceFromTemplate(ctx context.Context, templateID string, userID string, instanceName string) (*Persona, error)
	GetInstanceByID(ctx context.Context, id string) (*Persona, error)
	ListInstances(ctx context.Context, userID string) ([]Persona, error)
	UpdateInstance(ctx context.Context, id string, name *string, config map[string]interface{}) (*Persona, error)
	DeleteInstance(ctx context.Context, id string) error

	AdminUpdateInstanceConfig(ctx context.Context, clientID, instanceID string, config map[string]interface{}) error
}
-------------------------------------------------
filepath = ./pkg/models/contracts.go
// FILE: pkg/models/contracts.go (updated)
package models

import "time"

// AgentConfig defines the "mind" of an agent, loaded from the database
type AgentConfig struct {
	AgentID      string                 `json:"agent_id"`
	AgentType    string                 `json:"agent_type"`
	Version      int                    `json:"version"`
	CoreLogic    map[string]interface{} `json:"core_logic"`
	Workflow     WorkflowPlan           `json:"workflow"`
	MemoryConfig MemoryConfiguration    `json:"memory_config,omitempty"`
}

// MemoryConfiguration controls how the agent uses long-term memory
type MemoryConfiguration struct {
	Enabled            bool     `json:"enabled"`
	AutoStore          bool     `json:"auto_store"`
	AutoStoreThreshold float64  `json:"auto_store_threshold"`
	MaxMemories        int      `json:"max_memories"`
	RetrievalCount     int      `json:"retrieval_count"`
	EmbeddingModel     string   `json:"embedding_model"`
	IncludeTypes       []string `json:"include_types"`
}

// MemoryEntry represents a single memory to be stored
type MemoryEntry struct {
	Content   string                 `json:"content"`
	Type      string                 `json:"type"`
	Metadata  map[string]interface{} `json:"metadata"`
	Timestamp time.Time              `json:"timestamp"`
}

// WorkflowPlan defines the orchestration steps for an agent
type WorkflowPlan struct {
	StartStep string          `json:"start_step"`
	Steps     map[string]Step `json:"steps"`
}

// Step represents a single action or sub-workflow within a plan
type Step struct {
	Action       string    `json:"action"`
	Description  string    `json:"description"`
	Topic        string    `json:"topic,omitempty"`
	Dependencies []string  `json:"dependencies,omitempty"`
	NextStep     string    `json:"next_step,omitempty"`
	SubTasks     []SubTask `json:"sub_tasks,omitempty"`
	StoreMemory  bool      `json:"store_memory,omitempty"` // New field
}

// SubTask for fan-out operations
type SubTask struct {
	StepName string `json:"step_name"`
	Topic    string `json:"topic"`
}

// Standard message payloads
type TaskRequest struct {
	Action string                 `json:"action"`
	Data   map[string]interface{} `json:"data"`
}

type TaskResponse struct {
	Success bool                   `json:"success"`
	Data    map[string]interface{} `json:"data"`
	Error   string                 `json:"error,omitempty"`
}
-------------------------------------------------
filepath = ./configs/agent-chassis.yaml
# FILE: configs/agent-chassis.yaml
service_info:
  name: "agent-chassis"
  version: "1.0.0"
  environment: "development"

server:
  port: "8085"

logging:
  level: "info"

observability:
  tracing_endpoint: "otel-collector.monitoring.svc.cluster.local:4317"

infrastructure:
  kafka_brokers:
    - "kafka-0.kafka-headless:9092"
    - "kafka-1.kafka-headless:9092"
    - "kafka-2.kafka-headless:9092"

  clients_database:
    host: "postgres-clients.database.svc.cluster.local"
    port: 5432
    user: "clients_user"
    password_env_var: "CLIENTS_DB_PASSWORD"
    db_name: "clients_db"
    sslmode: "disable"

  templates_database:
    host: "postgres-templates.database.svc.cluster.local"
    port: 5432
    user: "templates_user"
    password_env_var: "TEMPLATES_DB_PASSWORD"
    db_name: "templates_db"
    sslmode: "disable"

  auth_database: {}

  object_storage:
    provider: "s3"
    endpoint: "http://minio.storage.svc.cluster.local:9000"
    bucket: "agent-artifacts"
    access_key_env_var: "MINIO_ACCESS_KEY"
    secret_key_env_var: "MINIO_SECRET_KEY"-------------------------------------------------
filepath = ./configs/web-search-adapter.yaml
// FILE: configs/web-search-adapter.yaml
service_info:
  name: "web-search-adapter"
  version: "1.0.0"
  environment: "development"

server:
  port: "8083"

logging:
  level: "info"

infrastructure:
  kafka_brokers:
    - "kafka-0.kafka-headless:9092"
    - "kafka-1.kafka-headless:9092"
    - "kafka-2.kafka-headless:9092"

  clients_database: {}
  templates_database: {}
  auth_database: {}
  object_storage: {}

custom:
  search_provider: "serpapi"
  max_results_default: 10
  timeout_seconds: 30-------------------------------------------------
filepath = ./configs/auth-service.yaml
# FILE: configs/auth-service.yaml
service_info:
  name: "personae-auth-service"
  version: "1.1.0"
  environment: "development"

server:
  port: "8081"

logging:
  level: "debug"

observability:
  tracing_endpoint: "otel-collector.monitoring.svc.cluster.local:4317"

infrastructure:
  auth_database:
    host: "mysql-auth.database.svc.cluster.local"
    port: 3306
    user: "auth_user"
    password_env_var: "AUTH_DB_PASSWORD"
    db_name: "auth_db"
    ssl_mode: "disable"
  
  kafka_brokers: []
  clients_database: {}
  templates_database: {}
  object_storage: {}

custom:
  jwt_secret_key_env_var: "JWT_SECRET_KEY"
  jwt_expiry_access_minutes: 60
  allowed_origins:
    - "http://localhost:3000"
    - "http://localhost:8080"
  core_manager_url: "http://core-manager:8088"
  tiers:
    free_tier:
      max_personas_allowed: 1
      max_content_allowed: 5
    premium_tier:
      max_personas_allowed: -1
      max_content_allowed: -1-------------------------------------------------
filepath = ./configs/reasoning-agent.yaml
# FILE: configs/reasoning-agent.yaml
service_info:
  name: "reasoning-agent"
  version: "1.0.0"
  environment: "development"

server:
  port: "8082"

logging:
  level: "info"

infrastructure:
  kafka_brokers:
    - "kafka-0.kafka-headless:9092"
    - "kafka-1.kafka-headless:9092"
    - "kafka-2.kafka-headless:9092"

  clients_database: {}
  templates_database: {}
  auth_database: {}
  object_storage: {}

custom:
  ai_service:
    provider: "anthropic"
    model: "claude-3-opus-20240229"
    temperature: 0.2
    max_tokens: 2048
    api_key_env_var: "ANTHROPIC_API_KEY"-------------------------------------------------
filepath = ./configs/core-manager.yaml
# FILE: configs/core-manager.yaml
service_info:
  name: "core-manager"
  version: "1.0.0"
  environment: "development"

server:
  port: "8088"

logging:
  level: "info"

observability:
  tracing_endpoint: "otel-collector.monitoring.svc.cluster.local:4317"

infrastructure:
  kafka_brokers:
    - "kafka-0.kafka-headless:9092"
    - "kafka-1.kafka-headless:9092"
    - "kafka-2.kafka-headless:9092"
  
  clients_database:
    host: "postgres-clients.database.svc.cluster.local"
    port: 5432
    user: "clients_user"
    password_env_var: "CLIENTS_DB_PASSWORD"
    db_name: "clients_db"
    sslmode: "disable"
  
  templates_database:
    host: "postgres-templates.database.svc.cluster.local"
    port: 5432
    user: "templates_user"
    password_env_var: "TEMPLATES_DB_PASSWORD"
    db_name: "templates_db"
    sslmode: "disable"
  
  auth_database: {}
  
  object_storage:
    provider: "s3"
    endpoint: "http://minio.storage.svc.cluster.local:9000"
    bucket: "agent-artifacts"
    access_key_env_var: "MINIO_ACCESS_KEY"
    secret_key_env_var: "MINIO_SECRET_KEY"

custom:
  jwt_secret_env_var: "JWT_SECRET_KEY"  # Add this
  auth_service_url: "http://auth-service:8081"  # Add this for validation-------------------------------------------------
filepath = ./go.mod
// FILE: go.mod
module github.com/gqls/agentchassis

go 1.23.0

toolchain go1.24.4

require (
	github.com/DATA-DOG/go-sqlmock v1.5.2
	github.com/aws/aws-sdk-go-v2 v1.25.1
	github.com/aws/aws-sdk-go-v2/config v1.27.0
	github.com/aws/aws-sdk-go-v2/credentials v1.17.0
	github.com/aws/aws-sdk-go-v2/service/s3 v1.51.0
	github.com/gin-gonic/gin v1.10.1
	github.com/go-sql-driver/mysql v1.7.1
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.1
	github.com/jackc/pgx/v5 v5.5.5
	github.com/pgvector/pgvector-go v0.1.1
	github.com/prometheus/client_golang v1.22.0
	github.com/rs/cors v1.10.1
	github.com/segmentio/kafka-go v0.4.47
	github.com/sony/gobreaker v1.0.0
	github.com/spf13/viper v1.18.2
	github.com/stretchr/testify v1.10.0
	go.opentelemetry.io/otel v1.29.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.29.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
	go.opentelemetry.io/otel/sdk v1.29.0
	go.opentelemetry.io/otel/trace v1.29.0
	go.uber.org/zap v1.27.0
	golang.org/x/crypto v0.40.0
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.2.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.1 // indirect
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.15.0 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.1 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/sso v1.19.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.22.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.27.0 // indirect
	github.com/aws/smithy-go v1.20.1 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/bytedance/sonic v1.13.3 // indirect
	github.com/bytedance/sonic/loader v0.3.0 // indirect
	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/chenzhuoyu/base64x v0.0.0-20230717121745-296ad89f973d // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.7 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/fsnotify/fsnotify v1.7.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.9 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-openapi/jsonpointer v0.21.1 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/swag v0.23.1 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.27.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.20.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/puddle/v2 v2.2.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/compress v1.18.0 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pierrec/lz4/v4 v4.1.22 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/prometheus/client_model v0.6.1 // indirect
	github.com/prometheus/common v0.62.0 // indirect
	github.com/prometheus/procfs v0.15.1 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/sagikazarmark/locafero v0.4.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.11.0 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/swaggo/files v1.0.1 // indirect
	github.com/swaggo/gin-swagger v1.6.0 // indirect
	github.com/swaggo/swag v1.16.5 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.0 // indirect
	github.com/urfave/cli/v2 v2.27.7 // indirect
	github.com/xrash/smetrics v0.0.0-20250705151800-55b8f293f342 // indirect
	go.opentelemetry.io/otel/metric v1.29.0 // indirect
	go.opentelemetry.io/proto/otlp v1.3.1 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	go.yaml.in/yaml/v2 v2.4.2 // indirect
	golang.org/x/arch v0.19.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/mod v0.26.0 // indirect
	golang.org/x/net v0.42.0 // indirect
	golang.org/x/sync v0.16.0 // indirect
	golang.org/x/sys v0.34.0 // indirect
	golang.org/x/text v0.27.0 // indirect
	golang.org/x/tools v0.35.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240513163218-0867130af1f8 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240513163218-0867130af1f8 // indirect
	google.golang.org/grpc v1.64.1 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	sigs.k8s.io/yaml v1.5.0 // indirect
)
-------------------------------------------------
