filepath = ./cmd/core-manager/docs/swagger.yaml
info:
  contact: {}
paths: {}
swagger: "2.0"
-------------------------------------------------
filepath = ./cmd/core-manager/docs/swagger.json
{
    "swagger": "2.0",
    "info": {
        "contact": {}
    },
    "paths": {}
}-------------------------------------------------
filepath = ./cmd/core-manager/docs/docs.go
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {}
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "",
	Host:             "",
	BasePath:         "",
	Schemes:          []string{},
	Title:            "",
	Description:      "",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
-------------------------------------------------
filepath = ./cmd/core-manager/main.go
// FILE: cmd/core-manager/main.go
package main

import (
	"context"
	"errors"
	"flag"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gqls/agentchassis/internal/core-manager/api"

	// Platform packages
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/database"
	"github.com/gqls/agentchassis/platform/logger"

	"go.uber.org/zap"
)

func main() {
	// --- Step 1: Load Configuration using the Platform Library ---
	configPath := flag.String("config", "configs/core-manager.yaml", "Path to config file")
	flag.Parse()

	// Use the standardized platform loader
	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// --- Step 2: Initialize Logger using the Platform Library ---
	appLogger, err := logger.New(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	defer appLogger.Sync()

	appLogger.Info("Core Manager Service starting",
		zap.String("service_name", cfg.ServiceInfo.Name),
		zap.String("version", cfg.ServiceInfo.Version),
		zap.String("environment", cfg.ServiceInfo.Environment),
		zap.String("log_level", cfg.Logging.Level),
	)

	// Create a main context that can be cancelled for graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// --- Step 3: Initialize Database Connections using the Platform Library ---
	// 3a. Create connection pool for the Templates Database
	templatesPool, err := database.NewPostgresConnection(ctx, cfg.Infrastructure.TemplatesDatabase, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize templates database connection", zap.Error(err))
	}
	defer templatesPool.Close()

	// 3b. Create connection pool for the Clients Database
	clientsPool, err := database.NewPostgresConnection(ctx, cfg.Infrastructure.ClientsDatabase, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to initialize clients database connection", zap.Error(err))
	}
	defer clientsPool.Close()

	// --- Step 4: Initialize and Start the API Server ---
	apiServer, err := api.NewServer(ctx, cfg, appLogger, templatesPool, clientsPool)
	if err != nil {
		appLogger.Fatal("Failed to initialize API server", zap.Error(err))
	}

	// Run the server in a goroutine so it doesn't block
	go func() {
		appLogger.Info("Starting HTTP server", zap.String("address", apiServer.Address()))
		if err := apiServer.Start(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			appLogger.Error("API server failed", zap.Error(err))
			cancel() // Trigger shutdown on server error
		}
	}()

	// --- Step 5: Handle Graceful Shutdown ---
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	receivedSignal := <-sigCh
	appLogger.Info("Shutdown signal received", zap.String("signal", receivedSignal.String()))

	// Graceful shutdown with timeout
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer shutdownCancel()

	if err := apiServer.Shutdown(shutdownCtx); err != nil {
		appLogger.Error("Error during graceful shutdown", zap.Error(err))
	}

	appLogger.Info("Core Manager Service stopped")
}
-------------------------------------------------
filepath = ./internal/core-manager/api/server.go
package api

import (
	"context"
	"fmt"
	"github.com/gqls/agentchassis/internal/core-manager/handlers"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/core-manager/admin"
	"github.com/gqls/agentchassis/internal/core-manager/database"
	"github.com/gqls/agentchassis/internal/core-manager/middleware"
	"github.com/gqls/agentchassis/pkg/models"
	"github.com/gqls/agentchassis/platform/config"
	"github.com/gqls/agentchassis/platform/kafka"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// Server represents the Core Manager API server
type Server struct {
	ctx           context.Context
	cfg           *config.ServiceConfig
	logger        *zap.Logger
	router        *gin.Engine
	httpServer    *http.Server
	personaRepo   models.PersonaRepository
	kafkaProducer kafka.Producer
}

// NewServer creates a new API server instance
func NewServer(ctx context.Context, cfg *config.ServiceConfig, logger *zap.Logger, templatesDB, clientsDB *pgxpool.Pool) (*Server, error) {
	// Initialize repositories
	personaRepo := database.NewPersonaRepository(templatesDB, clientsDB, logger)

	// Create Gin router
	router := gin.New()
	router.Use(gin.Recovery())

	// Initialize Kafka Producer for admin handlers
	kafkaProducer, err := kafka.NewProducer(cfg.Infrastructure.KafkaBrokers, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create kafka producer for admin handlers: %w", err)
	}

	// Initialize auth middleware config
	authConfig, err := middleware.NewAuthMiddlewareConfig(cfg, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize auth middleware: %w", err)
	}

	server := &Server{
		ctx:           ctx,
		cfg:           cfg,
		logger:        logger,
		router:        router,
		personaRepo:   personaRepo,
		kafkaProducer: kafkaProducer,
	}

	// Setup routes with configured auth middleware
	server.setupRoutes(authConfig)

	// Create HTTP server
	server.httpServer = &http.Server{
		Addr:    ":" + cfg.Server.Port,
		Handler: router,
	}

	return server, nil
}

// setupRoutes configures all API routes with auth config
func (s *Server) setupRoutes(authConfig *middleware.AuthMiddlewareConfig) {
	// Initialize handlers
	healthHandler := handlers.NewHealthHandler(s.cfg, s.logger)
	templateHandler := handlers.NewTemplateHandler(s.personaRepo, s.logger)
	instanceHandler := handlers.NewInstanceHandler(s.personaRepo, s.logger)

	// Initialize admin handlers
	personaRepoImpl := s.personaRepo.(*database.PersonaRepository)
	clientHandlers := admin.NewClientHandlers(personaRepoImpl.ClientsDB(), s.logger)
	systemHandlers := admin.NewSystemHandlers(personaRepoImpl.ClientsDB(), personaRepoImpl.TemplatesDB(), s.kafkaProducer, s.logger)
	agentAdminHandlers := admin.NewAgentHandlers(personaRepoImpl.ClientsDB(), personaRepoImpl.TemplatesDB(), s.kafkaProducer, s.logger, s.personaRepo)

	// Health check (no auth)
	s.router.GET("/health", healthHandler.HandleHealth)

	// API v1 group with authentication
	apiV1 := s.router.Group("/api/v1")
	apiV1.Use(middleware.AuthMiddleware(authConfig))
	{
		// Template Management (Admin Only)
		templates := apiV1.Group("/templates")
		templates.Use(middleware.AdminOnly())
		{
			templates.POST("", templateHandler.HandleCreateTemplate)
			templates.GET("", templateHandler.HandleListTemplates)
			templates.GET("/:id", templateHandler.HandleGetTemplate)
			templates.PUT("/:id", templateHandler.HandleUpdateTemplate)
			templates.DELETE("/:id", templateHandler.HandleDeleteTemplate)
		}

		// Persona Instance Management (Tenant-scoped)
		instances := apiV1.Group("/personas/instances")
		instances.Use(middleware.TenantMiddleware(s.logger))
		{
			instances.POST("", instanceHandler.HandleCreateInstance)
			instances.GET("", instanceHandler.HandleListInstances)
			instances.GET("/:id", instanceHandler.HandleGetInstance)
			instances.PATCH("/:id", instanceHandler.HandleUpdateInstance)
			instances.DELETE("/:id", instanceHandler.HandleDeleteInstance)
		}

		// Admin Management (Admin Only)
		adminGroup := apiV1.Group("/admin")
		adminGroup.Use(middleware.AdminOnly())
		{
			// Client Management
			adminGroup.POST("/clients", clientHandlers.HandleCreateClient)
			adminGroup.GET("/clients", clientHandlers.HandleListClients)
			adminGroup.GET("/clients/:client_id/usage", clientHandlers.HandleGetClientUsage)

			// System & Workflow Management
			adminGroup.GET("/system/status", systemHandlers.HandleGetSystemStatus)
			adminGroup.GET("/system/kafka/topics", systemHandlers.HandleListKafkaTopics)
			adminGroup.GET("/workflows", systemHandlers.HandleListWorkflows)
			adminGroup.GET("/workflows/:correlation_id", systemHandlers.HandleGetWorkflow)
			adminGroup.POST("/workflows/:correlation_id/resume", systemHandlers.HandleResumeWorkflow)

			// Agent Definition Management
			adminGroup.GET("/agent-definitions", systemHandlers.HandleListAgentDefinitions)
			adminGroup.PUT("/agent-definitions/:type_name", systemHandlers.HandleUpdateAgentDefinition)

			// Agent Instance Management
			adminGroup.PUT("/clients/:client_id/instances/:instance_id/config", agentAdminHandlers.HandleUpdateInstanceConfig)
		}
	}
}

// Start starts the HTTP server
func (s *Server) Start() error {
	s.logger.Info("Starting Core Manager API server", zap.String("address", s.httpServer.Addr))
	return s.httpServer.ListenAndServe()
}

// Shutdown gracefully shuts down the server
func (s *Server) Shutdown(ctx context.Context) error {
	s.kafkaProducer.Close()
	return s.httpServer.Shutdown(ctx)
}

// Address returns the server's address
func (s *Server) Address() string {
	return s.httpServer.Addr
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/client_handlers.go
// FILE: internal/core-manager/admin/client_handlers.go
package admin

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// ClientHandlers handles admin operations for client management
type ClientHandlers struct {
	clientsDB *pgxpool.Pool
	logger    *zap.Logger
}

// NewClientHandlers creates new client admin handlers
func NewClientHandlers(clientsDB *pgxpool.Pool, logger *zap.Logger) *ClientHandlers {
	return &ClientHandlers{
		clientsDB: clientsDB,
		logger:    logger,
	}
}

// CreateClientRequest represents a request to create a new client
type CreateClientRequest struct {
	ClientID    string                 `json:"client_id" binding:"required,alphanum,min=3,max=50"`
	DisplayName string                 `json:"display_name" binding:"required"`
	Settings    map[string]interface{} `json:"settings,omitempty"`
}

// ClientInfo represents client information
type ClientInfo struct {
	ClientID    string                 `json:"client_id"`
	DisplayName string                 `json:"display_name"`
	Settings    map[string]interface{} `json:"settings,omitempty"`
	CreatedAt   string                 `json:"created_at"`
	IsActive    bool                   `json:"is_active"`
}

// HandleCreateClient creates a new client with schema
func (h *ClientHandlers) HandleCreateClient(c *gin.Context) {
	var req CreateClientRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate client_id format (alphanumeric, underscores allowed)
	if !isValidClientID(req.ClientID) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid client_id format. Use only alphanumeric characters and underscores"})
		return
	}

	// Check if client already exists
	exists, err := h.clientExists(c.Request.Context(), req.ClientID)
	if err != nil {
		h.logger.Error("Failed to check client existence", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check client existence"})
		return
	}

	if exists {
		c.JSON(http.StatusConflict, gin.H{"error": "Client already exists"})
		return
	}

	// Create client schema
	if err := h.createClientSchema(c.Request.Context(), req.ClientID); err != nil {
		h.logger.Error("Failed to create client schema", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create client schema"})
		return
	}

	// Store client info in a clients table (we'll need to create this)
	if err := h.storeClientInfo(c.Request.Context(), &req); err != nil {
		h.logger.Error("Failed to store client info", zap.Error(err))
		// Note: Schema is already created, this is a partial failure
	}

	h.logger.Info("Client created successfully", zap.String("client_id", req.ClientID))
	c.JSON(http.StatusCreated, gin.H{
		"message":   "Client created successfully",
		"client_id": req.ClientID,
	})
}

// HandleListClients lists all clients
func (h *ClientHandlers) HandleListClients(c *gin.Context) {
	clients, err := h.listClients(c.Request.Context())
	if err != nil {
		h.logger.Error("Failed to list clients", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list clients"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"clients": clients,
		"count":   len(clients),
	})
}

// HandleGetClientUsage gets usage statistics for a client
func (h *ClientHandlers) HandleGetClientUsage(c *gin.Context) {
	clientID := c.Param("client_id")

	if !isValidClientID(clientID) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid client_id format"})
		return
	}

	usage, err := h.getClientUsage(c.Request.Context(), clientID)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Client not found"})
			return
		}
		h.logger.Error("Failed to get client usage", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get client usage"})
		return
	}

	c.JSON(http.StatusOK, usage)
}

// Helper functions

func isValidClientID(clientID string) bool {
	// Only allow alphanumeric and underscores
	for _, char := range clientID {
		if !((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9') || char == '_') {
			return false
		}
	}
	return len(clientID) >= 3 && len(clientID) <= 50
}

func (h *ClientHandlers) clientExists(ctx context.Context, clientID string) (bool, error) {
	// Check if schema exists
	query := `
		SELECT EXISTS (
			SELECT 1 FROM information_schema.schemata 
			WHERE schema_name = $1
		)
	`
	schemaName := fmt.Sprintf("client_%s", clientID)

	var exists bool
	err := h.clientsDB.QueryRow(ctx, query, schemaName).Scan(&exists)
	return exists, err
}

func (h *ClientHandlers) createClientSchema(ctx context.Context, clientID string) error {
	// Call the stored procedure to create client schema
	query := `SELECT create_client_schema($1)`
	_, err := h.clientsDB.Exec(ctx, query, clientID)
	return err
}

func (h *ClientHandlers) storeClientInfo(ctx context.Context, req *CreateClientRequest) error {
	// First, ensure we have a clients info table
	createTableQuery := `
		CREATE TABLE IF NOT EXISTS clients_info (
			client_id VARCHAR(50) PRIMARY KEY,
			display_name VARCHAR(255) NOT NULL,
			settings JSONB DEFAULT '{}',
			is_active BOOLEAN DEFAULT true,
			created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
			updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
		)
	`

	if _, err := h.clientsDB.Exec(ctx, createTableQuery); err != nil {
		return fmt.Errorf("failed to create clients_info table: %w", err)
	}

	// Insert client info
	insertQuery := `
		INSERT INTO clients_info (client_id, display_name, settings)
		VALUES ($1, $2, $3)
		ON CONFLICT (client_id) DO NOTHING
	`

	_, err := h.clientsDB.Exec(ctx, insertQuery, req.ClientID, req.DisplayName, req.Settings)
	return err
}

func (h *ClientHandlers) listClients(ctx context.Context) ([]ClientInfo, error) {
	// First ensure the table exists
	h.storeClientInfo(ctx, &CreateClientRequest{}) // This will create table if needed

	query := `
		SELECT client_id, display_name, settings, is_active, created_at
		FROM clients_info
		WHERE is_active = true
		ORDER BY created_at DESC
	`

	rows, err := h.clientsDB.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var clients []ClientInfo
	for rows.Next() {
		var client ClientInfo
		var createdAt sql.NullTime
		var settings sql.NullString

		err := rows.Scan(&client.ClientID, &client.DisplayName, &settings, &client.IsActive, &createdAt)
		if err != nil {
			h.logger.Error("Failed to scan client row", zap.Error(err))
			continue
		}

		if createdAt.Valid {
			client.CreatedAt = createdAt.Time.Format("2006-01-02T15:04:05Z")
		}

		clients = append(clients, client)
	}

	// Also check for schemas without entries in clients_info
	schemaQuery := `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
		AND schema_name NOT IN (
			SELECT 'client_' || client_id FROM clients_info
		)
	`

	schemaRows, err := h.clientsDB.Query(ctx, schemaQuery)
	if err == nil {
		defer schemaRows.Close()
		for schemaRows.Next() {
			var schemaName string
			if err := schemaRows.Scan(&schemaName); err == nil {
				clientID := strings.TrimPrefix(schemaName, "client_")
				clients = append(clients, ClientInfo{
					ClientID:    clientID,
					DisplayName: clientID + " (Legacy)",
					IsActive:    true,
					CreatedAt:   "Unknown",
				})
			}
		}
	}

	return clients, nil
}

// ClientUsageStats represents usage statistics for a client
type ClientUsageStats struct {
	ClientID            string `json:"client_id"`
	TotalUsers          int    `json:"total_users"`
	ActiveUsers         int    `json:"active_users"`
	TotalInstances      int    `json:"total_instances"`
	ActiveInstances     int    `json:"active_instances"`
	TotalWorkflows      int    `json:"total_workflows"`
	WorkflowsLast30Days int    `json:"workflows_last_30_days"`
	TotalMemoryEntries  int    `json:"total_memory_entries"`
	TotalFuelConsumed   int64  `json:"total_fuel_consumed"`
}

func (h *ClientHandlers) getClientUsage(ctx context.Context, clientID string) (*ClientUsageStats, error) {
	stats := &ClientUsageStats{ClientID: clientID}

	// Get user counts from auth database (would need access to auth DB)
	// For now, we'll focus on what we can get from clients DB

	// Count agent instances
	instanceQuery := fmt.Sprintf(`
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE is_active = true) as active
		FROM client_%s.agent_instances
	`, clientID)

	err := h.clientsDB.QueryRow(ctx, instanceQuery).Scan(&stats.TotalInstances, &stats.ActiveInstances)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		return nil, err
	}

	// Count workflows
	workflowQuery := fmt.Sprintf(`
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE started_at > NOW() - INTERVAL '30 days') as recent
		FROM client_%s.workflow_executions
	`, clientID)

	err = h.clientsDB.QueryRow(ctx, workflowQuery).Scan(&stats.TotalWorkflows, &stats.WorkflowsLast30Days)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		h.logger.Warn("Failed to get workflow stats", zap.Error(err))
	}

	// Count memory entries
	memoryQuery := fmt.Sprintf(`
		SELECT COUNT(*) FROM client_%s.agent_memory
	`, clientID)

	err = h.clientsDB.QueryRow(ctx, memoryQuery).Scan(&stats.TotalMemoryEntries)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		h.logger.Warn("Failed to get memory stats", zap.Error(err))
	}

	// Get fuel consumption
	fuelQuery := fmt.Sprintf(`
		SELECT COALESCE(SUM(fuel_consumed), 0)
		FROM client_%s.usage_analytics
	`, clientID)

	err = h.clientsDB.QueryRow(ctx, fuelQuery).Scan(&stats.TotalFuelConsumed)
	if err != nil && !strings.Contains(err.Error(), "does not exist") {
		h.logger.Warn("Failed to get fuel stats", zap.Error(err))
	}

	return stats, nil
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/dashboard_handlers.go
// FILE: internal/core-manager/admin/dashboard_handlers.go
package admin

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// DashboardHandlers provides admin dashboard endpoints
type DashboardHandlers struct {
	clientsDB   *pgxpool.Pool
	templatesDB *pgxpool.Pool
	authDB      *sql.DB // For accessing auth database
	logger      *zap.Logger
}

// NewDashboardHandlers creates new dashboard handlers
func NewDashboardHandlers(clientsDB, templatesDB *pgxpool.Pool, authDB *sql.DB, logger *zap.Logger) *DashboardHandlers {
	return &DashboardHandlers{
		clientsDB:   clientsDB,
		templatesDB: templatesDB,
		authDB:      authDB,
		logger:      logger,
	}
}

// DashboardMetrics represents overall system metrics
type DashboardMetrics struct {
	Overview       OverviewMetrics     `json:"overview"`
	UserMetrics    UserMetrics         `json:"user_metrics"`
	AgentMetrics   AgentMetrics        `json:"agent_metrics"`
	UsageMetrics   UsageMetrics        `json:"usage_metrics"`
	SystemHealth   SystemHealthMetrics `json:"system_health"`
	RecentActivity []ActivityEntry     `json:"recent_activity"`
}

type OverviewMetrics struct {
	TotalClients        int     `json:"total_clients"`
	TotalUsers          int     `json:"total_users"`
	ActiveUsers30Days   int     `json:"active_users_30_days"`
	TotalAgentInstances int     `json:"total_agent_instances"`
	TotalWorkflows      int     `json:"total_workflows"`
	SuccessRate         float64 `json:"success_rate"`
	TotalRevenue        float64 `json:"total_revenue_mtd"`
}

type UserMetrics struct {
	UsersByTier      map[string]int `json:"users_by_tier"`
	NewUsersToday    int            `json:"new_users_today"`
	NewUsersThisWeek int            `json:"new_users_this_week"`
	ChurnRate        float64        `json:"churn_rate_monthly"`
}

type AgentMetrics struct {
	AgentsByType        map[string]int `json:"agents_by_type"`
	MostUsedAgents      []AgentUsage   `json:"most_used_agents"`
	AverageResponseTime float64        `json:"avg_response_time_ms"`
}

type AgentUsage struct {
	AgentType  string `json:"agent_type"`
	UsageCount int    `json:"usage_count"`
}

type UsageMetrics struct {
	TotalFuelConsumed int64            `json:"total_fuel_consumed"`
	FuelByAgentType   map[string]int64 `json:"fuel_by_agent_type"`
	APICallsToday     int              `json:"api_calls_today"`
	StorageUsedGB     float64          `json:"storage_used_gb"`
}

type SystemHealthMetrics struct {
	DatabaseStatus  string  `json:"database_status"`
	KafkaStatus     string  `json:"kafka_status"`
	AverageLatency  float64 `json:"average_latency_ms"`
	ErrorRate       float64 `json:"error_rate_percent"`
	ActiveWorkflows int     `json:"active_workflows"`
	QueueDepth      int     `json:"queue_depth"`
}

type ActivityEntry struct {
	Timestamp   time.Time `json:"timestamp"`
	Type        string    `json:"type"`
	Description string    `json:"description"`
	UserID      string    `json:"user_id,omitempty"`
	ClientID    string    `json:"client_id,omitempty"`
}

// HandleGetDashboard returns comprehensive dashboard metrics
func (h *DashboardHandlers) HandleGetDashboard(c *gin.Context) {
	ctx := c.Request.Context()

	metrics := &DashboardMetrics{
		Overview:       h.getOverviewMetrics(ctx),
		UserMetrics:    h.getUserMetrics(ctx),
		AgentMetrics:   h.getAgentMetrics(ctx),
		UsageMetrics:   h.getUsageMetrics(ctx),
		SystemHealth:   h.getSystemHealth(ctx),
		RecentActivity: h.getRecentActivity(ctx),
	}

	c.JSON(http.StatusOK, metrics)
}

// getOverviewMetrics collects high-level system metrics
func (h *DashboardHandlers) getOverviewMetrics(ctx context.Context) OverviewMetrics {
	metrics := OverviewMetrics{}

	// Count total clients
	var totalClients int
	err := h.clientsDB.QueryRow(ctx, `
		SELECT COUNT(DISTINCT schema_name) 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`).Scan(&totalClients)
	if err != nil {
		h.logger.Error("Failed to count clients", zap.Error(err))
	}
	metrics.TotalClients = totalClients

	// Count total users from auth DB
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM users WHERE is_active = true
	`).Scan(&metrics.TotalUsers)
	if err != nil {
		h.logger.Error("Failed to count users", zap.Error(err))
	}

	// Count active users in last 30 days
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(DISTINCT user_id) 
		FROM user_activity_logs 
		WHERE created_at > NOW() - INTERVAL 30 DAY
	`).Scan(&metrics.ActiveUsers30Days)
	if err != nil {
		h.logger.Error("Failed to count active users", zap.Error(err))
	}

	// Count total agent instances across all clients
	rows, err := h.clientsDB.Query(ctx, `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var schemaName string
			if err := rows.Scan(&schemaName); err == nil {
				var count int
				query := fmt.Sprintf("SELECT COUNT(*) FROM %s.agent_instances WHERE is_active = true", schemaName)
				h.clientsDB.QueryRow(ctx, query).Scan(&count)
				metrics.TotalAgentInstances += count
			}
		}
	}

	// Count total workflows and calculate success rate
	var successCount int
	err = h.clientsDB.QueryRow(ctx, `
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE status = 'COMPLETED') as success
		FROM orchestrator_state
		WHERE created_at > NOW() - INTERVAL '30 days'
	`).Scan(&metrics.TotalWorkflows, &successCount)
	if err == nil && metrics.TotalWorkflows > 0 {
		metrics.SuccessRate = float64(successCount) / float64(metrics.TotalWorkflows) * 100
	}

	// Calculate total revenue (simplified - would need proper billing integration)
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COALESCE(SUM(
			CASE 
				WHEN st.name = 'basic' THEN st.price_monthly
				WHEN st.name = 'premium' THEN st.price_monthly
				WHEN st.name = 'enterprise' THEN st.price_monthly
				ELSE 0
			END
		), 0) as total_revenue
		FROM users u
		JOIN subscriptions s ON u.id = s.user_id
		JOIN subscription_tiers st ON s.tier = st.name
		WHERE u.is_active = true AND s.status = 'active'
	`).Scan(&metrics.TotalRevenue)
	if err != nil {
		h.logger.Error("Failed to calculate revenue", zap.Error(err))
	}

	return metrics
}

// getUserMetrics collects user-related metrics
func (h *DashboardHandlers) getUserMetrics(ctx context.Context) UserMetrics {
	metrics := UserMetrics{
		UsersByTier: make(map[string]int),
	}

	// Count users by subscription tier
	rows, err := h.authDB.QueryContext(ctx, `
		SELECT subscription_tier, COUNT(*) 
		FROM users 
		WHERE is_active = true 
		GROUP BY subscription_tier
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var tier string
			var count int
			if err := rows.Scan(&tier, &count); err == nil {
				metrics.UsersByTier[tier] = count
			}
		}
	}

	// Count new users today
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM users 
		WHERE DATE(created_at) = CURDATE()
	`).Scan(&metrics.NewUsersToday)

	// Count new users this week
	err = h.authDB.QueryRowContext(ctx, `
		SELECT COUNT(*) FROM users 
		WHERE created_at > NOW() - INTERVAL 7 DAY
	`).Scan(&metrics.NewUsersThisWeek)

	// Calculate churn rate (simplified)
	var totalLastMonth, churnedThisMonth int
	h.authDB.QueryRowContext(ctx, `
		SELECT 
			(SELECT COUNT(*) FROM users WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 MONTH)) as total_last_month,
			(SELECT COUNT(*) FROM users WHERE is_active = false AND updated_at > DATE_SUB(NOW(), INTERVAL 1 MONTH)) as churned
	`).Scan(&totalLastMonth, &churnedThisMonth)

	if totalLastMonth > 0 {
		metrics.ChurnRate = float64(churnedThisMonth) / float64(totalLastMonth) * 100
	}

	return metrics
}

// getAgentMetrics collects agent-related metrics
func (h *DashboardHandlers) getAgentMetrics(ctx context.Context) AgentMetrics {
	metrics := AgentMetrics{
		AgentsByType: make(map[string]int),
	}

	// Count agents by type
	rows, err := h.clientsDB.Query(ctx, `
		SELECT type, COUNT(*) 
		FROM agent_definitions 
		WHERE is_active = true 
		GROUP BY type
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var agentType string
			var count int
			if err := rows.Scan(&agentType, &count); err == nil {
				metrics.AgentsByType[agentType] = count
			}
		}
	}

	// Get most used agents (from all client schemas)
	// This is simplified - in production you'd aggregate across all client schemas
	mostUsedQuery := `
		SELECT 
			ad.type,
			COUNT(*) as usage_count
		FROM orchestrator_state os
		JOIN agent_definitions ad ON true
		WHERE os.created_at > NOW() - INTERVAL '7 days'
		GROUP BY ad.type
		ORDER BY usage_count DESC
		LIMIT 5
	`

	rows, err = h.clientsDB.Query(ctx, mostUsedQuery)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var usage AgentUsage
			if err := rows.Scan(&usage.AgentType, &usage.UsageCount); err == nil {
				metrics.MostUsedAgents = append(metrics.MostUsedAgents, usage)
			}
		}
	}

	// Calculate average response time (simplified)
	// In production, this would come from your metrics system
	metrics.AverageResponseTime = 245.7 // Mock value

	return metrics
}

// getUsageMetrics collects resource usage metrics
func (h *DashboardHandlers) getUsageMetrics(ctx context.Context) UsageMetrics {
	metrics := UsageMetrics{
		FuelByAgentType: make(map[string]int64),
	}

	// Get total fuel consumed across all clients
	// This would need to aggregate from all client schemas
	metrics.TotalFuelConsumed = 125000 // Mock value

	// Fuel by agent type (mock data)
	metrics.FuelByAgentType = map[string]int64{
		"copywriter":      45000,
		"researcher":      35000,
		"reasoning":       25000,
		"image-generator": 20000,
	}

	// API calls today (mock)
	metrics.APICallsToday = 8543

	// Storage used (would query actual storage metrics)
	metrics.StorageUsedGB = 45.7

	return metrics
}

// getSystemHealth checks current system health
func (h *DashboardHandlers) getSystemHealth(ctx context.Context) SystemHealthMetrics {
	metrics := SystemHealthMetrics{}

	// Check database status
	if err := h.clientsDB.Ping(ctx); err != nil {
		metrics.DatabaseStatus = "unhealthy"
	} else {
		metrics.DatabaseStatus = "healthy"
	}

	// Kafka status (simplified)
	metrics.KafkaStatus = "healthy"

	// Get active workflows count
	h.clientsDB.QueryRow(ctx, `
		SELECT COUNT(*) FROM orchestrator_state 
		WHERE status IN ('RUNNING', 'AWAITING_RESPONSES', 'PAUSED_FOR_HUMAN_INPUT')
	`).Scan(&metrics.ActiveWorkflows)

	// Mock metrics - in production these would come from Prometheus
	metrics.AverageLatency = 123.5
	metrics.ErrorRate = 0.02
	metrics.QueueDepth = 42

	return metrics
}

// getRecentActivity returns recent system activity
func (h *DashboardHandlers) getRecentActivity(ctx context.Context) []ActivityEntry {
	activities := []ActivityEntry{}

	// Get recent user registrations
	rows, err := h.authDB.QueryContext(ctx, `
		SELECT created_at, 'user_registration' as type, email, client_id
		FROM users
		ORDER BY created_at DESC
		LIMIT 10
	`)
	if err == nil {
		defer rows.Close()
		for rows.Next() {
			var activity ActivityEntry
			var email string
			rows.Scan(&activity.Timestamp, &activity.Type, &email, &activity.ClientID)
			activity.Description = fmt.Sprintf("New user registered: %s", email)
			activities = append(activities, activity)
		}
	}

	// Get recent workflow completions
	workflowRows, err := h.clientsDB.Query(ctx, `
		SELECT updated_at, status, correlation_id, client_id
		FROM orchestrator_state
		WHERE status IN ('COMPLETED', 'FAILED')
		ORDER BY updated_at DESC
		LIMIT 10
	`)
	if err == nil {
		defer workflowRows.Close()
		for workflowRows.Next() {
			var activity ActivityEntry
			var status, correlationID string
			workflowRows.Scan(&activity.Timestamp, &status, &correlationID, &activity.ClientID)
			activity.Type = "workflow_" + strings.ToLower(status)
			activity.Description = fmt.Sprintf("Workflow %s: %s", status, correlationID[:8])
			activities = append(activities, activity)
		}
	}

	// Sort by timestamp
	sort.Slice(activities, func(i, j int) bool {
		return activities[i].Timestamp.After(activities[j].Timestamp)
	})

	// Return top 20
	if len(activities) > 20 {
		activities = activities[:20]
	}

	return activities
}

// HandleGetSystemLogs returns recent system logs
func (h *DashboardHandlers) HandleGetSystemLogs(c *gin.Context) {
	service := c.Query("service")
	level := c.Query("level")
	limit := 100

	if limitStr := c.Query("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 1000 {
			limit = l
		}
	}

	// In production, this would query your centralized logging system
	// For now, return mock data
	logs := []LogEntry{
		{
			Timestamp: time.Now(),
			Service:   "auth-service",
			Level:     "info",
			Message:   "User login successful",
			Metadata: map[string]interface{}{
				"user_id": "123",
				"ip":      "192.168.1.1",
			},
		},
	}

	c.JSON(http.StatusOK, gin.H{
		"logs":  logs,
		"total": len(logs),
		"query": gin.H{
			"service": service,
			"level":   level,
			"limit":   limit,
		},
	})
}

type LogEntry struct {
	Timestamp time.Time              `json:"timestamp"`
	Service   string                 `json:"service"`
	Level     string                 `json:"level"`
	Message   string                 `json:"message"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/system_handlers.go
// FILE: internal/core-manager/admin/system_handlers.go
package admin

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/platform/kafka"
	"github.com/gqls/agentchassis/platform/orchestration"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// SystemHandlers handles admin system monitoring operations
type SystemHandlers struct {
	clientsDB     *pgxpool.Pool
	templatesDB   *pgxpool.Pool
	kafkaProducer kafka.Producer
	logger        *zap.Logger
}

// NewSystemHandlers creates new system monitoring handlers
func NewSystemHandlers(clientsDB, templatesDB *pgxpool.Pool, kafkaProducer kafka.Producer, logger *zap.Logger) *SystemHandlers {
	return &SystemHandlers{
		clientsDB:     clientsDB,
		templatesDB:   templatesDB,
		kafkaProducer: kafkaProducer,
		logger:        logger,
	}
}

// SystemStatus represents overall system health
type SystemStatus struct {
	Status      string                    `json:"status"`
	Timestamp   time.Time                 `json:"timestamp"`
	Services    map[string]ServiceStatus  `json:"services"`
	Databases   map[string]DatabaseStatus `json:"databases"`
	KafkaStatus KafkaStatus               `json:"kafka"`
}

// ServiceStatus represents a service health status
type ServiceStatus struct {
	Name    string `json:"name"`
	Status  string `json:"status"`
	Version string `json:"version,omitempty"`
	Uptime  string `json:"uptime,omitempty"`
}

// DatabaseStatus represents database health
type DatabaseStatus struct {
	Name        string `json:"name"`
	Status      string `json:"status"`
	Connections int    `json:"active_connections"`
	Size        string `json:"size,omitempty"`
}

// KafkaStatus represents Kafka cluster status
type KafkaStatus struct {
	Status      string `json:"status"`
	BrokerCount int    `json:"broker_count"`
	TopicCount  int    `json:"topic_count"`
	ConsumerLag int64  `json:"total_consumer_lag,omitempty"`
}

// HandleGetSystemStatus returns aggregated system status
func (h *SystemHandlers) HandleGetSystemStatus(c *gin.Context) {
	status := SystemStatus{
		Status:    "healthy",
		Timestamp: time.Now(),
		Services:  make(map[string]ServiceStatus),
		Databases: make(map[string]DatabaseStatus),
	}

	// Check database connections
	// Clients DB
	if err := h.clientsDB.Ping(c.Request.Context()); err != nil {
		status.Status = "degraded"
		status.Databases["clients_db"] = DatabaseStatus{
			Name:   "clients_db",
			Status: "unhealthy",
		}
	} else {
		stats := h.clientsDB.Stat()
		status.Databases["clients_db"] = DatabaseStatus{
			Name:        "clients_db",
			Status:      "healthy",
			Connections: int(stats.AcquiredConns()),
		}
	}

	// Templates DB
	if err := h.templatesDB.Ping(c.Request.Context()); err != nil {
		status.Status = "degraded"
		status.Databases["templates_db"] = DatabaseStatus{
			Name:   "templates_db",
			Status: "unhealthy",
		}
	} else {
		stats := h.templatesDB.Stat()
		status.Databases["templates_db"] = DatabaseStatus{
			Name:        "templates_db",
			Status:      "healthy",
			Connections: int(stats.AcquiredConns()),
		}
	}

	// Get database sizes
	h.getDatabaseSizes(c.Request.Context(), &status)

	// Check Kafka (simplified - in production you'd want more detailed checks)
	status.KafkaStatus = h.getKafkaStatus(c.Request.Context())

	c.JSON(http.StatusOK, status)
}

// HandleListKafkaTopics lists all Kafka topics
func (h *SystemHandlers) HandleListKafkaTopics(c *gin.Context) {
	// This would require a Kafka admin client
	// For now, return known topics
	knownTopics := []string{
		"orchestrator.state-changes",
		"human.approvals",
		"system.events",
		"system.notifications.ui",
		"system.commands.workflow.resume",
		"system.agent.reasoning.process",
		"system.responses.reasoning",
		"system.adapter.image.generate",
		"system.responses.image",
		"system.adapter.web.search",
		"system.responses.websearch",
		"system.agent.generic.process",
		"system.tasks.copywriter",
		"system.tasks.researcher",
		"system.tasks.content-creator",
		"system.tasks.multimedia-creator",
	}

	c.JSON(http.StatusOK, gin.H{
		"topics": knownTopics,
		"count":  len(knownTopics),
	})
}

// WorkflowListRequest represents workflow filtering parameters
type WorkflowListRequest struct {
	Status    string `form:"status"`
	ClientID  string `form:"client_id"`
	StartDate string `form:"start_date"`
	EndDate   string `form:"end_date"`
	Limit     int    `form:"limit,default=50"`
	Offset    int    `form:"offset,default=0"`
}

// HandleListWorkflows lists workflow executions
func (h *SystemHandlers) HandleListWorkflows(c *gin.Context) {
	var req WorkflowListRequest
	if err := c.ShouldBindQuery(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	workflows, err := h.listWorkflows(c.Request.Context(), req)
	if err != nil {
		h.logger.Error("Failed to list workflows", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list workflows"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"workflows": workflows,
		"count":     len(workflows),
	})
}

// HandleGetWorkflow returns detailed workflow state
func (h *SystemHandlers) HandleGetWorkflow(c *gin.Context) {
	correlationID := c.Param("correlation_id")

	workflow, err := h.getWorkflowState(c.Request.Context(), correlationID)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
			return
		}
		h.logger.Error("Failed to get workflow", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get workflow"})
		return
	}

	c.JSON(http.StatusOK, workflow)
}

// HandleResumeWorkflow manually resumes or terminates a workflow
func (h *SystemHandlers) HandleResumeWorkflow(c *gin.Context) {
	correlationID := c.Param("correlation_id")

	var req struct {
		Action   string                 `json:"action" binding:"required,oneof=resume terminate"`
		Feedback map[string]interface{} `json:"feedback,omitempty"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get workflow state to find client_id
	workflow, err := h.getWorkflowState(c.Request.Context(), correlationID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
		return
	}

	if req.Action == "terminate" {
		// Update workflow status to FAILED
		err = h.updateWorkflowStatus(c.Request.Context(), correlationID, "FAILED", "Manually terminated by admin")
		if err != nil {
			h.logger.Error("Failed to terminate workflow", zap.Error(err))
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to terminate workflow"})
			return
		}
	} else if req.Action == "resume" {
		// Send resume command via Kafka
		resumePayload := map[string]interface{}{
			"approved": true,
			"feedback": req.Feedback,
		}

		payloadBytes, _ := json.Marshal(resumePayload)
		headers := map[string]string{
			"correlation_id": correlationID,
			"client_id":      workflow["client_id"].(string),
			"admin_action":   "true",
		}

		err = h.kafkaProducer.Produce(c.Request.Context(),
			orchestration.ResumeWorkflowTopic,
			headers,
			[]byte(correlationID),
			payloadBytes,
		)

		if err != nil {
			h.logger.Error("Failed to send resume command", zap.Error(err))
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to resume workflow"})
			return
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"message":        fmt.Sprintf("Workflow %s successfully", req.Action+"d"),
		"correlation_id": correlationID,
	})
}

// HandleListAgentDefinitions lists all agent types
func (h *SystemHandlers) HandleListAgentDefinitions(c *gin.Context) {
	query := `
		SELECT id, type, display_name, description, category, default_config, is_active
		FROM agent_definitions
		WHERE deleted_at IS NULL
		ORDER BY category, type
	`

	rows, err := h.clientsDB.Query(c.Request.Context(), query)
	if err != nil {
		h.logger.Error("Failed to list agent definitions", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list agent definitions"})
		return
	}
	defer rows.Close()

	var definitions []map[string]interface{}
	for rows.Next() {
		var def struct {
			ID            string
			Type          string
			DisplayName   string
			Description   string
			Category      string
			DefaultConfig json.RawMessage
			IsActive      bool
		}

		err := rows.Scan(&def.ID, &def.Type, &def.DisplayName,
			&def.Description, &def.Category, &def.DefaultConfig, &def.IsActive)
		if err != nil {
			h.logger.Error("Failed to scan agent definition", zap.Error(err))
			continue
		}

		var config map[string]interface{}
		json.Unmarshal(def.DefaultConfig, &config)

		definitions = append(definitions, map[string]interface{}{
			"id":             def.ID,
			"type":           def.Type,
			"display_name":   def.DisplayName,
			"description":    def.Description,
			"category":       def.Category,
			"default_config": config,
			"is_active":      def.IsActive,
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"definitions": definitions,
		"count":       len(definitions),
	})
}

// HandleUpdateAgentDefinition updates an agent type configuration
func (h *SystemHandlers) HandleUpdateAgentDefinition(c *gin.Context) {
	typeName := c.Param("type_name")

	var req struct {
		DisplayName   *string                `json:"display_name"`
		Description   *string                `json:"description"`
		DefaultConfig map[string]interface{} `json:"default_config"`
		IsActive      *bool                  `json:"is_active"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Build update query
	updates := []string{"updated_at = NOW()"}
	args := []interface{}{}
	argCount := 0

	if req.DisplayName != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("display_name = $%d", argCount))
		args = append(args, *req.DisplayName)
	}

	if req.Description != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("description = $%d", argCount))
		args = append(args, *req.Description)
	}

	if req.DefaultConfig != nil {
		argCount++
		configBytes, _ := json.Marshal(req.DefaultConfig)
		updates = append(updates, fmt.Sprintf("default_config = $%d", argCount))
		args = append(args, configBytes)
	}

	if req.IsActive != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("is_active = $%d", argCount))
		args = append(args, *req.IsActive)
	}

	argCount++
	args = append(args, typeName)

	query := fmt.Sprintf(
		"UPDATE agent_definitions SET %s WHERE type = $%d AND deleted_at IS NULL",
		strings.Join(updates, ", "),
		argCount,
	)

	result, err := h.clientsDB.Exec(c.Request.Context(), query, args...)
	if err != nil {
		h.logger.Error("Failed to update agent definition", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update agent definition"})
		return
	}

	if result.RowsAffected() == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Agent definition not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Agent definition updated successfully",
		"type":    typeName,
	})
}

// Helper methods

func (h *SystemHandlers) getDatabaseSizes(ctx context.Context, status *SystemStatus) {
	// Get clients DB size
	var clientsSize string
	err := h.clientsDB.QueryRow(ctx,
		"SELECT pg_size_pretty(pg_database_size(current_database()))").Scan(&clientsSize)
	if err == nil {
		dbStatus := status.Databases["clients_db"]
		dbStatus.Size = clientsSize
		status.Databases["clients_db"] = dbStatus
	}

	// Get templates DB size
	var templatesSize string
	err = h.templatesDB.QueryRow(ctx,
		"SELECT pg_size_pretty(pg_database_size(current_database()))").Scan(&templatesSize)
	if err == nil {
		dbStatus := status.Databases["templates_db"]
		dbStatus.Size = templatesSize
		status.Databases["templates_db"] = dbStatus
	}
}

func (h *SystemHandlers) getKafkaStatus(ctx context.Context) KafkaStatus {
	// In a real implementation, you'd use a Kafka admin client
	// For now, return a simplified status
	return KafkaStatus{
		Status:      "healthy",
		BrokerCount: 3,  // Based on the k8s config
		TopicCount:  20, // Approximate
	}
}

func (h *SystemHandlers) listWorkflows(ctx context.Context, req WorkflowListRequest) ([]map[string]interface{}, error) {
	query := `
		SELECT correlation_id, client_id, status, current_step, 
		       created_at, updated_at, error
		FROM orchestrator_state
		WHERE 1=1
	`

	args := []interface{}{}
	argCount := 0

	if req.Status != "" {
		argCount++
		query += fmt.Sprintf(" AND status = $%d", argCount)
		args = append(args, req.Status)
	}

	if req.ClientID != "" {
		argCount++
		query += fmt.Sprintf(" AND client_id = $%d", argCount)
		args = append(args, req.ClientID)
	}

	if req.StartDate != "" {
		argCount++
		query += fmt.Sprintf(" AND created_at >= $%d", argCount)
		args = append(args, req.StartDate)
	}

	if req.EndDate != "" {
		argCount++
		query += fmt.Sprintf(" AND created_at <= $%d", argCount)
		args = append(args, req.EndDate)
	}

	query += " ORDER BY created_at DESC"

	argCount++
	query += fmt.Sprintf(" LIMIT $%d", argCount)
	args = append(args, req.Limit)

	argCount++
	query += fmt.Sprintf(" OFFSET $%d", argCount)
	args = append(args, req.Offset)

	rows, err := h.clientsDB.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var workflows []map[string]interface{}
	for rows.Next() {
		var w struct {
			CorrelationID string
			ClientID      string
			Status        string
			CurrentStep   string
			CreatedAt     time.Time
			UpdatedAt     time.Time
			Error         sql.NullString
		}

		err := rows.Scan(&w.CorrelationID, &w.ClientID, &w.Status,
			&w.CurrentStep, &w.CreatedAt, &w.UpdatedAt, &w.Error)
		if err != nil {
			continue
		}

		workflow := map[string]interface{}{
			"correlation_id": w.CorrelationID,
			"client_id":      w.ClientID,
			"status":         w.Status,
			"current_step":   w.CurrentStep,
			"created_at":     w.CreatedAt,
			"updated_at":     w.UpdatedAt,
		}

		if w.Error.Valid {
			workflow["error"] = w.Error.String
		}

		workflows = append(workflows, workflow)
	}

	return workflows, nil
}

func (h *SystemHandlers) getWorkflowState(ctx context.Context, correlationID string) (map[string]interface{}, error) {
	var state orchestration.OrchestrationState
	var awaitedStepsJSON, collectedDataJSON, initialRequestDataJSON, finalResultJSON []byte
	var errorNull sql.NullString

	query := `
		SELECT correlation_id, client_id, status, current_step, awaited_steps, 
		       collected_data, initial_request_data, final_result, error, 
		       created_at, updated_at
		FROM orchestrator_state
		WHERE correlation_id = $1
	`

	err := h.clientsDB.QueryRow(ctx, query, correlationID).Scan(
		&state.CorrelationID,
		&state.ClientID,
		&state.Status,
		&state.CurrentStep,
		&awaitedStepsJSON,
		&collectedDataJSON,
		&initialRequestDataJSON,
		&finalResultJSON,
		&errorNull,
		&state.CreatedAt,
		&state.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	// Parse JSON fields
	json.Unmarshal(awaitedStepsJSON, &state.AwaitedSteps)
	json.Unmarshal(collectedDataJSON, &state.CollectedData)
	state.InitialRequestData = initialRequestDataJSON
	state.FinalResult = finalResultJSON

	if errorNull.Valid {
		state.Error = errorNull.String
	}

	// Convert to map for response
	result := map[string]interface{}{
		"correlation_id":       state.CorrelationID,
		"client_id":            state.ClientID,
		"status":               state.Status,
		"current_step":         state.CurrentStep,
		"awaited_steps":        state.AwaitedSteps,
		"collected_data":       state.CollectedData,
		"initial_request_data": json.RawMessage(state.InitialRequestData),
		"final_result":         json.RawMessage(state.FinalResult),
		"error":                state.Error,
		"created_at":           state.CreatedAt,
		"updated_at":           state.UpdatedAt,
	}

	return result, nil
}

func (h *SystemHandlers) updateWorkflowStatus(ctx context.Context, correlationID, status, errorMsg string) error {
	query := `
		UPDATE orchestrator_state 
		SET status = $2, error = $3, updated_at = NOW()
		WHERE correlation_id = $1
	`

	_, err := h.clientsDB.Exec(ctx, query, correlationID, status, errorMsg)
	return err
}
-------------------------------------------------
filepath = ./internal/core-manager/admin/agent_handlers.go
// FILE: internal/core-manager/admin/agent_handlers.go
package admin

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/gqls/agentchassis/pkg/models"
	"github.com/gqls/agentchassis/platform/kafka"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// AgentHandlers manages agent-related admin operations
type AgentHandlers struct {
	clientsDB     *pgxpool.Pool
	templatesDB   *pgxpool.Pool
	kafkaProducer kafka.Producer
	logger        *zap.Logger
	personaRepo   models.PersonaRepository
}

// NewAgentHandlers creates new agent management handlers
func NewAgentHandlers(clientsDB, templatesDB *pgxpool.Pool, kafkaProducer kafka.Producer, logger *zap.Logger, personaRepo models.PersonaRepository) *AgentHandlers {
	return &AgentHandlers{
		clientsDB:     clientsDB,
		templatesDB:   templatesDB,
		kafkaProducer: kafkaProducer,
		logger:        logger,
		personaRepo:   personaRepo,
	}
}

// AgentDefinitionRequest for creating/updating agent definitions
type AgentDefinitionRequest struct {
	Type          string                 `json:"type" binding:"required"`
	DisplayName   string                 `json:"display_name" binding:"required"`
	Description   string                 `json:"description"`
	Category      string                 `json:"category" binding:"required,oneof=data-driven code-driven adapter"`
	DefaultConfig map[string]interface{} `json:"default_config"`
}

// AgentInstanceDetails provides detailed info about an agent instance
type AgentInstanceDetails struct {
	ID           string                 `json:"id"`
	TemplateID   string                 `json:"template_id"`
	TemplateName string                 `json:"template_name"`
	ClientID     string                 `json:"client_id"`
	OwnerUserID  string                 `json:"owner_user_id"`
	Name         string                 `json:"name"`
	Config       map[string]interface{} `json:"config"`
	IsActive     bool                   `json:"is_active"`
	CreatedAt    time.Time              `json:"created_at"`
	UpdatedAt    time.Time              `json:"updated_at"`
	Usage        AgentUsageStats        `json:"usage"`
	Health       AgentHealthStatus      `json:"health"`
}

// AgentUsageStats tracks usage metrics for an agent
type AgentUsageStats struct {
	TotalExecutions   int        `json:"total_executions"`
	SuccessfulRuns    int        `json:"successful_runs"`
	FailedRuns        int        `json:"failed_runs"`
	AverageRunTime    float64    `json:"average_run_time_ms"`
	LastExecutionTime *time.Time `json:"last_execution_time,omitempty"`
	FuelConsumed      int64      `json:"fuel_consumed"`
}

// AgentHealthStatus represents current health of an agent
type AgentHealthStatus struct {
	Status        string    `json:"status"` // healthy, degraded, unhealthy
	LastCheckTime time.Time `json:"last_check_time"`
	ErrorRate     float64   `json:"error_rate_percent"`
	ResponseTime  float64   `json:"avg_response_time_ms"`
	QueueDepth    int       `json:"queue_depth"`
}

// HandleCreateAgentDefinition creates a new agent type
func (h *AgentHandlers) HandleCreateAgentDefinition(c *gin.Context) {
	var req AgentDefinitionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if type already exists
	var exists bool
	err := h.clientsDB.QueryRow(c.Request.Context(),
		"SELECT EXISTS(SELECT 1 FROM agent_definitions WHERE type = $1 AND deleted_at IS NULL)",
		req.Type,
	).Scan(&exists)

	if err != nil {
		h.logger.Error("Failed to check agent existence", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check agent existence"})
		return
	}

	if exists {
		c.JSON(http.StatusConflict, gin.H{"error": "Agent type already exists"})
		return
	}

	// Insert new agent definition
	id := uuid.New()
	configBytes, _ := json.Marshal(req.DefaultConfig)

	query := `
		INSERT INTO agent_definitions 
		(id, type, display_name, description, category, default_config, is_active)
		VALUES ($1, $2, $3, $4, $5, $6, true)
	`

	_, err = h.clientsDB.Exec(c.Request.Context(), query,
		id, req.Type, req.DisplayName, req.Description, req.Category, configBytes,
	)

	if err != nil {
		h.logger.Error("Failed to create agent definition", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create agent definition"})
		return
	}

	// Create Kafka topics for the new agent type
	h.createAgentTopics(c.Request.Context(), req.Type)

	h.logger.Info("Agent definition created",
		zap.String("id", id.String()),
		zap.String("type", req.Type))

	c.JSON(http.StatusCreated, gin.H{
		"id":      id.String(),
		"type":    req.Type,
		"message": "Agent definition created successfully",
	})
}

// HandleListAgentInstances lists all agent instances with filtering
func (h *AgentHandlers) HandleListAgentInstances(c *gin.Context) {
	clientID := c.Query("client_id")
	agentType := c.Query("agent_type")
	isActive := c.Query("is_active")

	instances := []AgentInstanceDetails{}

	// Get all client schemas
	schemaRows, err := h.clientsDB.Query(c.Request.Context(), `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`)
	if err != nil {
		h.logger.Error("Failed to list schemas", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list instances"})
		return
	}
	defer schemaRows.Close()

	for schemaRows.Next() {
		var schemaName string
		if err := schemaRows.Scan(&schemaName); err != nil {
			continue
		}

		currentClientID := strings.TrimPrefix(schemaName, "client_")
		if clientID != "" && currentClientID != clientID {
			continue
		}

		// Query instances from this client schema
		query := fmt.Sprintf(`
			SELECT 
				ai.id, ai.template_id, ai.owner_user_id, ai.name, 
				ai.config, ai.is_active, ai.created_at, ai.updated_at,
				pt.name as template_name
			FROM %s.agent_instances ai
			LEFT JOIN persona_templates pt ON ai.template_id = pt.id
			WHERE 1=1
		`, schemaName)

		args := []interface{}{}
		argCount := 0

		if agentType != "" {
			argCount++
			query += fmt.Sprintf(" AND pt.category = $%d", argCount)
			args = append(args, agentType)
		}

		if isActive != "" {
			argCount++
			query += fmt.Sprintf(" AND ai.is_active = $%d", argCount)
			args = append(args, isActive == "true")
		}

		rows, err := h.clientsDB.Query(c.Request.Context(), query, args...)
		if err != nil {
			h.logger.Error("Failed to query instances", zap.Error(err))
			continue
		}

		for rows.Next() {
			var instance AgentInstanceDetails
			var configJSON []byte
			var templateName sql.NullString

			err := rows.Scan(
				&instance.ID, &instance.TemplateID, &instance.OwnerUserID,
				&instance.Name, &configJSON, &instance.IsActive,
				&instance.CreatedAt, &instance.UpdatedAt, &templateName,
			)
			if err != nil {
				continue
			}

			instance.ClientID = currentClientID
			if templateName.Valid {
				instance.TemplateName = templateName.String
			}
			json.Unmarshal(configJSON, &instance.Config)

			// Get usage stats
			instance.Usage = h.getAgentUsageStats(c.Request.Context(), currentClientID, instance.ID)
			instance.Health = h.getAgentHealth(c.Request.Context(), instance.ID)

			instances = append(instances, instance)
		}
		rows.Close()
	}

	c.JSON(http.StatusOK, gin.H{
		"instances": instances,
		"count":     len(instances),
	})
}

// HandleGetAgentInstance returns detailed information about a specific agent
func (h *AgentHandlers) HandleGetAgentInstance(c *gin.Context) {
	agentID := c.Param("agent_id")
	clientID := c.Param("client_id")

	if clientID == "" {
		// Need to find which client owns this agent
		clientID = h.findClientForAgent(c.Request.Context(), agentID)
		if clientID == "" {
			c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
			return
		}
	}

	query := fmt.Sprintf(`
		SELECT 
			ai.id, ai.template_id, ai.owner_user_id, ai.name, 
			ai.config, ai.is_active, ai.created_at, ai.updated_at,
			pt.name as template_name
		FROM client_%s.agent_instances ai
		LEFT JOIN persona_templates pt ON ai.template_id = pt.id
		WHERE ai.id = $1
	`, clientID)

	var instance AgentInstanceDetails
	var configJSON []byte
	var templateName sql.NullString

	err := h.clientsDB.QueryRow(c.Request.Context(), query, agentID).Scan(
		&instance.ID, &instance.TemplateID, &instance.OwnerUserID,
		&instance.Name, &configJSON, &instance.IsActive,
		&instance.CreatedAt, &instance.UpdatedAt, &templateName,
	)

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
		return
	}

	instance.ClientID = clientID
	if templateName.Valid {
		instance.TemplateName = templateName.String
	}
	json.Unmarshal(configJSON, &instance.Config)

	// Get detailed usage and health
	instance.Usage = h.getAgentUsageStats(c.Request.Context(), clientID, agentID)
	instance.Health = h.getAgentHealth(c.Request.Context(), agentID)

	// Get recent executions
	executions := h.getRecentExecutions(c.Request.Context(), clientID, agentID, 10)

	c.JSON(http.StatusOK, gin.H{
		"agent":      instance,
		"executions": executions,
	})
}

// HandleToggleAgentStatus enables/disables an agent instance
func (h *AgentHandlers) HandleToggleAgentStatus(c *gin.Context) {
	agentID := c.Param("agent_id")
	clientID := c.Param("client_id")

	if clientID == "" {
		clientID = h.findClientForAgent(c.Request.Context(), agentID)
		if clientID == "" {
			c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
			return
		}
	}

	var req struct {
		IsActive bool   `json:"is_active"`
		Reason   string `json:"reason"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	query := fmt.Sprintf(`
		UPDATE client_%s.agent_instances 
		SET is_active = $2, updated_at = NOW()
		WHERE id = $1
	`, clientID)

	result, err := h.clientsDB.Exec(c.Request.Context(), query, agentID, req.IsActive)
	if err != nil {
		h.logger.Error("Failed to toggle agent status", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update agent status"})
		return
	}

	if result.RowsAffected() == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Agent not found"})
		return
	}

	// Log the action
	h.logger.Info("Agent status toggled",
		zap.String("agent_id", agentID),
		zap.String("client_id", clientID),
		zap.Bool("is_active", req.IsActive),
		zap.String("reason", req.Reason))

	// Send notification if disabling
	if !req.IsActive {
		h.notifyAgentDisabled(c.Request.Context(), clientID, agentID, req.Reason)
	}

	c.JSON(http.StatusOK, gin.H{
		"message":   fmt.Sprintf("Agent %s successfully", map[bool]string{true: "enabled", false: "disabled"}[req.IsActive]),
		"agent_id":  agentID,
		"is_active": req.IsActive,
	})
}

// HandleRestartAgent sends a restart command to an agent
func (h *AgentHandlers) HandleRestartAgent(c *gin.Context) {
	agentID := c.Param("agent_id")

	// Send restart command via Kafka
	command := map[string]interface{}{
		"command":   "restart",
		"agent_id":  agentID,
		"timestamp": time.Now().UTC(),
	}

	commandBytes, _ := json.Marshal(command)
	headers := map[string]string{
		"correlation_id": uuid.NewString(),
		"command_type":   "agent_restart",
		"agent_id":       agentID,
	}

	err := h.kafkaProducer.Produce(c.Request.Context(),
		"system.agent.commands",
		headers,
		[]byte(agentID),
		commandBytes,
	)

	if err != nil {
		h.logger.Error("Failed to send restart command", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send restart command"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":  "Restart command sent",
		"agent_id": agentID,
	})
}

// Helper methods

func (h *AgentHandlers) createAgentTopics(ctx context.Context, agentType string) {
	topics := []string{
		fmt.Sprintf("tasks.high.%s", agentType),
		fmt.Sprintf("tasks.normal.%s", agentType),
		fmt.Sprintf("tasks.low.%s", agentType),
		fmt.Sprintf("responses.%s", agentType),
		fmt.Sprintf("dlq.%s", agentType),
	}

	for _, topic := range topics {
		// In production, you'd use Kafka admin client
		h.logger.Info("Would create Kafka topic", zap.String("topic", topic))
	}
}

func (h *AgentHandlers) findClientForAgent(ctx context.Context, agentID string) string {
	// Search through all client schemas
	rows, err := h.clientsDB.Query(ctx, `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name LIKE 'client_%'
	`)
	if err != nil {
		return ""
	}
	defer rows.Close()

	for rows.Next() {
		var schemaName string
		if err := rows.Scan(&schemaName); err != nil {
			continue
		}

		var exists bool
		query := fmt.Sprintf("SELECT EXISTS(SELECT 1 FROM %s.agent_instances WHERE id = $1)", schemaName)
		if err := h.clientsDB.QueryRow(ctx, query, agentID).Scan(&exists); err == nil && exists {
			return strings.TrimPrefix(schemaName, "client_")
		}
	}

	return ""
}

func (h *AgentHandlers) getAgentUsageStats(ctx context.Context, clientID, agentID string) AgentUsageStats {
	stats := AgentUsageStats{}

	// Get execution stats from workflow_executions
	query := fmt.Sprintf(`
		SELECT 
			COUNT(*) as total,
			COUNT(*) FILTER (WHERE status = 'COMPLETED') as successful,
			COUNT(*) FILTER (WHERE status = 'FAILED') as failed,
			AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) * 1000) as avg_runtime,
			MAX(completed_at) as last_execution
		FROM client_%s.workflow_executions
		WHERE agent_instance_id = $1
	`, clientID)

	var lastExecution sql.NullTime
	h.clientsDB.QueryRow(ctx, query, agentID).Scan(
		&stats.TotalExecutions,
		&stats.SuccessfulRuns,
		&stats.FailedRuns,
		&stats.AverageRunTime,
		&lastExecution,
	)

	if lastExecution.Valid {
		stats.LastExecutionTime = &lastExecution.Time
	}

	// Get fuel consumption
	fuelQuery := fmt.Sprintf(`
		SELECT COALESCE(SUM(fuel_consumed), 0)
		FROM client_%s.usage_analytics
		WHERE metadata->>'agent_id' = $1
	`, clientID)
	h.clientsDB.QueryRow(ctx, fuelQuery, agentID).Scan(&stats.FuelConsumed)

	return stats
}

func (h *AgentHandlers) getAgentHealth(ctx context.Context, agentID string) AgentHealthStatus {
	// In production, this would query your metrics system
	return AgentHealthStatus{
		Status:        "healthy",
		LastCheckTime: time.Now(),
		ErrorRate:     2.5,
		ResponseTime:  145.3,
		QueueDepth:    3,
	}
}

func (h *AgentHandlers) getRecentExecutions(ctx context.Context, clientID, agentID string, limit int) []map[string]interface{} {
	executions := []map[string]interface{}{}

	query := fmt.Sprintf(`
		SELECT 
			id, correlation_id, status, started_at, completed_at,
			input_data, output_data, error_message
		FROM client_%s.workflow_executions
		WHERE agent_instance_id = $1
		ORDER BY started_at DESC
		LIMIT $2
	`, clientID)

	rows, err := h.clientsDB.Query(ctx, query, agentID, limit)
	if err != nil {
		return executions
	}
	defer rows.Close()

	for rows.Next() {
		var exec struct {
			ID            string
			CorrelationID string
			Status        string
			StartedAt     time.Time
			CompletedAt   sql.NullTime
			InputData     json.RawMessage
			OutputData    json.RawMessage
			ErrorMessage  sql.NullString
		}

		if err := rows.Scan(&exec.ID, &exec.CorrelationID, &exec.Status,
			&exec.StartedAt, &exec.CompletedAt, &exec.InputData,
			&exec.OutputData, &exec.ErrorMessage); err != nil {
			continue
		}

		execution := map[string]interface{}{
			"id":             exec.ID,
			"correlation_id": exec.CorrelationID,
			"status":         exec.Status,
			"started_at":     exec.StartedAt,
			"duration_ms":    nil,
		}

		if exec.CompletedAt.Valid {
			duration := exec.CompletedAt.Time.Sub(exec.StartedAt).Milliseconds()
			execution["completed_at"] = exec.CompletedAt.Time
			execution["duration_ms"] = duration
		}

		if exec.ErrorMessage.Valid {
			execution["error"] = exec.ErrorMessage.String
		}

		executions = append(executions, execution)
	}

	return executions
}

func (h *AgentHandlers) notifyAgentDisabled(ctx context.Context, clientID, agentID, reason string) {
	notification := map[string]interface{}{
		"event_type": "AGENT_DISABLED",
		"client_id":  clientID,
		"agent_id":   agentID,
		"reason":     reason,
		"timestamp":  time.Now().UTC(),
	}

	notificationBytes, _ := json.Marshal(notification)
	headers := map[string]string{
		"correlation_id": uuid.NewString(),
		"event_type":     "agent_disabled",
	}

	h.kafkaProducer.Produce(ctx, "system.notifications.admin", headers,
		[]byte(agentID), notificationBytes)
}

// HandleUpdateInstanceConfig updates the configuration of a specific agent instance.
func (h *AgentHandlers) HandleUpdateInstanceConfig(c *gin.Context) {
	agentID := c.Param("agent_id")
	clientID := c.Param("client_id")

	var req struct {
		Config map[string]interface{} `json:"config" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body: " + err.Error()})
		return
	}

	// Now you can call the repository method directly from the handler
	err := h.personaRepo.AdminUpdateInstanceConfig(c.Request.Context(), clientID, agentID, req.Config)
	if err != nil {
		h.logger.Error("Failed to update instance config", zap.Error(err), zap.String("agent_id", agentID))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update instance config"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":   "Configuration updated successfully.",
		"agent_id":  agentID,
		"client_id": clientID,
	})
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/instance_swagger.go
package handlers

// NOTE: This file contains swagger annotations for the instance handlers.
// All types are defined in instance.go

// HandleCreateInstance godoc
// @Summary      Create instance
// @Description  Creates a new persona instance from a template
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        request body handlers.CreateInstanceRequest true "Instance creation details"
// @Success      201 {object} models.Persona "Instance created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Could not create instance"
// @Router       /api/v1/personas/instances [post]
// @Security     Bearer
// @ID           createInstance

// HandleListInstances godoc
// @Summary      List instances
// @Description  Returns all persona instances for the authenticated user
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Success      200 {object} handlers.InstanceListResponse "List of instances retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Could not retrieve instances"
// @Router       /api/v1/personas/instances [get]
// @Security     Bearer
// @ID           listInstances

// HandleGetInstance godoc
// @Summary      Get instance
// @Description  Returns a specific persona instance by ID
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        id path string true "Instance ID"
// @Success      200 {object} models.Persona "Instance details retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "Instance not found"
// @Router       /api/v1/personas/instances/{id} [get]
// @Security     Bearer
// @ID           getInstance

// HandleUpdateInstance godoc
// @Summary      Update instance
// @Description  Updates an existing persona instance
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        id path string true "Instance ID"
// @Param        request body handlers.UpdateInstanceRequest true "Instance update details"
// @Success      200 {object} models.Persona "Instance updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Failed to update instance"
// @Router       /api/v1/personas/instances/{id} [patch]
// @Security     Bearer
// @ID           updateInstance

// HandleDeleteInstance godoc
// @Summary      Delete instance
// @Description  Deletes a persona instance
// @Tags         Instances
// @Accept       json
// @Produce      json
// @Param        id path string true "Instance ID"
// @Success      204 {string} string "Instance deleted successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Failed to delete instance"
// @Router       /api/v1/personas/instances/{id} [delete]
// @Security     Bearer
// @ID           deleteInstance
-------------------------------------------------
filepath = ./internal/core-manager/handlers/template_swagger.go
package handlers

// NOTE: This file contains swagger annotations for the template handlers.
// All types are defined in template.go

// HandleCreateTemplate godoc
// @Summary      Create template
// @Description  Creates a new persona template (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        request body handlers.CreateTemplateRequest true "Template creation details"
// @Success      201 {object} models.Persona "Template created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to create template"
// @Router       /api/v1/templates [post]
// @Security     Bearer
// @ID           createTemplate

// HandleListTemplates godoc
// @Summary      List templates
// @Description  Returns all available persona templates (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Success      200 {object} handlers.TemplateListResponse "List of templates retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to retrieve templates"
// @Router       /api/v1/templates [get]
// @Security     Bearer
// @ID           listTemplates

// HandleGetTemplate godoc
// @Summary      Get template
// @Description  Returns a specific persona template by ID (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        id path string true "Template ID"
// @Success      200 {object} models.Persona "Template details retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      404 {object} map[string]interface{} "Template not found"
// @Router       /api/v1/templates/{id} [get]
// @Security     Bearer
// @ID           getTemplate

// HandleUpdateTemplate godoc
// @Summary      Update template
// @Description  Updates an existing persona template (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        id path string true "Template ID"
// @Param        request body handlers.CreateTemplateRequest true "Template update details"
// @Success      200 {object} models.Persona "Template updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to update template"
// @Router       /api/v1/templates/{id} [put]
// @Security     Bearer
// @ID           updateTemplate

// HandleDeleteTemplate godoc
// @Summary      Delete template
// @Description  Deletes a persona template (admin only)
// @Tags         Templates
// @Accept       json
// @Produce      json
// @Param        id path string true "Template ID"
// @Success      204 {string} string "Template deleted successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to delete template"
// @Router       /api/v1/templates/{id} [delete]
// @Security     Bearer
// @ID           deleteTemplate
-------------------------------------------------
filepath = ./internal/core-manager/handlers/health.go
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/platform/config"
	"go.uber.org/zap"
)

// HealthHandler handles health check endpoints
type HealthHandler struct {
	cfg    *config.ServiceConfig
	logger *zap.Logger
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(cfg *config.ServiceConfig, logger *zap.Logger) *HealthHandler {
	return &HealthHandler{
		cfg:    cfg,
		logger: logger,
	}
}

// HealthResponse represents the health check response
type HealthResponse struct {
	Status  string `json:"status" example:"healthy"`
	Service string `json:"service" example:"core-manager"`
	Version string `json:"version" example:"1.0.0"`
}

// HandleHealth returns the service health status
func (h *HealthHandler) HandleHealth(c *gin.Context) {
	response := HealthResponse{
		Status:  "healthy",
		Service: h.cfg.ServiceInfo.Name,
		Version: h.cfg.ServiceInfo.Version,
	}
	c.JSON(http.StatusOK, response)
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/template.go
// FILE: internal/core-manager/handlers/template.go
package handlers

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/gqls/agentchassis/pkg/models"
	"go.uber.org/zap"
)

// TemplateHandler handles template-related operations
type TemplateHandler struct {
	personaRepo models.PersonaRepository
	logger      *zap.Logger
}

// NewTemplateHandler creates a new template handler
func NewTemplateHandler(personaRepo models.PersonaRepository, logger *zap.Logger) *TemplateHandler {
	return &TemplateHandler{
		personaRepo: personaRepo,
		logger:      logger,
	}
}

// CreateTemplateRequest represents a request to create a template
type CreateTemplateRequest struct {
	Name        string                 `json:"name" binding:"required" example:"Customer Support Agent"`
	Description string                 `json:"description" example:"A helpful customer support agent template"`
	Category    string                 `json:"category" binding:"required" example:"support"`
	Config      map[string]interface{} `json:"config" binding:"required"`
}

// TemplateListResponse represents a list of templates
type TemplateListResponse struct {
	Templates []models.Persona `json:"templates"`
	Count     int              `json:"count" example:"10"`
}

// HandleCreateTemplate creates a new template
func (h *TemplateHandler) HandleCreateTemplate(c *gin.Context) {
	var req CreateTemplateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body: " + err.Error()})
		return
	}

	template := &models.Persona{
		ID:          uuid.New(),
		Name:        req.Name,
		Description: req.Description,
		Category:    req.Category,
		Config:      req.Config,
		IsTemplate:  true,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	createdTemplate, err := h.personaRepo.CreateTemplate(c.Request.Context(), template)
	if err != nil {
		h.logger.Error("Failed to create template", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create template"})
		return
	}

	c.JSON(http.StatusCreated, createdTemplate)
}

// HandleListTemplates returns all templates
func (h *TemplateHandler) HandleListTemplates(c *gin.Context) {
	templates, err := h.personaRepo.ListTemplates(c.Request.Context())
	if err != nil {
		h.logger.Error("Failed to list templates", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve templates"})
		return
	}

	response := TemplateListResponse{
		Templates: templates,
		Count:     len(templates),
	}
	c.JSON(http.StatusOK, response)
}

// HandleGetTemplate returns a specific template
func (h *TemplateHandler) HandleGetTemplate(c *gin.Context) {
	templateID := c.Param("id")
	template, err := h.personaRepo.GetTemplateByID(c.Request.Context(), templateID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Template not found"})
		return
	}
	c.JSON(http.StatusOK, template)
}

// HandleUpdateTemplate updates an existing template
func (h *TemplateHandler) HandleUpdateTemplate(c *gin.Context) {
	templateID := c.Param("id")

	var req CreateTemplateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	template := &models.Persona{
		ID:          uuid.MustParse(templateID),
		Name:        req.Name,
		Description: req.Description,
		Category:    req.Category,
		Config:      req.Config,
		UpdatedAt:   time.Now(),
	}

	updatedTemplate, err := h.personaRepo.UpdateTemplate(c.Request.Context(), template)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update template"})
		return
	}
	c.JSON(http.StatusOK, updatedTemplate)
}

// HandleDeleteTemplate deletes a template
func (h *TemplateHandler) HandleDeleteTemplate(c *gin.Context) {
	templateID := c.Param("id")
	if err := h.personaRepo.DeleteTemplate(c.Request.Context(), templateID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete template"})
		return
	}
	c.Status(http.StatusNoContent)
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/instance.go
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/gqls/agentchassis/internal/core-manager/middleware"
	"github.com/gqls/agentchassis/pkg/models"
	"go.uber.org/zap"
)

// InstanceHandler handles persona instance operations
type InstanceHandler struct {
	personaRepo models.PersonaRepository
	logger      *zap.Logger
}

// NewInstanceHandler creates a new instance handler
func NewInstanceHandler(personaRepo models.PersonaRepository, logger *zap.Logger) *InstanceHandler {
	return &InstanceHandler{
		personaRepo: personaRepo,
		logger:      logger,
	}
}

// CreateInstanceRequest represents a request to create an instance
type CreateInstanceRequest struct {
	TemplateID   string `json:"template_id" binding:"required,uuid" example:"123e4567-e89b-12d3-a456-426614174000"`
	InstanceName string `json:"instance_name" binding:"required" example:"My Support Agent"`
}

// UpdateInstanceRequest represents a request to update an instance
type UpdateInstanceRequest struct {
	Name   *string                `json:"name,omitempty" example:"Updated Agent Name"`
	Config map[string]interface{} `json:"config,omitempty"`
}

// InstanceListResponse represents a list of instances
type InstanceListResponse struct {
	Instances []models.Persona `json:"instances"`
	Count     int              `json:"count" example:"5"`
}

// HandleCreateInstance creates a new instance from a template
func (h *InstanceHandler) HandleCreateInstance(c *gin.Context) {
	claims := c.MustGet("user_claims").(*middleware.AuthClaims)

	var req CreateInstanceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	instance, err := h.personaRepo.CreateInstanceFromTemplate(c.Request.Context(),
		req.TemplateID, claims.UserID, req.InstanceName)
	if err != nil {
		h.logger.Error("Failed to create instance", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not create instance"})
		return
	}
	c.JSON(http.StatusCreated, instance)
}

// HandleGetInstance returns a specific instance
func (h *InstanceHandler) HandleGetInstance(c *gin.Context) {
	instanceID := c.Param("id")
	instance, err := h.personaRepo.GetInstanceByID(c.Request.Context(), instanceID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Instance not found"})
		return
	}
	c.JSON(http.StatusOK, instance)
}

// HandleListInstances returns all instances for the current user
func (h *InstanceHandler) HandleListInstances(c *gin.Context) {
	claims := c.MustGet("user_claims").(*middleware.AuthClaims)
	instances, err := h.personaRepo.ListInstances(c.Request.Context(), claims.UserID)
	if err != nil {
		h.logger.Error("Failed to list instances", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not retrieve instances"})
		return
	}

	response := InstanceListResponse{
		Instances: instances,
		Count:     len(instances),
	}
	c.JSON(http.StatusOK, response)
}

// HandleUpdateInstance updates an existing instance
func (h *InstanceHandler) HandleUpdateInstance(c *gin.Context) {
	instanceID := c.Param("id")

	var req UpdateInstanceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	updatedInstance, err := h.personaRepo.UpdateInstance(c.Request.Context(), instanceID, req.Name, req.Config)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update instance"})
		return
	}
	c.JSON(http.StatusOK, updatedInstance)
}

// HandleDeleteInstance deletes an instance
func (h *InstanceHandler) HandleDeleteInstance(c *gin.Context) {
	instanceID := c.Param("id")
	if err := h.personaRepo.DeleteInstance(c.Request.Context(), instanceID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete instance"})
		return
	}
	c.Status(http.StatusNoContent)
}
-------------------------------------------------
filepath = ./internal/core-manager/handlers/health_swagger.go
package handlers

// NOTE: This file contains swagger annotations for the health handler.
// All types are defined in health.go

// HandleHealth godoc
// @Summary      Health check
// @Description  Returns the health status of the Core Manager service
// @Tags         System
// @Accept       json
// @Produce      json
// @Success      200 {object} handlers.HealthResponse "Service is healthy"
// @Router       /health [get]
// @ID           healthCheck
-------------------------------------------------
filepath = ./internal/core-manager/middleware/auth.go
// FILE: internal/core-manager/middleware/auth.go
package middleware

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/gqls/agentchassis/platform/config"
	"go.uber.org/zap"
)

// AuthClaims represents the JWT claims
type AuthClaims struct {
	UserID      string   `json:"user_id"`
	Email       string   `json:"email"`
	ClientID    string   `json:"client_id"`
	Role        string   `json:"role"`
	Tier        string   `json:"tier"`
	Permissions []string `json:"permissions,omitempty"`
	jwt.RegisteredClaims
}

// AuthMiddlewareConfig holds configuration for auth middleware
type AuthMiddlewareConfig struct {
	JWTSecret      []byte
	AuthServiceURL string
	Logger         *zap.Logger
}

// NewAuthMiddlewareConfig creates auth middleware configuration from service config
func NewAuthMiddlewareConfig(cfg *config.ServiceConfig, logger *zap.Logger) (*AuthMiddlewareConfig, error) {
	// Get JWT secret from environment
	jwtSecretEnvVar := "JWT_SECRET_KEY"
	if cfg.Custom != nil {
		if envVar, ok := cfg.Custom["jwt_secret_env_var"].(string); ok {
			jwtSecretEnvVar = envVar
		}
	}

	jwtSecret := os.Getenv(jwtSecretEnvVar)
	if jwtSecret == "" {
		return nil, fmt.Errorf("JWT secret not found in environment variable %s", jwtSecretEnvVar)
	}

	// Get auth service URL
	authServiceURL := "http://auth-service:8081"
	if cfg.Custom != nil {
		if url, ok := cfg.Custom["auth_service_url"].(string); ok {
			authServiceURL = url
		}
	}

	return &AuthMiddlewareConfig{
		JWTSecret:      []byte(jwtSecret),
		AuthServiceURL: authServiceURL,
		Logger:         logger,
	}, nil
}

// AuthMiddleware validates JWT tokens
func AuthMiddleware(config *AuthMiddlewareConfig) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			// Also check X-Authorization header (for proxied requests)
			authHeader = c.GetHeader("X-Authorization")
		}

		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		tokenString := strings.Replace(authHeader, "Bearer ", "", 1)

		// Parse and validate token
		token, err := jwt.ParseWithClaims(tokenString, &AuthClaims{}, func(token *jwt.Token) (interface{}, error) {
			// Validate signing method
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return config.JWTSecret, nil
		})

		if err != nil {
			config.Logger.Debug("Token validation failed", zap.Error(err))

			// Optionally validate with auth service
			if isValid := validateWithAuthService(config, tokenString); !isValid {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
				c.Abort()
				return
			}
		}

		if claims, ok := token.Claims.(*AuthClaims); ok && token.Valid {
			// Set user context
			c.Set("user_claims", claims)
			c.Set("user_id", claims.UserID)
			c.Set("client_id", claims.ClientID)
			c.Set("user_email", claims.Email)
			c.Set("user_role", claims.Role)
			c.Set("user_tier", claims.Tier)
			c.Set("user_permissions", claims.Permissions)
			c.Next()
		} else {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			c.Abort()
			return
		}
	}
}

// validateWithAuthService validates token with auth service (optional fallback)
func validateWithAuthService(config *AuthMiddlewareConfig, token string) bool {
	client := &http.Client{Timeout: 5 * time.Second}

	req, err := http.NewRequest("POST", config.AuthServiceURL+"/api/v1/auth/validate", nil)
	if err != nil {
		config.Logger.Error("Failed to create validation request", zap.Error(err))
		return false
	}

	req.Header.Set("Authorization", "Bearer "+token)

	resp, err := client.Do(req)
	if err != nil {
		config.Logger.Error("Failed to validate with auth service", zap.Error(err))
		return false
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return false
	}

	var result struct {
		Valid bool `json:"valid"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return false
	}

	return result.Valid
}

// TenantMiddleware sets up tenant context
func TenantMiddleware(logger *zap.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		claims, exists := c.Get("user_claims")
		if !exists {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "No user claims found"})
			c.Abort()
			return
		}

		authClaims, ok := claims.(*AuthClaims)
		if !ok {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid claims type"})
			c.Abort()
			return
		}

		// Set tenant context for database operations
		c.Set("client_id", authClaims.ClientID)
		c.Set("user_id", authClaims.UserID)

		c.Next()
	}
}

// AdminOnly restricts access to admin users
func AdminOnly() gin.HandlerFunc {
	return func(c *gin.Context) {
		role, exists := c.Get("user_role")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "No role found"})
			c.Abort()
			return
		}

		if role != "admin" {
			c.JSON(http.StatusForbidden, gin.H{"error": "Admin access required"})
			c.Abort()
			return
		}

		c.Next()
	}
}
-------------------------------------------------
filepath = ./internal/core-manager/API.md
# Core Manager Internal API Documentation

## Overview

The Core Manager service is responsible for managing persona templates and instances. It serves as the central management hub for all persona-related operations.

## Internal HTTP Endpoints

### Health Check
```
GET /internal/health
```

Returns the health status of the service.

**Response:**
```json
{
  "status": "healthy",
  "service": "core-manager",
  "version": "1.0.0",
  "database": "connected"
}
```

## External HTTP Endpoints (via Auth Service Gateway)

These endpoints are accessed through the auth-service gateway with authentication.

### Persona Templates

#### List Templates
```
GET /api/v1/templates
```

Returns all available persona templates.

**Required Role:** Admin

**Response:**
```json
{
  "templates": [
    {
      "id": "uuid",
      "name": "Copywriter",
      "description": "Creates compelling marketing copy",
      "category": "data-driven",
      "config": {
        "model": "claude-3-sonnet",
        "temperature": 0.7
      },
      "is_active": true,
      "created_at": "2024-01-01T00:00:00Z",
      "updated_at": "2024-01-01T00:00:00Z"
    }
  ],
  "count": 1
}
```

### Persona Instances

#### Create Instance
```
POST /api/v1/personas/instances
```

Creates a new persona instance from a template.

**Request:**
```json
{
  "template_id": "template-uuid",
  "name": "My Marketing Assistant",
  "project_id": "project-uuid",
  "config": {
    "custom_prompt": "Focus on B2B technology companies"
  }
}
```

**Response:**
```json
{
  "id": "instance-uuid",
  "template_id": "template-uuid",
  "name": "My Marketing Assistant",
  "owner_user_id": "user-uuid",
  "config": {
    "model": "claude-3-sonnet",
    "temperature": 0.7,
    "custom_prompt": "Focus on B2B technology companies"
  },
  "is_active": true,
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-01T00:00:00Z"
}
```

## Kafka Topics

### Consumed Topics

#### system.personas.commands
Commands for persona management operations.

**Message Format:**
```json
{
  "action": "create_instance|update_instance|delete_instance",
  "data": {
    // Action-specific data
  }
}
```

**Required Headers:**
- `correlation_id`: Unique request identifier
- `request_id`: Request tracking ID
- `client_id`: Client identifier
- `user_id`: User performing the action

### Produced Topics

#### system.personas.events
Events related to persona lifecycle.

**Message Format:**
```json
{
  "event": "instance_created|instance_updated|instance_deleted",
  "data": {
    "instance_id": "uuid",
    "template_id": "uuid",
    "user_id": "uuid",
    // Event-specific data
  },
  "timestamp": "2024-01-01T00:00:00Z"
}
```

## Database Schema

The Core Manager uses the `clients` PostgreSQL database with client-specific schemas.

### Global Tables

#### agent_definitions
```sql
CREATE TABLE agent_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(100) NOT NULL UNIQUE,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL,
    default_config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);
```

### Client-Specific Tables (in schema `client_{client_id}`)

#### agent_instances
```sql
CREATE TABLE agent_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id UUID NOT NULL,
    owner_user_id VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

## Environment Variables

```bash
# Database
CLIENTS_DB_HOST=postgres-clients
CLIENTS_DB_PORT=5432
CLIENTS_DB_NAME=clients_db
CLIENTS_DB_USER=clients_user
CLIENTS_DB_PASSWORD=<password>

# Templates Database
TEMPLATES_DB_HOST=postgres-templates
TEMPLATES_DB_PORT=5432
TEMPLATES_DB_NAME=templates_db
TEMPLATES_DB_USER=templates_user
TEMPLATES_DB_PASSWORD=<password>

# Kafka
KAFKA_BROKERS=kafka-0:9092,kafka-1:9092,kafka-2:9092

# Service
SERVICE_PORT=8088
LOG_LEVEL=info
```

## Integration Notes

### For Auth Service
- All requests should include user context headers
- Validate quota limits before creating instances
- Check user permissions for admin operations

### For Agent Services
- Subscribe to `system.personas.events` for instance lifecycle events
- Use instance configuration when processing requests
- Report usage metrics back to core-manager

### Error Handling
The service returns standard HTTP status codes:
- 200: Success
- 201: Created
- 400: Bad Request
- 401: Unauthorized
- 403: Forbidden (quota exceeded or insufficient permissions)
- 404: Not Found
- 500: Internal Server Error

Error responses follow the format:
```json
{
  "error": {
    "code": "PERSONA_001",
    "message": "Human-readable error message",
    "details": {
      // Additional context
    }
  }
}
```-------------------------------------------------
filepath = ./internal/core-manager/database/personas.go
// FILE: internal/core-manager/database/personas.go

package database

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/gqls/agentchassis/pkg/models"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

type PersonaRepository struct {
	templatesDB *pgxpool.Pool
	clientsDB   *pgxpool.Pool
	logger      *zap.Logger
}

// NewPersonaRepository creates a new repository instance
func NewPersonaRepository(templatesDB, clientsDB *pgxpool.Pool, logger *zap.Logger) *PersonaRepository {
	return &PersonaRepository{
		templatesDB: templatesDB,
		clientsDB:   clientsDB,
		logger:      logger,
	}
}

// ClientsDB returns the clients database pool
func (r *PersonaRepository) ClientsDB() *pgxpool.Pool {
	return r.clientsDB
}

// TemplatesDB returns the templates database pool
func (r *PersonaRepository) TemplatesDB() *pgxpool.Pool {
	return r.templatesDB
}

// Template Methods

func (r *PersonaRepository) CreateTemplate(ctx context.Context, template *models.Persona) (*models.Persona, error) {
	r.logger.Info("Creating new persona template", zap.String("name", template.Name))

	configJSON, _ := json.Marshal(template.Config)

	query := `
        INSERT INTO persona_templates (id, name, description, category, config, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id
    `

	err := r.templatesDB.QueryRow(ctx, query,
		template.ID,
		template.Name,
		template.Description,
		template.Category,
		configJSON,
		true,
		template.CreatedAt,
		template.UpdatedAt,
	).Scan(&template.ID)

	if err != nil {
		r.logger.Error("Failed to create template", zap.Error(err))
		return nil, fmt.Errorf("failed to create template: %w", err)
	}

	return template, nil
}

func (r *PersonaRepository) GetTemplateByID(ctx context.Context, id string) (*models.Persona, error) {
	r.logger.Info("Getting template by ID", zap.String("id", id))

	var template models.Persona
	var configJSON []byte

	query := `
        SELECT id, name, description, category, config, is_active, created_at, updated_at
        FROM persona_templates
        WHERE id = $1 AND is_active = true
    `

	err := r.templatesDB.QueryRow(ctx, query, id).Scan(
		&template.ID,
		&template.Name,
		&template.Description,
		&template.Category,
		&configJSON,
		&template.IsActive,
		&template.CreatedAt,
		&template.UpdatedAt,
	)

	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, fmt.Errorf("template not found")
		}
		return nil, fmt.Errorf("failed to get template: %w", err)
	}

	json.Unmarshal(configJSON, &template.Config)
	template.IsTemplate = true

	return &template, nil
}

func (r *PersonaRepository) ListTemplates(ctx context.Context) ([]models.Persona, error) {
	r.logger.Info("Listing all templates")

	query := `
        SELECT id, name, description, category, config, is_active, created_at, updated_at
        FROM persona_templates
        WHERE is_active = true
        ORDER BY category, name
    `

	rows, err := r.templatesDB.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to list templates: %w", err)
	}
	defer rows.Close()

	var templates []models.Persona
	for rows.Next() {
		var template models.Persona
		var configJSON []byte

		err := rows.Scan(
			&template.ID,
			&template.Name,
			&template.Description,
			&template.Category,
			&configJSON,
			&template.IsActive,
			&template.CreatedAt,
			&template.UpdatedAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan template row", zap.Error(err))
			continue
		}

		json.Unmarshal(configJSON, &template.Config)
		template.IsTemplate = true
		templates = append(templates, template)
	}

	return templates, nil
}

func (r *PersonaRepository) UpdateTemplate(ctx context.Context, template *models.Persona) (*models.Persona, error) {
	r.logger.Info("Updating template", zap.String("id", template.ID.String()))

	configJSON, _ := json.Marshal(template.Config)

	query := `
        UPDATE persona_templates
        SET name = $2, description = $3, category = $4, config = $5, updated_at = $6
        WHERE id = $1
        RETURNING updated_at
    `

	err := r.templatesDB.QueryRow(ctx, query,
		template.ID,
		template.Name,
		template.Description,
		template.Category,
		configJSON,
		time.Now(),
	).Scan(&template.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to update template: %w", err)
	}

	return template, nil
}

func (r *PersonaRepository) DeleteTemplate(ctx context.Context, id string) error {
	r.logger.Info("Deleting template", zap.String("id", id))

	// Soft delete
	query := `UPDATE persona_templates SET is_active = false, updated_at = $2 WHERE id = $1`

	_, err := r.templatesDB.Exec(ctx, query, id, time.Now())
	if err != nil {
		return fmt.Errorf("failed to delete template: %w", err)
	}

	return nil
}

// Instance Methods

func (r *PersonaRepository) CreateInstanceFromTemplate(ctx context.Context, templateID string, userID string, instanceName string) (*models.Persona, error) {
	r.logger.Info("Creating instance from template",
		zap.String("templateID", templateID),
		zap.String("userID", userID))

	// Get client ID from context
	clientID, ok := ctx.Value("client_id").(string)
	if !ok {
		return nil, fmt.Errorf("client_id not found in context")
	}

	// First, fetch the template
	template, err := r.GetTemplateByID(ctx, templateID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch template: %w", err)
	}

	// Create the instance
	instance := &models.Persona{
		ID:          uuid.New(),
		Name:        instanceName,
		Description: template.Description,
		Category:    template.Category,
		Config:      template.Config,
		IsTemplate:  false,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	configJSON, _ := json.Marshal(instance.Config)

	// Use client-specific schema
	query := fmt.Sprintf(`
        INSERT INTO client_%s.agent_instances 
        (id, template_id, owner_user_id, name, config, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `, clientID)

	_, err = r.clientsDB.Exec(ctx, query,
		instance.ID,
		templateID,
		userID,
		instance.Name,
		configJSON,
		true,
		instance.CreatedAt,
		instance.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create instance: %w", err)
	}

	return instance, nil
}

func (r *PersonaRepository) GetInstanceByID(ctx context.Context, id string) (*models.Persona, error) {
	clientID, _ := ctx.Value("client_id").(string)

	var instance models.Persona
	var configJSON []byte

	query := fmt.Sprintf(`
        SELECT id, name, config, is_active, created_at, updated_at
        FROM client_%s.agent_instances
        WHERE id = $1 AND is_active = true
    `, clientID)

	err := r.clientsDB.QueryRow(ctx, query, id).Scan(
		&instance.ID,
		&instance.Name,
		&configJSON,
		&instance.IsActive,
		&instance.CreatedAt,
		&instance.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to get instance: %w", err)
	}

	json.Unmarshal(configJSON, &instance.Config)
	return &instance, nil
}

func (r *PersonaRepository) ListInstances(ctx context.Context, userID string) ([]models.Persona, error) {
	clientID, _ := ctx.Value("client_id").(string)

	query := fmt.Sprintf(`
        SELECT id, name, config, is_active, created_at, updated_at
        FROM client_%s.agent_instances
        WHERE owner_user_id = $1 AND is_active = true
        ORDER BY created_at DESC
    `, clientID)

	rows, err := r.clientsDB.Query(ctx, query, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to list instances: %w", err)
	}
	defer rows.Close()

	var instances []models.Persona
	for rows.Next() {
		var instance models.Persona
		var configJSON []byte

		err := rows.Scan(
			&instance.ID,
			&instance.Name,
			&configJSON,
			&instance.IsActive,
			&instance.CreatedAt,
			&instance.UpdatedAt,
		)
		if err != nil {
			continue
		}

		json.Unmarshal(configJSON, &instance.Config)
		instances = append(instances, instance)
	}

	return instances, nil
}

func (r *PersonaRepository) UpdateInstance(ctx context.Context, id string, name *string, config map[string]interface{}) (*models.Persona, error) {
	clientID, _ := ctx.Value("client_id").(string)

	// First get the current instance
	instance, err := r.GetInstanceByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Update fields
	if name != nil {
		instance.Name = *name
	}
	if config != nil {
		// Merge configs
		for k, v := range config {
			instance.Config[k] = v
		}
	}

	configJSON, _ := json.Marshal(instance.Config)

	query := fmt.Sprintf(`
        UPDATE client_%s.agent_instances
        SET name = $2, config = $3, updated_at = $4
        WHERE id = $1
    `, clientID)

	_, err = r.clientsDB.Exec(ctx, query, id, instance.Name, configJSON, time.Now())
	if err != nil {
		return nil, fmt.Errorf("failed to update instance: %w", err)
	}

	return instance, nil
}

func (r *PersonaRepository) DeleteInstance(ctx context.Context, id string) error {
	clientID, _ := ctx.Value("client_id").(string)

	query := fmt.Sprintf(`
        UPDATE client_%s.agent_instances
        SET is_active = false, updated_at = $2
        WHERE id = $1
    `, clientID)

	_, err := r.clientsDB.Exec(ctx, query, id, time.Now())
	if err != nil {
		return fmt.Errorf("failed to delete instance: %w", err)
	}

	return nil
}

// AdminUpdateInstanceConfig allows an admin to update an instance's config
func (r *PersonaRepository) AdminUpdateInstanceConfig(ctx context.Context, clientID, instanceID string, config map[string]interface{}) error {
	r.logger.Info("Admin updating instance config", zap.String("instance_id", instanceID), zap.String("client_id", clientID))

	configJSON, err := json.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	query := fmt.Sprintf(`
        UPDATE client_%s.agent_instances
        SET config = $2, updated_at = NOW()
        WHERE id = $1
    `, clientID)

	res, err := r.clientsDB.Exec(ctx, query, instanceID, configJSON)
	if err != nil {
		return fmt.Errorf("failed to execute update: %w", err)
	}

	if res.RowsAffected() == 0 {
		return fmt.Errorf("instance not found")
	}

	return nil
}
-------------------------------------------------
filepath = ./configs/core-manager.yaml
# FILE: configs/core-manager.yaml
service_info:
  name: "core-manager"
  version: "1.0.0"
  environment: "development"

server:
  port: "8088"

logging:
  level: "info"

observability:
  tracing_endpoint: "otel-collector.monitoring.svc.cluster.local:4317"

infrastructure:
  kafka_brokers:
    - "kafka-0.kafka-headless:9092"
    - "kafka-1.kafka-headless:9092"
    - "kafka-2.kafka-headless:9092"
  
  clients_database:
    host: "postgres-clients.database.svc.cluster.local"
    port: 5432
    user: "clients_user"
    password_env_var: "CLIENTS_DB_PASSWORD"
    db_name: "clients_db"
    sslmode: "disable"
  
  templates_database:
    host: "postgres-templates.database.svc.cluster.local"
    port: 5432
    user: "templates_user"
    password_env_var: "TEMPLATES_DB_PASSWORD"
    db_name: "templates_db"
    sslmode: "disable"
  
  auth_database: {}
  
  object_storage:
    provider: "s3"
    endpoint: "http://minio.storage.svc.cluster.local:9000"
    bucket: "agent-artifacts"
    access_key_env_var: "MINIO_ACCESS_KEY"
    secret_key_env_var: "MINIO_SECRET_KEY"

custom:
  jwt_secret_env_var: "JWT_SECRET_KEY"  # Add this
  auth_service_url: "http://auth-service:8081"  # Add this for validation-------------------------------------------------
filepath = ./go.mod
// FILE: go.mod
module github.com/gqls/agentchassis

go 1.23.0

toolchain go1.24.4

require (
	github.com/DATA-DOG/go-sqlmock v1.5.2
	github.com/aws/aws-sdk-go-v2 v1.25.1
	github.com/aws/aws-sdk-go-v2/config v1.27.0
	github.com/aws/aws-sdk-go-v2/credentials v1.17.0
	github.com/aws/aws-sdk-go-v2/service/s3 v1.51.0
	github.com/gin-gonic/gin v1.10.1
	github.com/go-sql-driver/mysql v1.7.1
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.1
	github.com/jackc/pgx/v5 v5.5.5
	github.com/pgvector/pgvector-go v0.1.1
	github.com/prometheus/client_golang v1.22.0
	github.com/rs/cors v1.10.1
	github.com/segmentio/kafka-go v0.4.47
	github.com/sony/gobreaker v1.0.0
	github.com/spf13/viper v1.18.2
	github.com/stretchr/testify v1.10.0
	go.opentelemetry.io/otel v1.29.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.29.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
	go.opentelemetry.io/otel/sdk v1.29.0
	go.opentelemetry.io/otel/trace v1.29.0
	go.uber.org/zap v1.27.0
	golang.org/x/crypto v0.40.0
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.2.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.1 // indirect
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.15.0 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.1 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/sso v1.19.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.22.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.27.0 // indirect
	github.com/aws/smithy-go v1.20.1 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/bytedance/sonic v1.13.3 // indirect
	github.com/bytedance/sonic/loader v0.3.0 // indirect
	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/chenzhuoyu/base64x v0.0.0-20230717121745-296ad89f973d // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.7 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/fsnotify/fsnotify v1.7.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.9 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-openapi/jsonpointer v0.21.1 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/swag v0.23.1 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.27.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.20.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/puddle/v2 v2.2.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/compress v1.18.0 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pierrec/lz4/v4 v4.1.22 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/prometheus/client_model v0.6.1 // indirect
	github.com/prometheus/common v0.62.0 // indirect
	github.com/prometheus/procfs v0.15.1 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/sagikazarmark/locafero v0.4.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.11.0 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/swaggo/files v1.0.1 // indirect
	github.com/swaggo/gin-swagger v1.6.0 // indirect
	github.com/swaggo/swag v1.16.5 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.0 // indirect
	github.com/urfave/cli/v2 v2.27.7 // indirect
	github.com/xrash/smetrics v0.0.0-20250705151800-55b8f293f342 // indirect
	go.opentelemetry.io/otel/metric v1.29.0 // indirect
	go.opentelemetry.io/proto/otlp v1.3.1 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	go.yaml.in/yaml/v2 v2.4.2 // indirect
	golang.org/x/arch v0.19.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/mod v0.26.0 // indirect
	golang.org/x/net v0.42.0 // indirect
	golang.org/x/sync v0.16.0 // indirect
	golang.org/x/sys v0.34.0 // indirect
	golang.org/x/text v0.27.0 // indirect
	golang.org/x/tools v0.35.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240513163218-0867130af1f8 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240513163218-0867130af1f8 // indirect
	google.golang.org/grpc v1.64.1 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	sigs.k8s.io/yaml v1.5.0 // indirect
)
-------------------------------------------------
