filepath = ./platform/database/migrations/001_enable_pgvector.sql
-- FILE: platform/database/migrations/001_enable_pgvector.sql
-- Run this on the clients database as superuser
CREATE EXTENSION IF NOT EXISTS vector;
-------------------------------------------------
filepath = ./platform/database/migrations/005_projects_schema.sql
// FILE: platform/database/migrations/005_projects_schema.sql
-- Projects table for auth database
CREATE TABLE IF NOT EXISTS projects (
                                        id VARCHAR(36) PRIMARY KEY,
    client_id VARCHAR(100) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    owner_id VARCHAR(36) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (owner_id) REFERENCES users(id),
    INDEX idx_projects_client (client_id),
    INDEX idx_projects_owner (owner_id)
    );

-- Subscriptions table
CREATE TABLE IF NOT EXISTS subscriptions (
                                             id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL UNIQUE,
    tier VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL,
    start_date TIMESTAMPTZ NOT NULL,
    end_date TIMESTAMPTZ,
    trial_ends_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,
    payment_method VARCHAR(100),
    stripe_customer_id VARCHAR(255),
    stripe_subscription_id VARCHAR(255),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(id),
    INDEX idx_subscriptions_status (status)
    );

-- Subscription tiers table
CREATE TABLE IF NOT EXISTS subscription_tiers (
                                                  id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    price_monthly DECIMAL(10,2) NOT NULL,
    price_yearly DECIMAL(10,2) NOT NULL,
    max_personas INT NOT NULL,
    max_projects INT NOT NULL,
    max_content_items INT NOT NULL,
    features JSON,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- Insert default tiers
INSERT INTO subscription_tiers (id, name, display_name, description, price_monthly, price_yearly, max_personas, max_projects, max_content_items, features) VALUES
                                                                                                                                                               ('00000000-0000-0000-0000-000000000001', 'free', 'Free', 'Basic features for getting started', 0.00, 0.00, 1, 3, 10, '["Basic personas", "Limited content generation"]'),
                                                                                                                                                               ('00000000-0000-0000-0000-000000000002', 'basic', 'Basic', 'For individual users', 9.99, 99.99, 5, 10, 100, '["All persona types", "Priority support", "Advanced templates"]'),
                                                                                                                                                               ('00000000-0000-0000-0000-000000000003', 'premium', 'Premium', 'For power users', 29.99, 299.99, 20, 50, 1000, '["All basic features", "Custom personas", "API access", "Analytics"]'),
                                                                                                                                                               ('00000000-0000-0000-0000-000000000004', 'enterprise', 'Enterprise', 'For organizations', 99.99, 999.99, -1, -1, -1, '["All premium features", "Unlimited usage", "Dedicated support", "Custom integrations"]');

-- User profiles table
CREATE TABLE IF NOT EXISTS user_profiles (
                                             user_id VARCHAR(36) PRIMARY KEY,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    company VARCHAR(255),
    phone VARCHAR(50),
    avatar_url VARCHAR(500),
    preferences JSON,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(id)
    );

-- Permissions table
CREATE TABLE IF NOT EXISTS permissions (
                                           id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- User permissions junction table
CREATE TABLE IF NOT EXISTS user_permissions (
                                                user_id VARCHAR(36) NOT NULL,
    permission_id VARCHAR(36) NOT NULL,
    granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (user_id, permission_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (permission_id) REFERENCES permissions(id)
    );

-- Insert default permissions
INSERT INTO permissions (id, name, description) VALUES
                                                    ('00000000-0000-0000-0000-000000000001', 'personas.create', 'Create new personas'),
                                                    ('00000000-0000-0000-0000-000000000002', 'personas.delete', 'Delete personas'),
                                                    ('00000000-0000-0000-0000-000000000003', 'projects.manage', 'Manage all projects'),
                                                    ('00000000-0000-0000-0000-000000000004', 'admin.users', 'Manage users'),
                                                    ('00000000-0000-0000-0000-000000000005', 'admin.subscriptions', 'Manage subscriptions'),
                                                    ('00000000-0000-0000-0000-000000000006', '*', 'Super admin - all permissions');-------------------------------------------------
filepath = ./platform/database/migrations/003_create_client_schema.sql
-- FILE: platform/database/migrations/003_create_client_schema.sql


-- Enable required extensions

-- Global agent definitions table (shared across all clients)
CREATE TABLE IF NOT EXISTS agent_definitions (
                                                 id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(100) NOT NULL UNIQUE,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL CHECK (category IN ('data-driven', 'code-driven', 'adapter')),
    default_config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
    );

-- Index for active agent types
CREATE INDEX IF NOT EXISTS idx_agent_definitions_type_active
    ON agent_definitions(type, is_active) WHERE deleted_at IS NULL;

-- Global orchestrator state table (shared across all clients)
CREATE TABLE IF NOT EXISTS orchestrator_state (
                                                  correlation_id UUID PRIMARY KEY,
                                                  client_id VARCHAR(100) NOT NULL,
    status VARCHAR(50) NOT NULL,
    current_step VARCHAR(255) NOT NULL,
    awaited_steps JSONB DEFAULT '[]',
    collected_data JSONB DEFAULT '{}',
    initial_request_data JSONB,
    final_result JSONB,
    error TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- Indexes for orchestrator state
CREATE INDEX IF NOT EXISTS idx_orchestrator_state_status ON orchestrator_state(status);
CREATE INDEX IF NOT EXISTS idx_orchestrator_state_client ON orchestrator_state(client_id);
CREATE INDEX IF NOT EXISTS idx_orchestrator_state_updated_at ON orchestrator_state(updated_at);

-- Function to create client-specific schema
CREATE OR REPLACE FUNCTION create_client_schema(client_id TEXT)
RETURNS VOID AS $$
DECLARE
schema_name TEXT := 'client_' || client_id;
BEGIN
    -- Create schema
EXECUTE format('CREATE SCHEMA IF NOT EXISTS %I', schema_name);

-- Agent instances table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.agent_instances (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            template_id UUID NOT NULL,
            owner_user_id VARCHAR(255) NOT NULL,
            name VARCHAR(255) NOT NULL,
            config JSONB NOT NULL DEFAULT ''{}''::jsonb,
            is_active BOOLEAN DEFAULT true,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name);

-- Indexes for agent instances
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_instances_owner
        ON %I.agent_instances(owner_user_id)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_instances_template
        ON %I.agent_instances(template_id)', schema_name);

-- Agent memory table with vector support
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.agent_memory (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            agent_instance_id UUID NOT NULL REFERENCES %I.agent_instances(id),
            content TEXT NOT NULL,
            embedding vector(1536) NOT NULL,
            metadata JSONB DEFAULT ''{}''::jsonb,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name, schema_name);

-- Vector index for similarity search
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_memory_embedding
        ON %I.agent_memory USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100)', schema_name);

-- Index for agent memory queries
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_memory_agent_created
        ON %I.agent_memory(agent_instance_id, created_at DESC)', schema_name);

-- Projects table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.projects (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            name VARCHAR(255) NOT NULL,
            description TEXT,
            owner_user_id VARCHAR(255) NOT NULL,
            settings JSONB DEFAULT ''{}''::jsonb,
            is_active BOOLEAN DEFAULT true,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name);

-- Index for project queries
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_projects_owner
        ON %I.projects(owner_user_id)', schema_name);

-- Workflow executions table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.workflow_executions (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            correlation_id UUID NOT NULL,
            project_id UUID REFERENCES %I.projects(id),
            agent_instance_id UUID REFERENCES %I.agent_instances(id),
            status VARCHAR(50) NOT NULL,
            input_data JSONB,
            output_data JSONB,
            error_message TEXT,
            started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            completed_at TIMESTAMPTZ,
            created_by VARCHAR(255) NOT NULL
        )', schema_name, schema_name, schema_name);

-- Indexes for workflow executions
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_workflow_executions_correlation
        ON %I.workflow_executions(correlation_id)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_workflow_executions_status
        ON %I.workflow_executions(status)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_workflow_executions_project
        ON %I.workflow_executions(project_id)', schema_name);

-- Usage analytics table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.usage_analytics (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id VARCHAR(255) NOT NULL,
            agent_type VARCHAR(100) NOT NULL,
            action VARCHAR(100) NOT NULL,
            fuel_consumed INTEGER NOT NULL DEFAULT 0,
            execution_time_ms INTEGER,
            success BOOLEAN NOT NULL,
            metadata JSONB DEFAULT ''{}''::jsonb,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name);

-- Indexes for analytics
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_usage_analytics_user_date
        ON %I.usage_analytics(user_id, created_at)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_usage_analytics_agent_type
        ON %I.usage_analytics(agent_type, created_at)', schema_name);

END;
$$ LANGUAGE plpgsql;

-- Insert default agent definitions
INSERT INTO agent_definitions (type, display_name, description, category, default_config) VALUES
                                                                                              ('copywriter', 'Copywriter', 'Creates compelling marketing and content copy', 'data-driven', '{"model": "claude-3-sonnet", "temperature": 0.7}'),
                                                                                              ('researcher', 'Research Assistant', 'Conducts thorough research and analysis', 'data-driven', '{"model": "claude-3-opus", "temperature": 0.3}'),
                                                                                              ('reasoning', 'Reasoning Agent', 'Performs logical analysis and decision making', 'code-driven', '{"model": "claude-3-opus", "temperature": 0.2}'),
                                                                                              ('image-generator', 'Image Generator', 'Creates images using AI generation', 'adapter', '{"provider": "stability_ai", "model": "sdxl"}'),
                                                                                              ('web-search', 'Web Search', 'Searches the internet for information', 'adapter', '{"provider": "serpapi", "max_results": 10}')
    ON CONFLICT (type) DO UPDATE SET
    display_name = EXCLUDED.display_name,
                              description = EXCLUDED.description,
                              category = EXCLUDED.category,
                              default_config = EXCLUDED.default_config,
                              updated_at = NOW();

-- Create a demo client schema for testing
SELECT create_client_schema('demo_client');


-- This should be run for each new client
-- Replace {client_id} with actual client ID

CREATE SCHEMA IF NOT EXISTS client_{client_id};

-- Agent instances table
CREATE TABLE IF NOT EXISTS client_{client_id}.agent_instances (
                                                                  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id UUID NOT NULL,
    owner_user_id VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_instances_owner ON client_{client_id}.agent_instances(owner_user_id);
CREATE INDEX idx_instances_template ON client_{client_id}.agent_instances(template_id);

-- Agent memory table with vector support
CREATE TABLE IF NOT EXISTS client_{client_id}.agent_memory (
                                                               id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_instance_id UUID NOT NULL REFERENCES client_{client_id}.agent_instances(id),
    content TEXT NOT NULL,
    embedding vector(1536) NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- Create vector index for similarity search
CREATE INDEX ON client_{client_id}.agent_memory USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- Orchestrator state table
CREATE TABLE IF NOT EXISTS client_{client_id}.orchestrator_state (
                                                                     correlation_id UUID PRIMARY KEY,
                                                                     status VARCHAR(50) NOT NULL,
    current_step VARCHAR(255) NOT NULL,
    awaited_steps JSONB DEFAULT '[]',
    collected_data JSONB DEFAULT '{}',
    initial_request_data JSONB,
    final_result JSONB,
    error TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_orchestrator_status ON client_{client_id}.orchestrator_state(status);

CREATE INDEX idx_memory_agent_created ON client_{client_id}.agent_memory(agent_instance_id, created_at DESC);
-------------------------------------------------
filepath = ./platform/database/migrations/004_auth_schema.sql
-- FILE: platform/database/migrations/004_auth_schema.sql
-- Auth database schema
CREATE TABLE IF NOT EXISTS users (
                                     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user',
    client_id VARCHAR(100) NOT NULL,
    subscription_tier VARCHAR(50) DEFAULT 'free',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_client ON users(client_id);

CREATE TABLE IF NOT EXISTS auth_tokens (
                                           id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    token_hash VARCHAR(255) NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_tokens_user ON auth_tokens(user_id);
CREATE INDEX idx_tokens_expires ON auth_tokens(expires_at);

CREATE INDEX idx_users_email_active ON users(email, is_active);-------------------------------------------------
filepath = ./platform/database/migrations/002_create_templates_schema.sql
-- FILE: platform/database/migrations/002_create_templates_schema.sql
-- Templates database schema
CREATE TABLE IF NOT EXISTS persona_templates (
                                                 id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_templates_category ON persona_templates(category);
CREATE INDEX idx_templates_active ON persona_templates(is_active);
-------------------------------------------------
filepath = ./platform/database/postgres.go
// FILE: platform/database/postgres.go
package database

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/gqls/agentchassis/platform/config"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// NewPostgresConnection creates a new PostgreSQL connection pool with retry logic
func NewPostgresConnection(ctx context.Context, dbCfg config.DatabaseConfig, logger *zap.Logger) (*pgxpool.Pool, error) {
	password := os.Getenv(dbCfg.PasswordEnvVar)
	if password == "" {
		return nil, fmt.Errorf("database password environment variable %s is not set", dbCfg.PasswordEnvVar)
	}

	connStr := fmt.Sprintf("postgresql://%s:%s@%s:%d/%s?sslmode=%s",
		dbCfg.User, password, dbCfg.Host, dbCfg.Port, dbCfg.DBName, dbCfg.SSLMode)

	poolConfig, err := pgxpool.ParseConfig(connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to parse postgres connection string: %w", err)
	}

	poolConfig.MaxConns = 10
	poolConfig.MinConns = 2
	poolConfig.MaxConnLifetime = time.Hour
	poolConfig.MaxConnIdleTime = 30 * time.Minute

	var pool *pgxpool.Pool
	for i := 0; i < 5; i++ {
		pool, err = pgxpool.NewWithConfig(ctx, poolConfig)
		if err == nil {
			pingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
			defer cancel()
			if err = pool.Ping(pingCtx); err == nil {
				logger.Info("Successfully connected to PostgreSQL database.", zap.String("database", dbCfg.DBName))
				return pool, nil
			}
		}
		logger.Warn("Failed to connect to PostgreSQL, retrying...",
			zap.Int("attempt", i+1),
			zap.String("database", dbCfg.DBName),
			zap.Error(err),
		)
		time.Sleep(5 * time.Second)
	}

	return nil, fmt.Errorf("failed to connect to postgres after multiple attempts: %w", err)
}
-------------------------------------------------
filepath = ./platform/database/mysql.go
// FILE: platform/database/mysql.go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/gqls/agentchassis/platform/config"
	"go.uber.org/zap"
)

// NewMySQLConnection creates a new MySQL database connection pool with retry logic
func NewMySQLConnection(ctx context.Context, dbCfg config.DatabaseConfig, logger *zap.Logger) (*sql.DB, error) {
	password := os.Getenv(dbCfg.PasswordEnvVar)
	if password == "" {
		return nil, fmt.Errorf("database password environment variable %s is not set", dbCfg.PasswordEnvVar)
	}

	// DSN format for MySQL
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true",
		dbCfg.User, password, dbCfg.Host, dbCfg.Port, dbCfg.DBName)

	var db *sql.DB
	var err error

	// Retry loop for initial connection
	for i := 0; i < 5; i++ {
		db, err = sql.Open("mysql", dsn)
		if err == nil {
			pingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
			defer cancel()
			if err = db.PingContext(pingCtx); err == nil {
				// Set connection pool parameters
				db.SetMaxOpenConns(10)
				db.SetMaxIdleConns(5)
				db.SetConnMaxLifetime(time.Hour)

				logger.Info("Successfully connected to MySQL database.", zap.String("database", dbCfg.DBName))
				return db, nil
			}
		}
		logger.Warn("Failed to connect to MySQL, retrying...",
			zap.Int("attempt", i+1),
			zap.String("database", dbCfg.DBName),
			zap.Error(err),
		)
		time.Sleep(5 * time.Second)
	}

	return nil, fmt.Errorf("failed to connect to mysql after multiple attempts: %w", err)
}
-------------------------------------------------
filepath = ./platform/database/pgvector.go
// FILE: platform/database/pgvector.go
package database

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/pgvector/pgvector-go"
	"go.uber.org/zap"
)

// MemoryRecord represents a single entry in the agent_memory table
type MemoryRecord struct {
	ID              uuid.UUID
	AgentInstanceID uuid.UUID
	Content         string
	Embedding       []float32
	Metadata        map[string]interface{}
}

// MemoryRepository provides methods for storing and retrieving agent memories
type MemoryRepository struct {
	pool   *pgxpool.Pool
	logger *zap.Logger
}

// NewMemoryRepository creates a new repository for memory operations
func NewMemoryRepository(pool *pgxpool.Pool, logger *zap.Logger) *MemoryRepository {
	return &MemoryRepository{pool: pool, logger: logger}
}

// StoreMemory saves a new memory record to the database for a specific agent
func (r *MemoryRepository) StoreMemory(ctx context.Context, agentID uuid.UUID, content string, embedding []float32, metadata map[string]interface{}) error {
	l := r.logger.With(zap.String("agent_id", agentID.String()))
	l.Info("Storing new memory")

	query := `
        INSERT INTO agent_memory (agent_instance_id, content, embedding, metadata)
        VALUES ($1, $2, $3, $4)
    `
	_, err := r.pool.Exec(ctx, query, agentID, content, pgvector.NewVector(embedding), metadata)
	if err != nil {
		l.Error("Failed to store agent memory", zap.Error(err))
		return fmt.Errorf("failed to insert memory record: %w", err)
	}

	l.Debug("Successfully stored memory record")
	return nil
}

// SearchMemory performs a semantic similarity search to find the most relevant memories
func (r *MemoryRepository) SearchMemory(ctx context.Context, agentID uuid.UUID, queryEmbedding []float32, limit int) ([]MemoryRecord, error) {
	l := r.logger.With(zap.String("agent_id", agentID.String()))
	l.Info("Searching for relevant memories", zap.Int("limit", limit))

	query := `
        SELECT id, content, metadata
        FROM agent_memory
        WHERE agent_instance_id = $1
        ORDER BY embedding <=> $2
        LIMIT $3
    `
	rows, err := r.pool.Query(ctx, query, agentID, pgvector.NewVector(queryEmbedding), limit)
	if err != nil {
		l.Error("Failed to execute memory search query", zap.Error(err))
		return nil, fmt.Errorf("failed to search memory: %w", err)
	}
	defer rows.Close()

	var results []MemoryRecord
	for rows.Next() {
		var record MemoryRecord
		record.AgentInstanceID = agentID
		if err := rows.Scan(&record.ID, &record.Content, &record.Metadata); err != nil {
			l.Error("Failed to scan memory search result", zap.Error(err))
			continue
		}
		results = append(results, record)
	}

	l.Info("Memory search completed", zap.Int("results_found", len(results)))
	return results, nil
}
-------------------------------------------------
filepath = ./platform/storage/s3.go
// FILE: platform/storage/s3.go
package storage

import (
	"context"
	"fmt"
	"io"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	platform_config "github.com/gqls/agentchassis/platform/config"
)

// S3Client implements the Client interface for S3-compatible services
type S3Client struct {
	client *s3.Client
	bucket string
}

// NewS3Client creates a new client for interacting with S3 or MinIO
func NewS3Client(ctx context.Context, cfg platform_config.ObjectStorageConfig) (*S3Client, error) {
	accessKey := os.Getenv(cfg.AccessKeyEnvVar)
	secretKey := os.Getenv(cfg.SecretKeyEnvVar)

	if accessKey == "" || secretKey == "" {
		return nil, fmt.Errorf("object storage credentials not found in environment variables (%s, %s)",
			cfg.AccessKeyEnvVar, cfg.SecretKeyEnvVar)
	}

	resolver := aws.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (aws.Endpoint, error) {
		return aws.Endpoint{
			URL:           cfg.Endpoint,
			SigningRegion: "us-east-1", // This can be anything for MinIO
		}, nil
	})

	awsCfg, err := config.LoadDefaultConfig(ctx,
		config.WithEndpointResolverWithOptions(resolver),
		config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(accessKey, secretKey, "")),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to load s3 config: %w", err)
	}

	// For MinIO, you must use path-style addressing
	s3Client := s3.NewFromConfig(awsCfg, func(o *s3.Options) {
		o.UsePathStyle = true
	})

	return &S3Client{
		client: s3Client,
		bucket: cfg.Bucket,
	}, nil
}

// Upload puts a new object into the storage bucket
func (c *S3Client) Upload(ctx context.Context, key, contentType string, body io.Reader) (string, error) {
	_, err := c.client.PutObject(ctx, &s3.PutObjectInput{
		Bucket:      aws.String(c.bucket),
		Key:         aws.String(key),
		Body:        body,
		ContentType: aws.String(contentType),
	})
	if err != nil {
		return "", fmt.Errorf("failed to upload object to s3: %w", err)
	}
	// Return the S3 URI for the object
	return fmt.Sprintf("s3://%s/%s", c.bucket, key), nil
}

// Download retrieves an object from the storage bucket
func (c *S3Client) Download(ctx context.Context, key string) (io.ReadCloser, error) {
	output, err := c.client.GetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String(c.bucket),
		Key:    aws.String(key),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to download object from s3: %w", err)
	}
	return output.Body, nil
}

// Delete removes an object from storage
func (c *S3Client) Delete(ctx context.Context, key string) error {
	_, err := c.client.DeleteObject(ctx, &s3.DeleteObjectInput{
		Bucket: aws.String(c.bucket),
		Key:    aws.String(key),
	})
	if err != nil {
		return fmt.Errorf("failed to delete object: %w", err)
	}
	return nil
}

// Exists checks if an object exists
func (c *S3Client) Exists(ctx context.Context, key string) (bool, error) {
	_, err := c.client.HeadObject(ctx, &s3.HeadObjectInput{
		Bucket: aws.String(c.bucket),
		Key:    aws.String(key),
	})
	if err != nil {
		// Check if it's a not found error
		if strings.Contains(err.Error(), "NotFound") {
			return false, nil
		}
		return false, fmt.Errorf("failed to check object existence: %w", err)
	}
	return true, nil
}

// ListObjects lists objects with a given prefix
func (c *S3Client) ListObjects(ctx context.Context, prefix string) ([]ObjectInfo, error) {
	paginator := s3.NewListObjectsV2Paginator(c.client, &s3.ListObjectsV2Input{
		Bucket: aws.String(c.bucket),
		Prefix: aws.String(prefix),
	})

	var objects []ObjectInfo
	for paginator.HasMorePages() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to list objects: %w", err)
		}

		for _, obj := range page.Contents {
			objects = append(objects, ObjectInfo{
				Key:          aws.ToString(obj.Key),
				Size:         aws.ToInt64(obj.Size),
				LastModified: aws.ToTime(obj.LastModified),
				ETag:         aws.ToString(obj.ETag),
			})
		}
	}

	return objects, nil
}

// GetPresignedURL generates a temporary access URL
func (c *S3Client) GetPresignedURL(ctx context.Context, key string, expiryMinutes int) (string, error) {
	presignClient := s3.NewPresignClient(c.client)

	request, err := presignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String(c.bucket),
		Key:    aws.String(key),
	}, func(opts *s3.PresignOptions) {
		opts.Expires = time.Duration(expiryMinutes) * time.Minute
	})

	if err != nil {
		return "", fmt.Errorf("failed to create presigned URL: %w", err)
	}

	return request.URL, nil
}
-------------------------------------------------
filepath = ./platform/storage/interface.go
// FILE: platform/storage/interface.go
package storage

import (
	"context"
	"io"
	"time"
)

// Client defines the interface for object storage operations
type Client interface {
	// Upload stores an object and returns its URI
	Upload(ctx context.Context, key, contentType string, body io.Reader) (string, error)

	// Download retrieves an object by its key
	Download(ctx context.Context, key string) (io.ReadCloser, error)

	// Delete removes an object
	Delete(ctx context.Context, key string) error

	// Exists checks if an object exists
	Exists(ctx context.Context, key string) (bool, error)

	// ListObjects lists objects with a given prefix
	ListObjects(ctx context.Context, prefix string) ([]ObjectInfo, error)

	// GetPresignedURL generates a temporary access URL
	GetPresignedURL(ctx context.Context, key string, expiry int) (string, error)
}

// ObjectInfo contains metadata about a stored object
type ObjectInfo struct {
	Key          string
	Size         int64
	LastModified time.Time
	ContentType  string
	ETag         string
}
-------------------------------------------------
filepath = ./platform/memory/service.go
// FILE: platform/memory/service.go
package memory

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/gqls/agentchassis/pkg/models"
	"github.com/gqls/agentchassis/platform/aiservice"
	"github.com/gqls/agentchassis/platform/database"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// Service handles memory operations for agents
type Service struct {
	pool       *pgxpool.Pool
	aiClient   aiservice.AIService
	logger     *zap.Logger
	memoryRepo *database.MemoryRepository
}

// NewService creates a new memory service
func NewService(pool *pgxpool.Pool, aiClient aiservice.AIService, logger *zap.Logger) *Service {
	return &Service{
		pool:       pool,
		aiClient:   aiClient,
		logger:     logger,
		memoryRepo: database.NewMemoryRepository(pool, logger),
	}
}

// StoreMemory stores a memory entry for an agent
func (s *Service) StoreMemory(ctx context.Context, agentID uuid.UUID, entry models.MemoryEntry) error {
	// Generate embedding
	embedding, err := s.aiClient.GenerateEmbedding(ctx, entry.Content)
	if err != nil {
		s.logger.Error("Failed to generate embedding", zap.Error(err))
		return fmt.Errorf("failed to generate embedding: %w", err)
	}

	// Add timestamp to metadata
	if entry.Metadata == nil {
		entry.Metadata = make(map[string]interface{})
	}
	entry.Metadata["timestamp"] = entry.Timestamp
	entry.Metadata["type"] = entry.Type

	// Store in database
	return s.memoryRepo.StoreMemory(ctx, agentID, entry.Content, embedding, entry.Metadata)
}

// RetrieveRelevantMemories retrieves memories relevant to a query
func (s *Service) RetrieveRelevantMemories(ctx context.Context, agentID uuid.UUID, query string, limit int) ([]models.MemoryEntry, error) {
	// Generate query embedding
	queryEmbedding, err := s.aiClient.GenerateEmbedding(ctx, query)
	if err != nil {
		s.logger.Error("Failed to generate query embedding", zap.Error(err))
		return nil, fmt.Errorf("failed to generate query embedding: %w", err)
	}

	// Search for similar memories
	records, err := s.memoryRepo.SearchMemory(ctx, agentID, queryEmbedding, limit)
	if err != nil {
		return nil, err
	}

	// Convert to memory entries
	entries := make([]models.MemoryEntry, len(records))
	for i, record := range records {
		entries[i] = models.MemoryEntry{
			Content:  record.Content,
			Metadata: record.Metadata,
		}

		// Extract type and timestamp from metadata
		if typeStr, ok := record.Metadata["type"].(string); ok {
			entries[i].Type = typeStr
		}
		if timestampStr, ok := record.Metadata["timestamp"].(string); ok {
			if t, err := time.Parse(time.RFC3339, timestampStr); err == nil {
				entries[i].Timestamp = t
			}
		}
	}

	return entries, nil
}

// ProcessWorkflowMemory handles memory storage for workflow steps
func (s *Service) ProcessWorkflowMemory(ctx context.Context, agentID uuid.UUID, config models.MemoryConfiguration, step models.Step, input, output interface{}) error {
	// Check if memory is enabled and this step should store memory
	if !config.Enabled || !step.StoreMemory {
		return nil
	}

	// Create memory entry
	entry := models.MemoryEntry{
		Type:      "workflow_step",
		Timestamp: time.Now(),
		Metadata: map[string]interface{}{
			"step_action":      step.Action,
			"step_description": step.Description,
		},
	}

	// Format content based on input and output
	content := map[string]interface{}{
		"action": step.Action,
		"input":  input,
		"output": output,
	}

	contentBytes, err := json.MarshalIndent(content, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal memory content: %w", err)
	}
	entry.Content = string(contentBytes)

	// Store the memory
	return s.StoreMemory(ctx, agentID, entry)
}

// GetMemoryContext retrieves relevant memories for a given context
func (s *Service) GetMemoryContext(ctx context.Context, agentID uuid.UUID, config models.MemoryConfiguration, currentContext string) ([]models.MemoryEntry, error) {
	if !config.Enabled {
		return nil, nil
	}

	count := config.RetrievalCount
	if count == 0 {
		count = 5 // default
	}

	return s.RetrieveRelevantMemories(ctx, agentID, currentContext, count)
}
-------------------------------------------------
filepath = ./go.mod
// FILE: go.mod
module github.com/gqls/agentchassis

go 1.23.0

toolchain go1.24.4

require (
	github.com/DATA-DOG/go-sqlmock v1.5.2
	github.com/aws/aws-sdk-go-v2 v1.25.1
	github.com/aws/aws-sdk-go-v2/config v1.27.0
	github.com/aws/aws-sdk-go-v2/credentials v1.17.0
	github.com/aws/aws-sdk-go-v2/service/s3 v1.51.0
	github.com/gin-gonic/gin v1.10.1
	github.com/go-sql-driver/mysql v1.7.1
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.1
	github.com/jackc/pgx/v5 v5.5.5
	github.com/pgvector/pgvector-go v0.1.1
	github.com/prometheus/client_golang v1.22.0
	github.com/rs/cors v1.10.1
	github.com/segmentio/kafka-go v0.4.47
	github.com/sony/gobreaker v1.0.0
	github.com/spf13/viper v1.18.2
	github.com/stretchr/testify v1.10.0
	go.opentelemetry.io/otel v1.29.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.29.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
	go.opentelemetry.io/otel/sdk v1.29.0
	go.opentelemetry.io/otel/trace v1.29.0
	go.uber.org/zap v1.27.0
	golang.org/x/crypto v0.40.0
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.2.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.1 // indirect
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.15.0 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.1 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/sso v1.19.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.22.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.27.0 // indirect
	github.com/aws/smithy-go v1.20.1 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/bytedance/sonic v1.13.3 // indirect
	github.com/bytedance/sonic/loader v0.3.0 // indirect
	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/chenzhuoyu/base64x v0.0.0-20230717121745-296ad89f973d // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.7 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/fsnotify/fsnotify v1.7.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.9 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-openapi/jsonpointer v0.21.1 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/swag v0.23.1 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.27.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.20.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/puddle/v2 v2.2.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/compress v1.18.0 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pierrec/lz4/v4 v4.1.22 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/prometheus/client_model v0.6.1 // indirect
	github.com/prometheus/common v0.62.0 // indirect
	github.com/prometheus/procfs v0.15.1 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/sagikazarmark/locafero v0.4.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.11.0 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/swaggo/files v1.0.1 // indirect
	github.com/swaggo/gin-swagger v1.6.0 // indirect
	github.com/swaggo/swag v1.16.5 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.0 // indirect
	github.com/urfave/cli/v2 v2.27.7 // indirect
	github.com/xrash/smetrics v0.0.0-20250705151800-55b8f293f342 // indirect
	go.opentelemetry.io/otel/metric v1.29.0 // indirect
	go.opentelemetry.io/proto/otlp v1.3.1 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	go.yaml.in/yaml/v2 v2.4.2 // indirect
	golang.org/x/arch v0.19.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/mod v0.26.0 // indirect
	golang.org/x/net v0.42.0 // indirect
	golang.org/x/sync v0.16.0 // indirect
	golang.org/x/sys v0.34.0 // indirect
	golang.org/x/text v0.27.0 // indirect
	golang.org/x/tools v0.35.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240513163218-0867130af1f8 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240513163218-0867130af1f8 // indirect
	google.golang.org/grpc v1.64.1 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	sigs.k8s.io/yaml v1.5.0 // indirect
)
-------------------------------------------------
