filepath = ./internal/auth-service/user/handlers_swagger.go
package user

// NOTE: This file contains swagger annotations for the user handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective files.

// HandleGetCurrentUser godoc
// @Summary      Get current user profile
// @Description  Retrieves the profile information of the currently authenticated user
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Success      200 {object} user.User "User profile retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "User not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/profile [get]
// @Security     Bearer
// @ID           getCurrentUser

// HandleUpdateCurrentUser godoc
// @Summary      Update user profile
// @Description  Updates the profile information of the currently authenticated user
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Param        request body user.UpdateUserRequest true "Profile update details"
// @Success      200 {object} user.User "Profile updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "User not found"
// @Failure      409 {object} map[string]interface{} "Email already in use"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/profile [put]
// @Security     Bearer
// @ID           updateUserProfile

// HandleChangePassword godoc
// @Summary      Change password
// @Description  Changes the password for the currently authenticated user
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Param        request body user.ChangePasswordRequest true "Password change details"
// @Success      200 {object} map[string]interface{} "Password changed successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request or password requirements not met"
// @Failure      401 {object} map[string]interface{} "Unauthorized or incorrect current password"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/password [post]
// @Security     Bearer
// @ID           changePassword

// HandleDeleteAccount godoc
// @Summary      Delete account
// @Description  Permanently deletes the currently authenticated user's account. This action cannot be undone.
// @Tags         User Management
// @Accept       json
// @Produce      json
// @Param        request body user.DeleteAccountRequest true "Account deletion confirmation"
// @Success      200 {object} map[string]interface{} "Account deleted successfully"
// @Failure      400 {object} map[string]interface{} "Invalid confirmation or request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized or incorrect password"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /user/delete [delete]
// @Security     Bearer
// @ID           deleteAccount
-------------------------------------------------
filepath = ./internal/auth-service/user/handlers.go
package user

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// Handlers wraps the user service for HTTP handling
type Handlers struct {
	service *Service
}

// NewHandlers creates new user handlers
func NewHandlers(service *Service) *Handlers {
	return &Handlers{service: service}
}

// DeleteAccountRequest for account deletion
type DeleteAccountRequest struct {
	Password     string `json:"password" binding:"required" example:"SecurePassword123!"`
	Confirmation string `json:"confirmation" binding:"required" example:"DELETE MY ACCOUNT"`
	Reason       string `json:"reason,omitempty" example:"No longer need the service"`
}

// HandleGetCurrentUser returns the current user's details
func (h *Handlers) HandleGetCurrentUser(c *gin.Context) {
	userID := c.GetString("user_id")

	user, err := h.service.GetUser(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// HandleUpdateCurrentUser updates the current user's details
func (h *Handlers) HandleUpdateCurrentUser(c *gin.Context) {
	userID := c.GetString("user_id")

	var req UpdateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.service.UpdateUser(c.Request.Context(), userID, &req); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
		return
	}

	// Return updated user
	user, _ := h.service.GetUser(c.Request.Context(), userID)
	c.JSON(http.StatusOK, user)
}

// HandleChangePassword changes the user's password
func (h *Handlers) HandleChangePassword(c *gin.Context) {
	userID := c.GetString("user_id")

	var req ChangePasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.service.ChangePassword(c.Request.Context(), userID, &req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

// HandleDeleteAccount deletes the user's account
func (h *Handlers) HandleDeleteAccount(c *gin.Context) {
	userID := c.GetString("user_id")

	var req DeleteAccountRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate confirmation
	if req.Confirmation != "DELETE MY ACCOUNT" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid confirmation text"})
		return
	}

	// Verify password
	user, err := h.service.GetUser(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify account"})
		return
	}

	// Validate password through login service
	_, err = h.service.Login(c.Request.Context(), user.Email, req.Password)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Incorrect password"})
		return
	}

	if err := h.service.DeleteUser(c.Request.Context(), userID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete account"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Account deleted successfully"})
}
-------------------------------------------------
filepath = ./internal/auth-service/user/repository_admin.go
// FILE: internal/auth-service/user/repository_admin.go
package user

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"go.uber.org/zap"
)

// ListUsersParams contains parameters for listing users
type ListUsersParams struct {
	Offset    int
	Limit     int
	Email     string
	ClientID  string
	Role      string
	Tier      string
	IsActive  *bool
	SortBy    string
	SortOrder string
}

// UserStats contains statistics about a user
type UserStats struct {
	TotalProjects int        `json:"total_projects" example:"5"`
	TotalPersonas int        `json:"total_personas" example:"12"`
	LastLoginAt   *time.Time `json:"last_login_at" example:"2024-07-17T10:00:00Z"`
	AccountAge    string     `json:"account_age" example:"6 months"`
	TotalLogins   int        `json:"total_logins" example:"142"`
}

// UserActivity represents a user activity log entry
type UserActivity struct {
	ID        string    `json:"id" example:"act_123e4567-e89b-12d3-a456-426614174000"`
	UserID    string    `json:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	Action    string    `json:"action" example:"login"`
	Details   string    `json:"details" example:"{\"ip\":\"192.168.1.1\",\"location\":\"New York\"}"`
	IPAddress string    `json:"ip_address" example:"192.168.1.1"`
	UserAgent string    `json:"user_agent" example:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"`
	CreatedAt time.Time `json:"created_at" example:"2024-07-17T14:30:00Z"`
}

// AdminUpdateRequest contains fields that can be updated by admin
type AdminUpdateRequest struct {
	Role             *string
	SubscriptionTier *string
	IsActive         *bool
	EmailVerified    *bool
}

// ListUsers returns a paginated list of users with optional filtering
func (r *Repository) ListUsers(ctx context.Context, params ListUsersParams) ([]User, int, error) {
	// Build the query dynamically
	query := `
		SELECT u.id, u.email, u.password_hash, u.role, u.client_id, 
		       u.subscription_tier, u.is_active, u.email_verified,
		       u.created_at, u.updated_at, u.last_login_at
		FROM users u
		WHERE 1=1
	`
	countQuery := `SELECT COUNT(*) FROM users u WHERE 1=1`

	args := []interface{}{}
	argCount := 0

	// Add filters
	var conditions []string

	if params.Email != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.email ILIKE $%d", argCount))
		args = append(args, "%"+params.Email+"%")
	}

	if params.ClientID != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.client_id = $%d", argCount))
		args = append(args, params.ClientID)
	}

	if params.Role != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.role = $%d", argCount))
		args = append(args, params.Role)
	}

	if params.Tier != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.subscription_tier = $%d", argCount))
		args = append(args, params.Tier)
	}

	if params.IsActive != nil {
		argCount++
		conditions = append(conditions, fmt.Sprintf("u.is_active = $%d", argCount))
		args = append(args, *params.IsActive)
	}

	// Add conditions to queries
	if len(conditions) > 0 {
		whereClause := " AND " + strings.Join(conditions, " AND ")
		query += whereClause
		countQuery += whereClause
	}

	// Get total count
	var totalCount int
	err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&totalCount)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to get user count: %w", err)
	}

	// Add sorting
	validSortColumns := map[string]bool{
		"email": true, "created_at": true, "updated_at": true,
		"last_login_at": true, "role": true, "subscription_tier": true,
	}

	sortBy := "created_at"
	if validSortColumns[params.SortBy] {
		sortBy = params.SortBy
	}

	sortOrder := "DESC"
	if strings.ToUpper(params.SortOrder) == "ASC" {
		sortOrder = "ASC"
	}

	query += fmt.Sprintf(" ORDER BY u.%s %s", sortBy, sortOrder)

	// Add pagination
	argCount++
	query += fmt.Sprintf(" LIMIT $%d", argCount)
	args = append(args, params.Limit)

	argCount++
	query += fmt.Sprintf(" OFFSET $%d", argCount)
	args = append(args, params.Offset)

	// Execute query
	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list users: %w", err)
	}
	defer rows.Close()

	var users []User
	for rows.Next() {
		var user User
		err := rows.Scan(
			&user.ID, &user.Email, &user.PasswordHash, &user.Role,
			&user.ClientID, &user.SubscriptionTier, &user.IsActive,
			&user.EmailVerified, &user.CreatedAt, &user.UpdatedAt,
			&user.LastLoginAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan user row", zap.Error(err))
			continue
		}

		// Don't load profile and permissions for list view (performance)
		users = append(users, user)
	}

	return users, totalCount, nil
}

// GetUserStats retrieves statistics for a user
func (r *Repository) GetUserStats(ctx context.Context, userID string) (*UserStats, error) {
	stats := &UserStats{}

	// Get basic user info for last login and account age
	var createdAt time.Time
	var lastLogin sql.NullTime
	err := r.db.QueryRowContext(ctx,
		"SELECT created_at, last_login_at FROM users WHERE id = $1",
		userID,
	).Scan(&createdAt, &lastLogin)

	if err != nil {
		return nil, err
	}

	if lastLogin.Valid {
		stats.LastLoginAt = &lastLogin.Time
	}

	// Calculate account age
	age := time.Since(createdAt)
	if age.Hours() < 24 {
		stats.AccountAge = fmt.Sprintf("%d hours", int(age.Hours()))
	} else if age.Hours() < 24*30 {
		stats.AccountAge = fmt.Sprintf("%d days", int(age.Hours()/24))
	} else {
		stats.AccountAge = fmt.Sprintf("%d months", int(age.Hours()/(24*30)))
	}

	// Get project count
	err = r.db.QueryRowContext(ctx,
		"SELECT COUNT(*) FROM projects WHERE owner_id = $1 AND is_active = true",
		userID,
	).Scan(&stats.TotalProjects)

	if err != nil && err != sql.ErrNoRows {
		r.logger.Warn("Failed to get project count", zap.Error(err))
	}

	// Note: Persona count would require access to clients DB
	// For now, we'll leave it at 0

	return stats, nil
}

// AdminUpdateUser updates user fields that only admins can change
func (r *Repository) AdminUpdateUser(ctx context.Context, userID string, req *AdminUpdateRequest) error {
	var setClauses []string
	var args []interface{}
	argCount := 0

	if req.Role != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("role = $%d", argCount))
		args = append(args, *req.Role)
	}

	if req.SubscriptionTier != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("subscription_tier = $%d", argCount))
		args = append(args, *req.SubscriptionTier)
	}

	if req.IsActive != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("is_active = $%d", argCount))
		args = append(args, *req.IsActive)
	}

	if req.EmailVerified != nil {
		argCount++
		setClauses = append(setClauses, fmt.Sprintf("email_verified = $%d", argCount))
		args = append(args, *req.EmailVerified)
	}

	if len(setClauses) == 0 {
		return nil // Nothing to update
	}

	argCount++
	setClauses = append(setClauses, fmt.Sprintf("updated_at = $%d", argCount))
	args = append(args, time.Now())

	argCount++
	args = append(args, userID)

	query := fmt.Sprintf(
		"UPDATE users SET %s WHERE id = $%d",
		strings.Join(setClauses, ", "),
		argCount,
	)

	_, err := r.db.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("failed to update user: %w", err)
	}

	return nil
}

// GetUserActivityLog retrieves activity logs for a user
func (r *Repository) GetUserActivityLog(ctx context.Context, userID string, limit, offset int) ([]UserActivity, error) {
	// First, ensure activity log table exists
	createTableQuery := `
		CREATE TABLE IF NOT EXISTS user_activity_logs (
			id VARCHAR(36) PRIMARY KEY,
			user_id VARCHAR(36) NOT NULL,
			action VARCHAR(100) NOT NULL,
			details TEXT,
			ip_address VARCHAR(45),
			user_agent TEXT,
			created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
			INDEX idx_activity_user_created (user_id, created_at DESC),
			FOREIGN KEY (user_id) REFERENCES users(id)
		)
	`

	_, err := r.db.ExecContext(ctx, createTableQuery)
	if err != nil {
		r.logger.Warn("Failed to ensure activity log table", zap.Error(err))
	}

	// Get activity logs
	query := `
		SELECT id, user_id, action, COALESCE(details, ''), 
		       COALESCE(ip_address, ''), COALESCE(user_agent, ''), created_at
		FROM user_activity_logs
		WHERE user_id = ?
		ORDER BY created_at DESC
		LIMIT ? OFFSET ?
	`

	rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get activity logs: %w", err)
	}
	defer rows.Close()

	var activities []UserActivity
	for rows.Next() {
		var activity UserActivity
		err := rows.Scan(
			&activity.ID, &activity.UserID, &activity.Action,
			&activity.Details, &activity.IPAddress, &activity.UserAgent,
			&activity.CreatedAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan activity row", zap.Error(err))
			continue
		}
		activities = append(activities, activity)
	}

	return activities, nil
}

// GrantPermission grants a permission to a user
func (r *Repository) GrantPermission(ctx context.Context, userID, permissionName string) error {
	// First get the permission ID
	var permissionID string
	err := r.db.QueryRowContext(ctx,
		"SELECT id FROM permissions WHERE name = ?",
		permissionName,
	).Scan(&permissionID)

	if err != nil {
		return fmt.Errorf("permission not found: %w", err)
	}

	// Grant the permission
	query := `
		INSERT INTO user_permissions (user_id, permission_id, granted_at)
		VALUES (?, ?, ?)
		ON DUPLICATE KEY UPDATE granted_at = VALUES(granted_at)
	`

	_, err = r.db.ExecContext(ctx, query, userID, permissionID, time.Now())
	if err != nil {
		return fmt.Errorf("failed to grant permission: %w", err)
	}

	return nil
}

// RevokePermission revokes a permission from a user
func (r *Repository) RevokePermission(ctx context.Context, userID, permissionName string) error {
	query := `
		DELETE up FROM user_permissions up
		JOIN permissions p ON up.permission_id = p.id
		WHERE up.user_id = ? AND p.name = ?
	`

	_, err := r.db.ExecContext(ctx, query, userID, permissionName)
	if err != nil {
		return fmt.Errorf("failed to revoke permission: %w", err)
	}

	return nil
}

// LogUserActivity logs a user action
func (r *Repository) LogUserActivity(ctx context.Context, activity *UserActivity) error {
	query := `
		INSERT INTO user_activity_logs 
		(id, user_id, action, details, ip_address, user_agent, created_at)
		VALUES (?, ?, ?, ?, ?, ?, ?)
	`

	_, err := r.db.ExecContext(ctx, query,
		activity.ID, activity.UserID, activity.Action,
		activity.Details, activity.IPAddress, activity.UserAgent,
		activity.CreatedAt,
	)

	return err
}
-------------------------------------------------
filepath = ./internal/auth-service/user/repository.go
package user

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"
	"golang.org/x/crypto/bcrypt"
)

// Repository handles user data access
type Repository struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewRepository creates a new user repository
func NewRepository(db *sql.DB, logger *zap.Logger) *Repository {
	return &Repository{
		db:     db,
		logger: logger,
	}
}

// CreateUser creates a new user with profile
func (r *Repository) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {
	// Start transaction
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	user := &User{
		ID:               uuid.New().String(),
		Email:            strings.ToLower(req.Email),
		PasswordHash:     string(hashedPassword),
		Role:             "user", // Default role
		ClientID:         req.ClientID,
		SubscriptionTier: "free", // Default tier
		IsActive:         true,
		EmailVerified:    false,
		CreatedAt:        time.Now(),
		UpdatedAt:        time.Now(),
	}

	// Insert user
	query := `
        INSERT INTO users (id, email, password_hash, role, client_id, subscription_tier, 
                          is_active, email_verified, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `

	_, err = tx.ExecContext(ctx, query,
		user.ID, user.Email, user.PasswordHash, user.Role, user.ClientID,
		user.SubscriptionTier, user.IsActive, user.EmailVerified,
		user.CreatedAt, user.UpdatedAt)

	if err != nil {
		if strings.Contains(err.Error(), "duplicate") {
			return nil, fmt.Errorf("user with email %s already exists", req.Email)
		}
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Create user profile
	profile := &UserProfile{
		UserID:    user.ID,
		FirstName: req.FirstName,
		LastName:  req.LastName,
		Company:   req.Company,
	}

	profileQuery := `
        INSERT INTO user_profiles (user_id, first_name, last_name, company)
        VALUES (?, ?, ?, ?)
    `

	_, err = tx.ExecContext(ctx, profileQuery,
		profile.UserID, profile.FirstName, profile.LastName, profile.Company)

	if err != nil {
		return nil, fmt.Errorf("failed to create user profile: %w", err)
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	user.Profile = profile
	r.logger.Info("User created successfully", zap.String("user_id", user.ID))

	return user, nil
}

// GetUserByEmail retrieves a user by email
func (r *Repository) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	email = strings.ToLower(email)

	var user User
	query := `
        SELECT id, email, password_hash, role, client_id, subscription_tier, 
               is_active, email_verified, created_at, updated_at, last_login_at
        FROM users
        WHERE email = ? AND is_active = true
    `

	err := r.db.QueryRowContext(ctx, query, email).Scan(
		&user.ID, &user.Email, &user.PasswordHash, &user.Role, &user.ClientID,
		&user.SubscriptionTier, &user.IsActive, &user.EmailVerified,
		&user.CreatedAt, &user.UpdatedAt, &user.LastLoginAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Load profile
	profile, err := r.getUserProfile(ctx, user.ID)
	if err == nil {
		user.Profile = profile
	}

	// Load permissions
	permissions, err := r.getUserPermissions(ctx, user.ID)
	if err == nil {
		user.Permissions = permissions
	}

	return &user, nil
}

// GetUserByID retrieves a user by ID
func (r *Repository) GetUserByID(ctx context.Context, userID string) (*User, error) {
	var user User
	query := `
        SELECT id, email, password_hash, role, client_id, subscription_tier, 
               is_active, email_verified, created_at, updated_at, last_login_at
        FROM users
        WHERE id = ? AND is_active = true
    `

	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&user.ID, &user.Email, &user.PasswordHash, &user.Role, &user.ClientID,
		&user.SubscriptionTier, &user.IsActive, &user.EmailVerified,
		&user.CreatedAt, &user.UpdatedAt, &user.LastLoginAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Load profile
	profile, err := r.getUserProfile(ctx, user.ID)
	if err == nil {
		user.Profile = profile
	}

	// Load permissions
	permissions, err := r.getUserPermissions(ctx, user.ID)
	if err == nil {
		user.Permissions = permissions
	}

	return &user, nil
}

// getUserProfile loads user profile
func (r *Repository) getUserProfile(ctx context.Context, userID string) (*UserProfile, error) {
	var profile UserProfile
	query := `
        SELECT user_id, first_name, last_name, company, phone, avatar_url, preferences
        FROM user_profiles
        WHERE user_id = ?
    `

	var preferences sql.NullString
	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&profile.UserID, &profile.FirstName, &profile.LastName,
		&profile.Company, &profile.Phone, &profile.AvatarURL, &preferences)

	if err != nil {
		return nil, err
	}

	if preferences.Valid {
		json.Unmarshal([]byte(preferences.String), &profile.Preferences)
	}

	return &profile, nil
}

// getUserPermissions loads user permissions
func (r *Repository) getUserPermissions(ctx context.Context, userID string) ([]string, error) {
	query := `
        SELECT p.name
        FROM permissions p
        JOIN user_permissions up ON p.id = up.permission_id
        WHERE up.user_id = ?
    `

	rows, err := r.db.QueryContext(ctx, query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var permissions []string
	for rows.Next() {
		var perm string
		if err := rows.Scan(&perm); err != nil {
			continue
		}
		permissions = append(permissions, perm)
	}

	return permissions, nil
}

// UpdateUser updates user information
func (r *Repository) UpdateUser(ctx context.Context, userID string, req *UpdateUserRequest) error {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Update user table
	userQuery := `UPDATE users SET updated_at = ? WHERE id = ?`
	_, err = tx.ExecContext(ctx, userQuery, time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to update user: %w", err)
	}

	// Update profile
	var setClauses []string
	var args []interface{}

	if req.FirstName != nil {
		setClauses = append(setClauses, "first_name = ?")
		args = append(args, *req.FirstName)
	}
	if req.LastName != nil {
		setClauses = append(setClauses, "last_name = ?")
		args = append(args, *req.LastName)
	}
	if req.Company != nil {
		setClauses = append(setClauses, "company = ?")
		args = append(args, *req.Company)
	}
	if req.Phone != nil {
		setClauses = append(setClauses, "phone = ?")
		args = append(args, *req.Phone)
	}
	if req.Preferences != nil {
		prefsJSON, _ := json.Marshal(req.Preferences)
		setClauses = append(setClauses, "preferences = ?")
		args = append(args, string(prefsJSON))
	}

	if len(setClauses) > 0 {
		args = append(args, userID)
		profileQuery := fmt.Sprintf(
			"UPDATE user_profiles SET %s WHERE user_id = ?",
			strings.Join(setClauses, ", "),
		)

		_, err = tx.ExecContext(ctx, profileQuery, args...)
		if err != nil {
			return fmt.Errorf("failed to update profile: %w", err)
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// ValidatePassword checks if the provided password matches
func (r *Repository) ValidatePassword(user *User, password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
	return err == nil
}

// UpdatePassword updates user password
func (r *Repository) UpdatePassword(ctx context.Context, userID, newPassword string) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	query := `UPDATE users SET password_hash = ?, updated_at = ? WHERE id = ?`
	_, err = r.db.ExecContext(ctx, query, string(hashedPassword), time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	return nil
}

// UpdateLastLogin updates the last login timestamp
func (r *Repository) UpdateLastLogin(ctx context.Context, userID string) error {
	query := `UPDATE users SET last_login_at = ? WHERE id = ?`
	_, err := r.db.ExecContext(ctx, query, time.Now(), userID)
	return err
}

// UpdateUserTier updates subscription tier
func (r *Repository) UpdateUserTier(ctx context.Context, userID, tier string) error {
	query := `UPDATE users SET subscription_tier = ?, updated_at = ? WHERE id = ?`
	_, err := r.db.ExecContext(ctx, query, tier, time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to update user tier: %w", err)
	}
	return nil
}

// DeleteUser soft deletes a user
func (r *Repository) DeleteUser(ctx context.Context, userID string) error {
	query := `UPDATE users SET is_active = false, updated_at = ? WHERE id = ?`
	_, err := r.db.ExecContext(ctx, query, time.Now(), userID)
	if err != nil {
		return fmt.Errorf("failed to delete user: %w", err)
	}
	return nil
}
-------------------------------------------------
filepath = ./internal/auth-service/user/models.go
package user

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"
)

// User represents a user in the system
type User struct {
	ID               string     `json:"id" db:"id" example:"123e4567-e89b-12d3-a456-426614174000"`
	Email            string     `json:"email" db:"email" example:"john.doe@example.com"`
	PasswordHash     string     `json:"-" db:"password_hash"`
	Role             string     `json:"role" db:"role" example:"user"`
	ClientID         string     `json:"client_id" db:"client_id" example:"client-123"`
	SubscriptionTier string     `json:"subscription_tier" db:"subscription_tier" example:"premium"`
	IsActive         bool       `json:"is_active" db:"is_active" example:"true"`
	EmailVerified    bool       `json:"email_verified" db:"email_verified" example:"true"`
	CreatedAt        time.Time  `json:"created_at" db:"created_at" example:"2024-01-15T10:30:00Z"`
	UpdatedAt        time.Time  `json:"updated_at" db:"updated_at" example:"2024-07-17T14:45:00Z"`
	LastLoginAt      *time.Time `json:"last_login_at,omitempty" db:"last_login_at" example:"2024-07-17T10:00:00Z"`

	// Additional fields
	Profile     *UserProfile `json:"profile,omitempty"`
	Permissions []string     `json:"permissions,omitempty" example:"read:agents,write:agents,read:workflows"`
}

// UserProfile contains additional user information
type UserProfile struct {
	UserID      string `json:"user_id" db:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	FirstName   string `json:"first_name" db:"first_name" example:"John"`
	LastName    string `json:"last_name" db:"last_name" example:"Doe"`
	Company     string `json:"company,omitempty" db:"company" example:"Acme Corp"`
	Phone       string `json:"phone,omitempty" db:"phone" example:"+1-555-123-4567"`
	AvatarURL   string `json:"avatar_url,omitempty" db:"avatar_url" example:"https://example.com/avatar.jpg"`
	Preferences JSONB  `json:"preferences,omitempty" db:"preferences"`
}

// JSONB handles JSON data in database
type JSONB map[string]interface{}

// Value implements driver.Valuer interface
func (j JSONB) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan implements sql.Scanner interface
func (j *JSONB) Scan(value interface{}) error {
	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("failed to scan JSONB")
	}
	return json.Unmarshal(bytes, j)
}

// CreateUserRequest for user registration
type CreateUserRequest struct {
	Email     string `json:"email" binding:"required,email" example:"john.doe@example.com"`
	Password  string `json:"password" binding:"required,min=8" example:"SecurePassword123!"`
	ClientID  string `json:"client_id" binding:"required" example:"client-123"`
	FirstName string `json:"first_name" example:"John"`
	LastName  string `json:"last_name" example:"Doe"`
	Company   string `json:"company" example:"Acme Corp"`
}

// UpdateUserRequest for user updates
type UpdateUserRequest struct {
	FirstName   *string `json:"first_name" example:"Jane"`
	LastName    *string `json:"last_name" example:"Smith"`
	Company     *string `json:"company" example:"Tech Corp"`
	Phone       *string `json:"phone" example:"+1-555-987-6543"`
	Preferences *JSONB  `json:"preferences"`
}

// ChangePasswordRequest for password changes
type ChangePasswordRequest struct {
	CurrentPassword string `json:"current_password" binding:"required" example:"OldPassword123!"`
	NewPassword     string `json:"new_password" binding:"required,min=8" example:"NewSecurePassword456!"`
}
-------------------------------------------------
filepath = ./internal/auth-service/user/doc.go
// Package user contains all user management and profile operations.
//
// This package defines the data structures and handlers for all user-centric
// actions such as retrieving profiles, updating details, and managing passwords.
//
// swagger:meta
package user
-------------------------------------------------
filepath = ./internal/auth-service/user/service.go
package user

import (
	"context"
	"fmt"
	"strings"

	"github.com/gqls/agentchassis/internal/auth-service/jwt"
	"go.uber.org/zap"
)

// Service handles business logic for users
type Service struct {
	repo   *Repository
	logger *zap.Logger
}

// NewService creates a new user service
func NewService(repo *Repository, logger *zap.Logger) *Service {
	return &Service{
		repo:   repo,
		logger: logger,
	}
}

// Register creates a new user account
func (s *Service) Register(ctx context.Context, req *CreateUserRequest) (*User, error) {
	// Validate email format
	req.Email = strings.ToLower(strings.TrimSpace(req.Email))

	// Check if user already exists
	existingUser, _ := s.repo.GetUserByEmail(ctx, req.Email)
	if existingUser != nil {
		return nil, fmt.Errorf("user with email %s already exists", req.Email)
	}

	// Create user
	user, err := s.repo.CreateUser(ctx, req)
	if err != nil {
		s.logger.Error("Failed to create user", zap.Error(err))
		return nil, err
	}

	// TODO: Send verification email

	s.logger.Info("User registered successfully",
		zap.String("user_id", user.ID),
		zap.String("email", user.Email))

	return user, nil
}

// Login validates user credentials
func (s *Service) Login(ctx context.Context, email, password string) (*User, error) {
	email = strings.ToLower(strings.TrimSpace(email))

	user, err := s.repo.GetUserByEmail(ctx, email)
	if err != nil {
		s.logger.Warn("Login attempt for non-existent user", zap.String("email", email))
		return nil, fmt.Errorf("invalid credentials")
	}

	if !s.repo.ValidatePassword(user, password) {
		s.logger.Warn("Invalid password attempt", zap.String("user_id", user.ID))
		return nil, fmt.Errorf("invalid credentials")
	}

	if !user.IsActive {
		return nil, fmt.Errorf("account is disabled")
	}

	// Update last login
	if err := s.repo.UpdateLastLogin(ctx, user.ID); err != nil {
		s.logger.Error("Failed to update last login", zap.Error(err))
	}

	return user, nil
}

// GetUser retrieves user details
func (s *Service) GetUser(ctx context.Context, userID string) (*User, error) {
	return s.repo.GetUserByID(ctx, userID)
}

// GetUserInfo returns user info for JWT token generation
func (s *Service) GetUserInfo(ctx context.Context, userID string) (*jwt.UserInfo, error) {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	return &jwt.UserInfo{
		UserID:      user.ID,
		Email:       user.Email,
		ClientID:    user.ClientID,
		Role:        user.Role,
		Tier:        user.SubscriptionTier,
		Permissions: user.Permissions,
	}, nil
}

// UpdateUser updates user information
func (s *Service) UpdateUser(ctx context.Context, userID string, req *UpdateUserRequest) error {
	return s.repo.UpdateUser(ctx, userID, req)
}

// ChangePassword changes user password
func (s *Service) ChangePassword(ctx context.Context, userID string, req *ChangePasswordRequest) error {
	user, err := s.repo.GetUserByID(ctx, userID)
	if err != nil {
		return err
	}

	// Validate current password
	if !s.repo.ValidatePassword(user, req.CurrentPassword) {
		return fmt.Errorf("current password is incorrect")
	}

	// Update password
	return s.repo.UpdatePassword(ctx, userID, req.NewPassword)
}

// DeleteUser deletes a user account
func (s *Service) DeleteUser(ctx context.Context, userID string) error {
	return s.repo.DeleteUser(ctx, userID)
}
-------------------------------------------------
filepath = ./internal/auth-service/project/handlers_swagger.go
package project

// NOTE: This file contains swagger annotations for the project handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective files.

// ListProjects godoc
// @Summary      List projects
// @Description  Get a list of all projects for the authenticated user
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Success      200 {object} project.ProjectListResponse "List of projects retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects [get]
// @Security     Bearer
// @ID           listProjects

// CreateProject godoc
// @Summary      Create project
// @Description  Create a new project for the authenticated user
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        request body project.CreateProjectRequest true "Project details"
// @Success      201 {object} project.Project "Project created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      409 {object} map[string]interface{} "Project with this name already exists"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects [post]
// @Security     Bearer
// @ID           createProject

// GetProject godoc
// @Summary      Get project
// @Description  Get detailed information about a specific project
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        id path string true "Project ID"
// @Success      200 {object} project.Project "Project details retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - no access to this project"
// @Failure      404 {object} map[string]interface{} "Project not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects/{id} [get]
// @Security     Bearer
// @ID           getProject

// UpdateProject godoc
// @Summary      Update project
// @Description  Update an existing project
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        id path string true "Project ID"
// @Param        request body project.UpdateProjectRequest true "Project update details"
// @Success      200 {object} project.Project "Project updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - no access to this project"
// @Failure      404 {object} map[string]interface{} "Project not found"
// @Failure      409 {object} map[string]interface{} "Project name already in use"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects/{id} [put]
// @Security     Bearer
// @ID           updateProject

// DeleteProject godoc
// @Summary      Delete project
// @Description  Delete a project and all associated resources
// @Tags         Projects
// @Accept       json
// @Produce      json
// @Param        id path string true "Project ID"
// @Success      204 {string} string "Project deleted successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - no access to this project"
// @Failure      404 {object} map[string]interface{} "Project not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /projects/{id} [delete]
// @Security     Bearer
// @ID           deleteProject
-------------------------------------------------
filepath = ./internal/auth-service/project/handlers.go
// FILE: internal/auth-service/project/handlers.go
package project

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"
)

// HTTPHandler handles project-related HTTP requests
type HTTPHandler struct {
	repo   *Repository
	logger *zap.Logger
}

// NewHTTPHandler creates a new project HTTP handler
func NewHTTPHandler(repo *Repository, logger *zap.Logger) *HTTPHandler {
	return &HTTPHandler{
		repo:   repo,
		logger: logger,
	}
}

// CreateProjectRequest for creating a new project
type CreateProjectRequest struct {
	Name        string `json:"name" binding:"required" example:"My AI Assistant Project"`
	Description string `json:"description,omitempty" example:"A project for developing custom AI assistants"`
}

// UpdateProjectRequest for updating a project
type UpdateProjectRequest struct {
	Name        *string `json:"name,omitempty" example:"Updated Project Name"`
	Description *string `json:"description,omitempty" example:"Updated project description"`
}

// ProjectListResponse represents a list of projects
type ProjectListResponse struct {
	Projects []Project `json:"projects"`
	Count    int       `json:"count" example:"5"`
}

// CreateProject handles project creation
func (h *HTTPHandler) CreateProject(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	var req CreateProjectRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	project := &Project{
		ID:          uuid.New().String(),
		ClientID:    clientID,
		Name:        req.Name,
		Description: req.Description,
		OwnerID:     userID,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if err := h.repo.Create(r.Context(), project); err != nil {
		h.logger.Error("Failed to create project", zap.Error(err))
		http.Error(w, "Failed to create project", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(project)
}

// ListProjects returns all projects for a user
func (h *HTTPHandler) ListProjects(w http.ResponseWriter, r *http.Request) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	projects, err := h.repo.ListByUser(r.Context(), clientID, userID)
	if err != nil {
		h.logger.Error("Failed to list projects", zap.Error(err))
		http.Error(w, "Failed to retrieve projects", http.StatusInternalServerError)
		return
	}

	response := ProjectListResponse{
		Projects: projects,
		Count:    len(projects),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetProject returns a specific project
func (h *HTTPHandler) GetProject(w http.ResponseWriter, r *http.Request, projectID string) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	project, err := h.repo.GetByID(r.Context(), projectID)
	if err != nil {
		http.Error(w, "Project not found", http.StatusNotFound)
		return
	}

	// Verify ownership
	if project.ClientID != clientID || project.OwnerID != userID {
		http.Error(w, "Access denied", http.StatusForbidden)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(project)
}

// UpdateProject updates a project
func (h *HTTPHandler) UpdateProject(w http.ResponseWriter, r *http.Request, projectID string) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	// Verify ownership first
	project, err := h.repo.GetByID(r.Context(), projectID)
	if err != nil {
		http.Error(w, "Project not found", http.StatusNotFound)
		return
	}

	if project.ClientID != clientID || project.OwnerID != userID {
		http.Error(w, "Access denied", http.StatusForbidden)
		return
	}

	// Parse update request
	var req UpdateProjectRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Apply updates
	if req.Name != nil {
		project.Name = *req.Name
	}
	if req.Description != nil {
		project.Description = *req.Description
	}
	project.UpdatedAt = time.Now()

	if err := h.repo.Update(r.Context(), project); err != nil {
		h.logger.Error("Failed to update project", zap.Error(err))
		http.Error(w, "Failed to update project", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(project)
}

// DeleteProject deletes a project
func (h *HTTPHandler) DeleteProject(w http.ResponseWriter, r *http.Request, projectID string) {
	userID := r.Context().Value("user_id").(string)
	clientID := r.Context().Value("client_id").(string)

	// Verify ownership
	project, err := h.repo.GetByID(r.Context(), projectID)
	if err != nil {
		http.Error(w, "Project not found", http.StatusNotFound)
		return
	}

	if project.ClientID != clientID || project.OwnerID != userID {
		http.Error(w, "Access denied", http.StatusForbidden)
		return
	}

	if err := h.repo.Delete(r.Context(), projectID); err != nil {
		h.logger.Error("Failed to delete project", zap.Error(err))
		http.Error(w, "Failed to delete project", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}
-------------------------------------------------
filepath = ./internal/auth-service/project/repository.go
// FILE: internal/auth-service/project/repository.go
package project

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"go.uber.org/zap"
)

// Repository handles project data access
type Repository struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewRepository creates a new project repository
func NewRepository(db *sql.DB, logger *zap.Logger) *Repository {
	return &Repository{
		db:     db,
		logger: logger,
	}
}

// Create creates a new project
func (r *Repository) Create(ctx context.Context, project *Project) error {
	query := `
        INSERT INTO projects (id, client_id, name, description, owner_id, is_active, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `

	_, err := r.db.ExecContext(ctx, query,
		project.ID, project.ClientID, project.Name, project.Description,
		project.OwnerID, project.IsActive, project.CreatedAt, project.UpdatedAt,
	)

	if err != nil {
		return fmt.Errorf("failed to create project: %w", err)
	}

	return nil
}

// GetByID retrieves a project by ID
func (r *Repository) GetByID(ctx context.Context, id string) (*Project, error) {
	var p Project
	query := `
        SELECT id, client_id, name, description, owner_id, is_active, created_at, updated_at
        FROM projects
        WHERE id = ? AND is_active = true
    `

	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&p.ID, &p.ClientID, &p.Name, &p.Description,
		&p.OwnerID, &p.IsActive, &p.CreatedAt, &p.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("project not found")
		}
		return nil, err
	}

	return &p, nil
}

// ListByUser returns all projects for a user
func (r *Repository) ListByUser(ctx context.Context, clientID, userID string) ([]Project, error) {
	query := `
        SELECT id, client_id, name, description, owner_id, is_active, created_at, updated_at
        FROM projects
        WHERE client_id = ? AND owner_id = ? AND is_active = true
        ORDER BY created_at DESC
    `

	rows, err := r.db.QueryContext(ctx, query, clientID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var projects []Project
	for rows.Next() {
		var p Project
		if err := rows.Scan(
			&p.ID, &p.ClientID, &p.Name, &p.Description,
			&p.OwnerID, &p.IsActive, &p.CreatedAt, &p.UpdatedAt,
		); err != nil {
			r.logger.Error("Failed to scan project", zap.Error(err))
			continue
		}
		projects = append(projects, p)
	}

	return projects, nil
}

// Update updates a project
func (r *Repository) Update(ctx context.Context, project *Project) error {
	query := `
        UPDATE projects
        SET name = ?, description = ?, updated_at = ?
        WHERE id = ?
    `

	_, err := r.db.ExecContext(ctx, query,
		project.Name, project.Description, project.UpdatedAt, project.ID,
	)

	return err
}

// Delete soft deletes a project
func (r *Repository) Delete(ctx context.Context, id string) error {
	query := `
        UPDATE projects
        SET is_active = false, updated_at = ?
        WHERE id = ?
    `

	_, err := r.db.ExecContext(ctx, query, time.Now(), id)
	return err
}
-------------------------------------------------
filepath = ./internal/auth-service/project/models.go
// FILE: internal/auth-service/project/models.go
package project

import "time"

// Project represents a project in the system
type Project struct {
	ID          string    `json:"id" db:"id" example:"proj_123e4567-e89b-12d3-a456-426614174000"`
	ClientID    string    `json:"client_id" db:"client_id" example:"client-123"`
	Name        string    `json:"name" db:"name" example:"My AI Assistant Project"`
	Description string    `json:"description" db:"description" example:"A project for developing custom AI assistants"`
	OwnerID     string    `json:"owner_id" db:"owner_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	IsActive    bool      `json:"is_active" db:"is_active" example:"true"`
	CreatedAt   time.Time `json:"created_at" db:"created_at" example:"2024-01-15T10:30:00Z"`
	UpdatedAt   time.Time `json:"updated_at" db:"updated_at" example:"2024-07-17T14:45:00Z"`
}
-------------------------------------------------
filepath = ./internal/auth-service/subscription/handlers_swagger.go
package subscription

// NOTE: This file contains swagger annotations for the subscription handlers.
// Run `swag init` to generate the swagger documentation.
// All types are defined in their respective files.

// HandleGetSubscription godoc
// @Summary      Get current subscription
// @Description  Returns the current user's subscription details including tier, status, and expiry dates
// @Tags         Subscription
// @Accept       json
// @Produce      json
// @Success      200 {object} subscription.Subscription "Subscription retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      404 {object} map[string]interface{} "Subscription not found"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /subscription [get]
// @Security     Bearer
// @ID           getSubscription

// HandleGetUsageStats godoc
// @Summary      Get usage statistics
// @Description  Returns usage statistics for the current billing period including personas, projects, and content counts
// @Tags         Subscription
// @Accept       json
// @Produce      json
// @Success      200 {object} subscription.UsageStats "Usage statistics retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Failed to get usage stats"
// @Router       /subscription/usage [get]
// @Security     Bearer
// @ID           getUsageStats

// HandleCheckQuota godoc
// @Summary      Check resource quota
// @Description  Checks if the user has available quota for a specific resource type
// @Tags         Subscription
// @Accept       json
// @Produce      json
// @Param        resource query string true "Resource type to check" Enums(personas,projects,content)
// @Success      200 {object} subscription.QuotaCheckResponse "Quota check result"
// @Failure      400 {object} map[string]interface{} "Resource parameter required"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      500 {object} map[string]interface{} "Internal server error"
// @Router       /subscription/check-quota [get]
// @Security     Bearer
// @ID           checkQuota

// Admin endpoints

// HandleCreateSubscription godoc
// @Summary      Create subscription
// @Description  Creates a new subscription for a user (admin only)
// @Tags         Admin - Subscription
// @Accept       json
// @Produce      json
// @Param        request body subscription.CreateSubscriptionRequest true "Subscription creation details"
// @Success      201 {object} subscription.Subscription "Subscription created successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      409 {object} map[string]interface{} "User already has a subscription"
// @Failure      500 {object} map[string]interface{} "Failed to create subscription"
// @Router       /admin/subscriptions [post]
// @Security     Bearer
// @ID           adminCreateSubscription

// HandleUpdateSubscription godoc
// @Summary      Update subscription
// @Description  Updates an existing subscription tier or payment method (admin only)
// @Tags         Admin - Subscription
// @Accept       json
// @Produce      json
// @Param        user_id path string true "User ID"
// @Param        request body subscription.UpdateSubscriptionRequest true "Subscription update details"
// @Success      200 {object} subscription.Subscription "Subscription updated successfully"
// @Failure      400 {object} map[string]interface{} "Invalid request body"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      404 {object} map[string]interface{} "Subscription not found"
// @Failure      500 {object} map[string]interface{} "Failed to update subscription"
// @Router       /admin/subscriptions/{user_id} [put]
// @Security     Bearer
// @ID           adminUpdateSubscription

// HandleListSubscriptions godoc
// @Summary      List subscriptions
// @Description  Lists all subscriptions with pagination and filtering options (admin only)
// @Tags         Admin - Subscription
// @Accept       json
// @Produce      json
// @Param        page query int false "Page number" default(1) minimum(1)
// @Param        limit query int false "Items per page" default(50) minimum(1) maximum(200)
// @Param        status query string false "Filter by status" Enums(active,trialing,past_due,canceled,expired)
// @Param        tier query string false "Filter by tier" Enums(free,basic,premium,enterprise)
// @Success      200 {object} subscription.SubscriptionListResponse "List of subscriptions retrieved successfully"
// @Failure      401 {object} map[string]interface{} "Unauthorized - no valid token"
// @Failure      403 {object} map[string]interface{} "Forbidden - admin access required"
// @Failure      500 {object} map[string]interface{} "Failed to retrieve subscriptions"
// @Router       /admin/subscriptions [get]
// @Security     Bearer
// @ID           adminListSubscriptions
-------------------------------------------------
filepath = ./internal/auth-service/subscription/handlers.go
// FILE: internal/auth-service/subscription/handlers.go
package subscription

import (
	"go.uber.org/zap"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

// Handlers wraps the subscription service for HTTP handling
type Handlers struct {
	service *Service
}

// NewHandlers creates new subscription handlers
func NewHandlers(service *Service) *Handlers {
	return &Handlers{service: service}
}

// QuotaCheckResponse for quota verification results
type QuotaCheckResponse struct {
	HasQuota     bool   `json:"has_quota" example:"true"`
	Resource     string `json:"resource" example:"personas"`
	CurrentUsage int    `json:"current_usage,omitempty" example:"12"`
	MaxAllowed   int    `json:"max_allowed,omitempty" example:"50"`
	Remaining    int    `json:"remaining,omitempty" example:"38"`
}

// HandleGetSubscription returns the current user's subscription
func (h *Handlers) HandleGetSubscription(c *gin.Context) {
	userID := c.GetString("user_id")

	subscription, err := h.service.GetSubscription(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Subscription not found"})
		return
	}

	c.JSON(http.StatusOK, subscription)
}

// HandleGetUsageStats returns usage statistics
func (h *Handlers) HandleGetUsageStats(c *gin.Context) {
	userID := c.GetString("user_id")

	stats, err := h.service.GetUsageStats(c.Request.Context(), userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get usage stats"})
		return
	}

	c.JSON(http.StatusOK, stats)
}

// HandleCheckQuota checks if user has quota for a resource
func (h *Handlers) HandleCheckQuota(c *gin.Context) {
	userID := c.GetString("user_id")
	resource := c.Query("resource")

	if resource == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Resource parameter required"})
		return
	}

	hasQuota, err := h.service.CheckQuota(c.Request.Context(), userID, resource)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	response := QuotaCheckResponse{
		HasQuota: hasQuota,
		Resource: resource,
	}

	c.JSON(http.StatusOK, response)
}

// AdminHandlers for admin operations
type AdminHandlers struct {
	service *Service
	logger  *zap.Logger
}

// NewAdminHandlers creates admin handlers
func NewAdminHandlers(service *Service, logger *zap.Logger) *AdminHandlers {
	return &AdminHandlers{service: service, logger: logger}
}

// SubscriptionListResponse for paginated subscription lists
type SubscriptionListResponse struct {
	Subscriptions []Subscription `json:"subscriptions"`
	TotalCount    int            `json:"total_count" example:"156"`
	Page          int            `json:"page" example:"1"`
	Limit         int            `json:"limit" example:"50"`
	TotalPages    int            `json:"total_pages,omitempty" example:"4"`
}

// HandleCreateSubscription creates a subscription (admin only)
func (h *AdminHandlers) HandleCreateSubscription(c *gin.Context) {
	var req CreateSubscriptionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	subscription, err := h.service.CreateSubscription(c.Request.Context(), &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create subscription"})
		return
	}

	c.JSON(http.StatusCreated, subscription)
}

// HandleUpdateSubscription updates a subscription (admin only)
func (h *AdminHandlers) HandleUpdateSubscription(c *gin.Context) {
	userID := c.Param("user_id")

	var req UpdateSubscriptionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	subscription, err := h.service.UpdateSubscription(c.Request.Context(), userID, &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update subscription"})
		return
	}

	c.JSON(http.StatusOK, subscription)
}

// HandleListSubscriptions lists all subscriptions with filtering (admin only)
func (h *AdminHandlers) HandleListSubscriptions(c *gin.Context) {
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	if limit > 200 {
		limit = 200
	}
	if page < 1 {
		page = 1
	}

	params := ListSubscriptionsParams{
		Limit:  limit,
		Offset: (page - 1) * limit,
		Status: c.Query("status"),
		Tier:   c.Query("tier"),
	}

	subscriptions, total, err := h.service.repo.ListAll(c.Request.Context(), params)
	if err != nil {
		h.logger.Error("Failed to list subscriptions", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve subscriptions"})
		return
	}

	totalPages := (total + limit - 1) / limit

	response := SubscriptionListResponse{
		Subscriptions: subscriptions,
		TotalCount:    total,
		Page:          page,
		Limit:         limit,
		TotalPages:    totalPages,
	}

	c.JSON(http.StatusOK, response)
}
-------------------------------------------------
filepath = ./internal/auth-service/subscription/repository.go
// FILE: internal/auth-service/subscription/repository.go
package subscription

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"go.uber.org/zap"
)

// Repository handles subscription data access
type Repository struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewRepository creates a new subscription repository
func NewRepository(db *sql.DB, logger *zap.Logger) *Repository {
	return &Repository{
		db:     db,
		logger: logger,
	}
}

// GetByUserID retrieves a subscription by user ID
func (r *Repository) GetByUserID(ctx context.Context, userID string) (*Subscription, error) {
	var s Subscription
	query := `
		SELECT id, user_id, tier, status, start_date, end_date, trial_ends_at, 
		       cancelled_at, payment_method, stripe_customer_id, stripe_subscription_id,
		       created_at, updated_at
		FROM subscriptions
		WHERE user_id = ?
	`

	err := r.db.QueryRowContext(ctx, query, userID).Scan(
		&s.ID, &s.UserID, &s.Tier, &s.Status, &s.StartDate, &s.EndDate,
		&s.TrialEndsAt, &s.CancelledAt, &s.PaymentMethod,
		&s.StripeCustomerID, &s.StripeSubscriptionID,
		&s.CreatedAt, &s.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("subscription not found")
		}
		return nil, err
	}

	return &s, nil
}

// Create creates a new subscription
func (r *Repository) Create(ctx context.Context, s *Subscription) error {
	query := `
		INSERT INTO subscriptions (id, user_id, tier, status, start_date, payment_method,
		                          trial_ends_at, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
	`

	_, err := r.db.ExecContext(ctx, query,
		s.ID, s.UserID, s.Tier, s.Status, s.StartDate,
		s.PaymentMethod, s.TrialEndsAt, s.CreatedAt, s.UpdatedAt,
	)

	return err
}

// Update updates an existing subscription
func (r *Repository) Update(ctx context.Context, s *Subscription) error {
	query := `
		UPDATE subscriptions 
		SET tier = ?, status = ?, payment_method = ?, updated_at = ?
		WHERE id = ?
	`

	_, err := r.db.ExecContext(ctx, query,
		s.Tier, s.Status, s.PaymentMethod, s.UpdatedAt, s.ID,
	)

	return err
}

// Cancel cancels a subscription
func (r *Repository) Cancel(ctx context.Context, userID string, cancelledAt time.Time) error {
	query := `
		UPDATE subscriptions 
		SET status = ?, cancelled_at = ?, updated_at = ?
		WHERE user_id = ?
	`

	_, err := r.db.ExecContext(ctx, query,
		StatusCanceled, cancelledAt, time.Now(), userID,
	)

	return err
}

// GetTier retrieves tier information
func (r *Repository) GetTier(ctx context.Context, tierName string) (*SubscriptionTier, error) {
	var t SubscriptionTier
	var featuresJSON string

	query := `
		SELECT id, name, display_name, description, price_monthly, price_yearly,
		       max_personas, max_projects, max_content_items, features, is_active
		FROM subscription_tiers
		WHERE name = ? AND is_active = true
	`

	err := r.db.QueryRowContext(ctx, query, tierName).Scan(
		&t.ID, &t.Name, &t.DisplayName, &t.Description,
		&t.PriceMonthly, &t.PriceYearly,
		&t.MaxPersonas, &t.MaxProjects, &t.MaxContentItems,
		&featuresJSON, &t.IsActive,
	)

	if err != nil {
		return nil, err
	}

	json.Unmarshal([]byte(featuresJSON), &t.Features)

	return &t, nil
}

// GetUsageStats retrieves usage statistics
func (r *Repository) GetUsageStats(ctx context.Context, userID string) (*UsageStats, error) {
	var stats UsageStats
	stats.UserID = userID

	// This would need to query across multiple tables/schemas
	// For now, returning mock data
	stats.PersonasCount = 0
	stats.ProjectsCount = 0
	stats.ContentCount = 0
	stats.LastUpdated = time.Now()

	return &stats, nil
}

// ListSubscriptionsParams contains parameters for listing subscriptions
type ListSubscriptionsParams struct {
	Limit  int
	Offset int
	Status string
	Tier   string
}

// ListAll retrieves a paginated list of all subscriptions
func (r *Repository) ListAll(ctx context.Context, params ListSubscriptionsParams) ([]Subscription, int, error) {
	query := `SELECT id, user_id, tier, status, start_date, end_date, created_at FROM subscriptions WHERE 1=1`
	countQuery := `SELECT COUNT(*) FROM subscriptions WHERE 1=1`

	args := []interface{}{}
	count := 1

	if params.Status != "" {
		query += fmt.Sprintf(" AND status = $%d", count)
		countQuery += fmt.Sprintf(" AND status = $%d", count)
		args = append(args, params.Status)
		count++
	}
	if params.Tier != "" {
		query += fmt.Sprintf(" AND tier = $%d", count)
		countQuery += fmt.Sprintf(" AND tier = $%d", count)
		args = append(args, params.Tier)
		count++
	}

	query += fmt.Sprintf(" ORDER BY created_at DESC LIMIT $%d OFFSET $%d", count, count+1)
	args = append(args, params.Limit, params.Offset)

	// Get total count
	var total int
	if err := r.db.QueryRowContext(ctx, countQuery, args[:count-1]...).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("failed to get subscription count: %w", err)
	}

	// Get subscriptions
	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list subscriptions: %w", err)
	}
	defer rows.Close()

	var subscriptions []Subscription
	for rows.Next() {
		var s Subscription
		if err := rows.Scan(&s.ID, &s.UserID, &s.Tier, &s.Status, &s.StartDate, &s.EndDate, &s.CreatedAt); err != nil {
			r.logger.Error("Failed to scan subscription row", zap.Error(err))
			continue
		}
		subscriptions = append(subscriptions, s)
	}

	return subscriptions, total, nil
}
-------------------------------------------------
filepath = ./internal/auth-service/subscription/models.go
package subscription

import (
	"time"
)

// Subscription represents a user's subscription
type Subscription struct {
	ID                   string     `json:"id" db:"id" example:"sub_123e4567-e89b-12d3-a456-426614174000"`
	UserID               string     `json:"user_id" db:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	Tier                 string     `json:"tier" db:"tier" example:"premium"`
	Status               string     `json:"status" db:"status" example:"active"`
	StartDate            time.Time  `json:"start_date" db:"start_date" example:"2024-01-15T10:30:00Z"`
	EndDate              *time.Time `json:"end_date,omitempty" db:"end_date" example:"2024-12-31T23:59:59Z"`
	TrialEndsAt          *time.Time `json:"trial_ends_at,omitempty" db:"trial_ends_at" example:"2024-02-14T23:59:59Z"`
	CancelledAt          *time.Time `json:"cancelled_at,omitempty" db:"cancelled_at" example:"2024-06-30T15:00:00Z"`
	PaymentMethod        string     `json:"payment_method" db:"payment_method" example:"pm_1234567890"`
	StripeCustomerID     string     `json:"-" db:"stripe_customer_id"`
	StripeSubscriptionID string     `json:"-" db:"stripe_subscription_id"`
	CreatedAt            time.Time  `json:"created_at" db:"created_at" example:"2024-01-15T10:30:00Z"`
	UpdatedAt            time.Time  `json:"updated_at" db:"updated_at" example:"2024-07-17T14:45:00Z"`
}

// SubscriptionTier defines tier details
type SubscriptionTier struct {
	ID              string   `json:"id" db:"id" example:"tier_premium"`
	Name            string   `json:"name" db:"name" example:"premium"`
	DisplayName     string   `json:"display_name" db:"display_name" example:"Premium Plan"`
	Description     string   `json:"description" db:"description" example:"Perfect for growing teams and businesses"`
	PriceMonthly    float64  `json:"price_monthly" db:"price_monthly" example:"49.99"`
	PriceYearly     float64  `json:"price_yearly" db:"price_yearly" example:"479.99"`
	MaxPersonas     int      `json:"max_personas" db:"max_personas" example:"50"`
	MaxProjects     int      `json:"max_projects" db:"max_projects" example:"20"`
	MaxContentItems int      `json:"max_content_items" db:"max_content_items" example:"10000"`
	Features        []string `json:"features" db:"features" example:"Advanced Analytics,API Access,Priority Support,Custom Integrations"`
	IsActive        bool     `json:"is_active" db:"is_active" example:"true"`
}

// UsageStats tracks user's resource usage
type UsageStats struct {
	UserID        string    `json:"user_id" db:"user_id" example:"123e4567-e89b-12d3-a456-426614174000"`
	PersonasCount int       `json:"personas_count" db:"personas_count" example:"12"`
	ProjectsCount int       `json:"projects_count" db:"projects_count" example:"5"`
	ContentCount  int       `json:"content_count" db:"content_count" example:"1234"`
	LastUpdated   time.Time `json:"last_updated" db:"last_updated" example:"2024-07-17T14:30:00Z"`
}

// SubscriptionStatus constants
const (
	StatusActive   = "active"
	StatusTrialing = "trialing"
	StatusPastDue  = "past_due"
	StatusCanceled = "canceled"
	StatusExpired  = "expired"
)

// Tier constants
const (
	TierFree       = "free"
	TierBasic      = "basic"
	TierPremium    = "premium"
	TierEnterprise = "enterprise"
)

// CreateSubscriptionRequest for new subscriptions
type CreateSubscriptionRequest struct {
	UserID          string `json:"user_id" binding:"required" example:"123e4567-e89b-12d3-a456-426614174000"`
	Tier            string `json:"tier" binding:"required" example:"premium"`
	PaymentMethodID string `json:"payment_method_id" example:"pm_1234567890"`
	TrialDays       int    `json:"trial_days" example:"14"`
}

// UpdateSubscriptionRequest for subscription changes
type UpdateSubscriptionRequest struct {
	Tier            *string `json:"tier" example:"enterprise"`
	PaymentMethodID *string `json:"payment_method_id" example:"pm_0987654321"`
}

// CheckoutSession for payment processing
type CheckoutSession struct {
	ID         string `json:"id" example:"cs_test_a1b2c3d4e5f6"`
	URL        string `json:"url" example:"https://checkout.stripe.com/pay/cs_test_a1b2c3d4e5f6"`
	SuccessURL string `json:"success_url" example:"https://app.example.com/subscription/success"`
	CancelURL  string `json:"cancel_url" example:"https://app.example.com/subscription/cancelled"`
	ExpiresAt  int64  `json:"expires_at" example:"1689696000"`
}
-------------------------------------------------
filepath = ./internal/auth-service/subscription/service.go
// FILE: internal/auth-service/subscription/service.go
package subscription

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"
)

// Service handles subscription business logic
type Service struct {
	repo   *Repository
	logger *zap.Logger
}

// NewService creates a new subscription service
func NewService(repo *Repository, logger *zap.Logger) *Service {
	return &Service{
		repo:   repo,
		logger: logger,
	}
}

// GetSubscription retrieves a user's subscription
func (s *Service) GetSubscription(ctx context.Context, userID string) (*Subscription, error) {
	return s.repo.GetByUserID(ctx, userID)
}

// CreateSubscription creates a new subscription
func (s *Service) CreateSubscription(ctx context.Context, req *CreateSubscriptionRequest) (*Subscription, error) {
	subscription := &Subscription{
		ID:            uuid.New().String(),
		UserID:        req.UserID,
		Tier:          req.Tier,
		Status:        StatusActive,
		StartDate:     time.Now(),
		PaymentMethod: req.PaymentMethodID,
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	if req.TrialDays > 0 {
		trialEnd := time.Now().AddDate(0, 0, req.TrialDays)
		subscription.TrialEndsAt = &trialEnd
		subscription.Status = StatusTrialing
	}

	if err := s.repo.Create(ctx, subscription); err != nil {
		return nil, fmt.Errorf("failed to create subscription: %w", err)
	}

	return subscription, nil
}

// UpdateSubscription updates an existing subscription
func (s *Service) UpdateSubscription(ctx context.Context, userID string, req *UpdateSubscriptionRequest) (*Subscription, error) {
	subscription, err := s.repo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	if req.Tier != nil {
		subscription.Tier = *req.Tier
	}

	if req.PaymentMethodID != nil {
		subscription.PaymentMethod = *req.PaymentMethodID
	}

	subscription.UpdatedAt = time.Now()

	if err := s.repo.Update(ctx, subscription); err != nil {
		return nil, fmt.Errorf("failed to update subscription: %w", err)
	}

	return subscription, nil
}

// CancelSubscription cancels a subscription
func (s *Service) CancelSubscription(ctx context.Context, userID string) error {
	now := time.Now()
	return s.repo.Cancel(ctx, userID, now)
}

// GetUsageStats retrieves usage statistics for a user
func (s *Service) GetUsageStats(ctx context.Context, userID string) (*UsageStats, error) {
	return s.repo.GetUsageStats(ctx, userID)
}

// CheckQuota checks if a user has quota for a specific resource
func (s *Service) CheckQuota(ctx context.Context, userID string, resource string) (bool, error) {
	subscription, err := s.GetSubscription(ctx, userID)
	if err != nil {
		return false, err
	}

	tier, err := s.repo.GetTier(ctx, subscription.Tier)
	if err != nil {
		return false, err
	}

	usage, err := s.GetUsageStats(ctx, userID)
	if err != nil {
		return false, err
	}

	switch resource {
	case "personas":
		return tier.MaxPersonas == -1 || usage.PersonasCount < tier.MaxPersonas, nil
	case "projects":
		return tier.MaxProjects == -1 || usage.ProjectsCount < tier.MaxProjects, nil
	case "content":
		return tier.MaxContentItems == -1 || usage.ContentCount < tier.MaxContentItems, nil
	default:
		return false, fmt.Errorf("unknown resource type: %s", resource)
	}
}
-------------------------------------------------
filepath = ./platform/database/migrations/001_enable_pgvector.sql
-- FILE: platform/database/migrations/001_enable_pgvector.sql
-- Run this on the clients database as superuser
CREATE EXTENSION IF NOT EXISTS vector;
-------------------------------------------------
filepath = ./platform/database/migrations/005_projects_schema.sql
// FILE: platform/database/migrations/005_projects_schema.sql
-- Projects table for auth database
CREATE TABLE IF NOT EXISTS projects (
                                        id VARCHAR(36) PRIMARY KEY,
    client_id VARCHAR(100) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    owner_id VARCHAR(36) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (owner_id) REFERENCES users(id),
    INDEX idx_projects_client (client_id),
    INDEX idx_projects_owner (owner_id)
    );

-- Subscriptions table
CREATE TABLE IF NOT EXISTS subscriptions (
                                             id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL UNIQUE,
    tier VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL,
    start_date TIMESTAMPTZ NOT NULL,
    end_date TIMESTAMPTZ,
    trial_ends_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,
    payment_method VARCHAR(100),
    stripe_customer_id VARCHAR(255),
    stripe_subscription_id VARCHAR(255),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(id),
    INDEX idx_subscriptions_status (status)
    );

-- Subscription tiers table
CREATE TABLE IF NOT EXISTS subscription_tiers (
                                                  id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    price_monthly DECIMAL(10,2) NOT NULL,
    price_yearly DECIMAL(10,2) NOT NULL,
    max_personas INT NOT NULL,
    max_projects INT NOT NULL,
    max_content_items INT NOT NULL,
    features JSON,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- Insert default tiers
INSERT INTO subscription_tiers (id, name, display_name, description, price_monthly, price_yearly, max_personas, max_projects, max_content_items, features) VALUES
                                                                                                                                                               ('00000000-0000-0000-0000-000000000001', 'free', 'Free', 'Basic features for getting started', 0.00, 0.00, 1, 3, 10, '["Basic personas", "Limited content generation"]'),
                                                                                                                                                               ('00000000-0000-0000-0000-000000000002', 'basic', 'Basic', 'For individual users', 9.99, 99.99, 5, 10, 100, '["All persona types", "Priority support", "Advanced templates"]'),
                                                                                                                                                               ('00000000-0000-0000-0000-000000000003', 'premium', 'Premium', 'For power users', 29.99, 299.99, 20, 50, 1000, '["All basic features", "Custom personas", "API access", "Analytics"]'),
                                                                                                                                                               ('00000000-0000-0000-0000-000000000004', 'enterprise', 'Enterprise', 'For organizations', 99.99, 999.99, -1, -1, -1, '["All premium features", "Unlimited usage", "Dedicated support", "Custom integrations"]');

-- User profiles table
CREATE TABLE IF NOT EXISTS user_profiles (
                                             user_id VARCHAR(36) PRIMARY KEY,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    company VARCHAR(255),
    phone VARCHAR(50),
    avatar_url VARCHAR(500),
    preferences JSON,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(id)
    );

-- Permissions table
CREATE TABLE IF NOT EXISTS permissions (
                                           id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- User permissions junction table
CREATE TABLE IF NOT EXISTS user_permissions (
                                                user_id VARCHAR(36) NOT NULL,
    permission_id VARCHAR(36) NOT NULL,
    granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (user_id, permission_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (permission_id) REFERENCES permissions(id)
    );

-- Insert default permissions
INSERT INTO permissions (id, name, description) VALUES
                                                    ('00000000-0000-0000-0000-000000000001', 'personas.create', 'Create new personas'),
                                                    ('00000000-0000-0000-0000-000000000002', 'personas.delete', 'Delete personas'),
                                                    ('00000000-0000-0000-0000-000000000003', 'projects.manage', 'Manage all projects'),
                                                    ('00000000-0000-0000-0000-000000000004', 'admin.users', 'Manage users'),
                                                    ('00000000-0000-0000-0000-000000000005', 'admin.subscriptions', 'Manage subscriptions'),
                                                    ('00000000-0000-0000-0000-000000000006', '*', 'Super admin - all permissions');-------------------------------------------------
filepath = ./platform/database/migrations/003_create_client_schema.sql
-- FILE: platform/database/migrations/003_create_client_schema.sql


-- Enable required extensions

-- Global agent definitions table (shared across all clients)
CREATE TABLE IF NOT EXISTS agent_definitions (
                                                 id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(100) NOT NULL UNIQUE,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL CHECK (category IN ('data-driven', 'code-driven', 'adapter')),
    default_config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
    );

-- Index for active agent types
CREATE INDEX IF NOT EXISTS idx_agent_definitions_type_active
    ON agent_definitions(type, is_active) WHERE deleted_at IS NULL;

-- Global orchestrator state table (shared across all clients)
CREATE TABLE IF NOT EXISTS orchestrator_state (
                                                  correlation_id UUID PRIMARY KEY,
                                                  client_id VARCHAR(100) NOT NULL,
    status VARCHAR(50) NOT NULL,
    current_step VARCHAR(255) NOT NULL,
    awaited_steps JSONB DEFAULT '[]',
    collected_data JSONB DEFAULT '{}',
    initial_request_data JSONB,
    final_result JSONB,
    error TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- Indexes for orchestrator state
CREATE INDEX IF NOT EXISTS idx_orchestrator_state_status ON orchestrator_state(status);
CREATE INDEX IF NOT EXISTS idx_orchestrator_state_client ON orchestrator_state(client_id);
CREATE INDEX IF NOT EXISTS idx_orchestrator_state_updated_at ON orchestrator_state(updated_at);

-- Function to create client-specific schema
CREATE OR REPLACE FUNCTION create_client_schema(client_id TEXT)
RETURNS VOID AS $$
DECLARE
schema_name TEXT := 'client_' || client_id;
BEGIN
    -- Create schema
EXECUTE format('CREATE SCHEMA IF NOT EXISTS %I', schema_name);

-- Agent instances table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.agent_instances (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            template_id UUID NOT NULL,
            owner_user_id VARCHAR(255) NOT NULL,
            name VARCHAR(255) NOT NULL,
            config JSONB NOT NULL DEFAULT ''{}''::jsonb,
            is_active BOOLEAN DEFAULT true,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name);

-- Indexes for agent instances
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_instances_owner
        ON %I.agent_instances(owner_user_id)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_instances_template
        ON %I.agent_instances(template_id)', schema_name);

-- Agent memory table with vector support
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.agent_memory (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            agent_instance_id UUID NOT NULL REFERENCES %I.agent_instances(id),
            content TEXT NOT NULL,
            embedding vector(1536) NOT NULL,
            metadata JSONB DEFAULT ''{}''::jsonb,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name, schema_name);

-- Vector index for similarity search
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_memory_embedding
        ON %I.agent_memory USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100)', schema_name);

-- Index for agent memory queries
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_memory_agent_created
        ON %I.agent_memory(agent_instance_id, created_at DESC)', schema_name);

-- Projects table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.projects (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            name VARCHAR(255) NOT NULL,
            description TEXT,
            owner_user_id VARCHAR(255) NOT NULL,
            settings JSONB DEFAULT ''{}''::jsonb,
            is_active BOOLEAN DEFAULT true,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name);

-- Index for project queries
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_projects_owner
        ON %I.projects(owner_user_id)', schema_name);

-- Workflow executions table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.workflow_executions (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            correlation_id UUID NOT NULL,
            project_id UUID REFERENCES %I.projects(id),
            agent_instance_id UUID REFERENCES %I.agent_instances(id),
            status VARCHAR(50) NOT NULL,
            input_data JSONB,
            output_data JSONB,
            error_message TEXT,
            started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            completed_at TIMESTAMPTZ,
            created_by VARCHAR(255) NOT NULL
        )', schema_name, schema_name, schema_name);

-- Indexes for workflow executions
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_workflow_executions_correlation
        ON %I.workflow_executions(correlation_id)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_workflow_executions_status
        ON %I.workflow_executions(status)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_workflow_executions_project
        ON %I.workflow_executions(project_id)', schema_name);

-- Usage analytics table for this client
EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I.usage_analytics (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id VARCHAR(255) NOT NULL,
            agent_type VARCHAR(100) NOT NULL,
            action VARCHAR(100) NOT NULL,
            fuel_consumed INTEGER NOT NULL DEFAULT 0,
            execution_time_ms INTEGER,
            success BOOLEAN NOT NULL,
            metadata JSONB DEFAULT ''{}''::jsonb,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )', schema_name);

-- Indexes for analytics
EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_usage_analytics_user_date
        ON %I.usage_analytics(user_id, created_at)', schema_name);

EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_usage_analytics_agent_type
        ON %I.usage_analytics(agent_type, created_at)', schema_name);

END;
$$ LANGUAGE plpgsql;

-- Insert default agent definitions
INSERT INTO agent_definitions (type, display_name, description, category, default_config) VALUES
                                                                                              ('copywriter', 'Copywriter', 'Creates compelling marketing and content copy', 'data-driven', '{"model": "claude-3-sonnet", "temperature": 0.7}'),
                                                                                              ('researcher', 'Research Assistant', 'Conducts thorough research and analysis', 'data-driven', '{"model": "claude-3-opus", "temperature": 0.3}'),
                                                                                              ('reasoning', 'Reasoning Agent', 'Performs logical analysis and decision making', 'code-driven', '{"model": "claude-3-opus", "temperature": 0.2}'),
                                                                                              ('image-generator', 'Image Generator', 'Creates images using AI generation', 'adapter', '{"provider": "stability_ai", "model": "sdxl"}'),
                                                                                              ('web-search', 'Web Search', 'Searches the internet for information', 'adapter', '{"provider": "serpapi", "max_results": 10}')
    ON CONFLICT (type) DO UPDATE SET
    display_name = EXCLUDED.display_name,
                              description = EXCLUDED.description,
                              category = EXCLUDED.category,
                              default_config = EXCLUDED.default_config,
                              updated_at = NOW();

-- Create a demo client schema for testing
SELECT create_client_schema('demo_client');


-- This should be run for each new client
-- Replace {client_id} with actual client ID

CREATE SCHEMA IF NOT EXISTS client_{client_id};

-- Agent instances table
CREATE TABLE IF NOT EXISTS client_{client_id}.agent_instances (
                                                                  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id UUID NOT NULL,
    owner_user_id VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_instances_owner ON client_{client_id}.agent_instances(owner_user_id);
CREATE INDEX idx_instances_template ON client_{client_id}.agent_instances(template_id);

-- Agent memory table with vector support
CREATE TABLE IF NOT EXISTS client_{client_id}.agent_memory (
                                                               id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_instance_id UUID NOT NULL REFERENCES client_{client_id}.agent_instances(id),
    content TEXT NOT NULL,
    embedding vector(1536) NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

-- Create vector index for similarity search
CREATE INDEX ON client_{client_id}.agent_memory USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- Orchestrator state table
CREATE TABLE IF NOT EXISTS client_{client_id}.orchestrator_state (
                                                                     correlation_id UUID PRIMARY KEY,
                                                                     status VARCHAR(50) NOT NULL,
    current_step VARCHAR(255) NOT NULL,
    awaited_steps JSONB DEFAULT '[]',
    collected_data JSONB DEFAULT '{}',
    initial_request_data JSONB,
    final_result JSONB,
    error TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_orchestrator_status ON client_{client_id}.orchestrator_state(status);

CREATE INDEX idx_memory_agent_created ON client_{client_id}.agent_memory(agent_instance_id, created_at DESC);
-------------------------------------------------
filepath = ./platform/database/migrations/004_auth_schema.sql
-- FILE: platform/database/migrations/004_auth_schema.sql
-- Auth database schema
CREATE TABLE IF NOT EXISTS users (
                                     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user',
    client_id VARCHAR(100) NOT NULL,
    subscription_tier VARCHAR(50) DEFAULT 'free',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_client ON users(client_id);

CREATE TABLE IF NOT EXISTS auth_tokens (
                                           id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    token_hash VARCHAR(255) NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_tokens_user ON auth_tokens(user_id);
CREATE INDEX idx_tokens_expires ON auth_tokens(expires_at);

CREATE INDEX idx_users_email_active ON users(email, is_active);-------------------------------------------------
filepath = ./platform/database/migrations/002_create_templates_schema.sql
-- FILE: platform/database/migrations/002_create_templates_schema.sql
-- Templates database schema
CREATE TABLE IF NOT EXISTS persona_templates (
                                                 id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

CREATE INDEX idx_templates_category ON persona_templates(category);
CREATE INDEX idx_templates_active ON persona_templates(is_active);
-------------------------------------------------
